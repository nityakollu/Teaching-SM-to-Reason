problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	Use QF_UF and QF_LIA axioms to prove that a valid schedule can be constructed from a given set of jobs with different durations.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the linear programming relaxation of the knapsack problem	Using QF_UF with an interval representation to solve this linear program	"(assert true)
(check-sat)"
Scheduling Problem	Integer linear programming to optimize task allocation on a machine with multiple processing units.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	# Use QF_UF and QF_LIA rules with simple integer constraints to model the scheduling problem. The SMT-LIB program should include the following constraints: # A must be executed by processor C1 P_A <= P_C1 * 2; # Assign tasks to processors based on their capabilities # B must be executed by processor C2 P_B <= P_C2 * 3; # Assign tasks to processors based on their capabilities # Check if the assignment satisfies all constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfies the linear programming relaxation of the flow network of scheduling problem with three nodes and four edges, where each edge has two capacities.	This problem can be solved using the flow network solver of SMT-LIB.	"(assert true)
(check-sat)"
Scheduling Problem	Construct a scheduling problem with two tasks that cannot be scheduled together.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling: max-work-hours	assert (set-logic QF_UF) and (declare-const hours 1: integer) and (declare-const total_hours 0: integer) and (assert (=, total_hours, sumhours(hours))) and (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA with simple integer and boolean constraints to model a scheduling algorithm that assigns jobs to machines based on their processing time and machine capacity.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF with integer variables	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF to solve this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
\(\setoflucore uf) \+ (\declareconst i32 x 10)	\(\checksat (\assert true) \| (\checksat false))	"(declare-const i32 Int)
(declare-const uf Int)
(assert (and (<= 1 i32) (<= i32 10)))
(assert (and (<= 1 uf) (<= uf 10)))
(assert (distinct i32 uf))
(check-sat)"
Scheduling Problem	Use QF_UF to model scheduling as a maximization problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
{'type': 'scheduling', 'domain': 'transportation'}	{'type': 'explanation', 'domain': 'scheduling'}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Check if this scheduling problem is solvable in practice.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a scheduling problem	{'approach': 'brute-force', 'search': 'depth-first'}	"(assert true)
(check-sat)"
\(declare-const x 0: Int\); (set-logic QF_UF)\n(declare-const y 1: Boolean; (assert \(x = true; \))\n(check-sat)	Using the properties of equality and union to derive new constraints	"(declare-const n Int)
(declare-const x Int)
(assert (and (<= 1 n) (<= n 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct n x))
(check-sat)"
Scheduling Problem	Use QF_LIA and set-logic QF_UF to generate constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling problem to minimize make times and meet deadlines	Use QF_UF and QF_LIA rules to analyze constraints on machine times and resource utilization.	"(assert true)
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to enforce valid scheduling rules	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF with linear constraints to model a scheduling problem where tasks are assigned to time slots and their start times must be within a certain range.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to model the scheduling of tasks on a shared resource.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA SMT-LIB rules to derive a valid scheduling plan.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to generate valid constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Minimize Latency	Use QF_LIA and set-logic QF_UF to ensure validity and correctness.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find an assignment that satisfies all constraints	Using QF_UF and QF_LIA, derive valid integer constraints to satisfy the scheduling problem.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_LIA to reason about scheduling constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Maximize the number of customers served while minimizing idle time	Use QF_UF and QF_LIA rules to model the scheduling problem, including constraints on customer arrival and departure times, as well as idle time.	"(assert true)
(check-sat)"
Scheduling Problem: Find an optimal assignment of jobs to machines in a factory	Use QF_UF and QF_LIA rules to solve this scheduling problem, ensuring that all constraints are satisfied exactly.	"(declare-const a_of Bool)
(declare-const a_to Bool)
(declare-const an_of Bool)
(declare-const an_to Bool)
(declare-const in_of Bool)
(declare-const in_to Bool)
(assert (= (+
  (ite a_of 1 0)
  (ite an_of 1 0)
  (ite in_of 1 0)
) 1))
(assert (= (+
  (ite a_to 1 0)
  (ite an_to 1 0)
  (ite in_to 1 0)
) 1))
(assert (<= (+
  (ite a_of 1 0)
  (ite a_to 1 0)
) 1))
(assert (<= (+
  (ite an_of 1 0)
  (ite an_to 1 0)
) 1))
(assert (<= (+
  (ite in_of 1 0)
  (ite in_to 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to solve the scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
(set-logic QF_UF  (declare-const x int)  (declare-const y int)  (assert (>= x 0)    (<= y 10) )	This is a problem that will be solved using SMT-LIB.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Scheduling Problem	Formally specify scheduling constraints using QF_UF and QF_LIA.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the parity of three signals in a 3D system	Use QF_UF with equality constraints and set-logic QF_LIA to enforce non-increasing order.	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Satisfy the following scheduling constraint: Minimize make_time(1, 2) + make_time(3, 4)	Use QF_UF and QF_LIA constraints to ensure that make_time(1, 2) <= make_time(3, 4).	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to prove the satisfiability of the scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA clauses to model the scheduling of tasks on a single processor.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a scheduling conflict on multiple servers	Using QF_UF and QF_LIA to ensure tight coupling between tasks and servers, while respecting resource constraints.	"(declare-const a Int)
(declare-const on Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 on) (<= on 10)))
(assert (distinct a on))
(check-sat)"
Scheduling Problem: Resource Allocation	Use QF_UF and QF_LIA constraints to model resource allocation in a scheduling problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF to define sets of variables and use QF_LIA to check consistency.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Maximize Productivity with Limited Time	This problem can be solved using QF_UF and QF_LIA constraints to ensure that the production of products does not exceed the available time.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	{'constraints': ['(set-logic QF_UF)', '(declare-const X 1)', '(declare-const Y 2)', '(assert (<= X 10))'], 'clauses': ['(check-sat)']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling problem with no conflicts	Use QF_LIA to model this scheduling problem without conflicts.	"(assert true)
(check-sat)"
Scheduling Problem	This problem uses QF_UF and QF_LIA formulas to model a real-time system.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and check-sat to prove the validity of the program, which asserts that there exists an integer solution to the scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	{'constraint_type': 'integer_lower_bound', 'variables': ['x', 'y'], 'constraints': ['(set-logic QF_UF)', '(declare-const x int)', '(declare-const y int)', '(assert (>= x 0))', '(assert (<= y 10))']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Integer Constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the following linear programming relaxation of the 8-hour workday problem with additional constraints	Using QF_UF and QF_LIA, derive the solution to a system of linear equations representing the 8-hour workday problem, where employees are only allowed to work up to 40 hours per week.	"(assert true)
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to prove validity	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Maximize Customer Satisfaction	Use QF_UF or QF_LIA to generate a valid model and check its satisfiability.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Formulate a valid schedule that satisfies all constraints and meets the deadline.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	{'type': 'clausal', 'constraints': ['(set-logic QF_UF)', '(declare-const x Int)', '(declare-const y Bool)', '(assert (not (= x 0)))']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to model this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Find all valid solutions to the following system of linear equations with two variables.	Use QF_LIA and integer constraints to solve this system.	"(declare-const of Int)
(declare-const to Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct of to))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to ensure valid constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling: maximize {x, y} where x is the number of customers served in the first hour and y is the number of customers served in the last hour	The goal is to maximize the total number of customers served within a fixed time frame. This can be achieved by prioritizing customers based on their arrival times.	"(declare-const in Int)
(declare-const is Int)
(assert (and (<= 1 in) (<= in 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct in is))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA constraints to model a scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	To solve the scheduling problem, we need to find an assignment of tasks to machines that satisfies all constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find the optimal assignment of tasks to machines	Use QF_UF and QF_LIA constraints to enforce valid scheduling rules, and check for satisfiability using QBF or DPLL-SAT.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA to represent the scheduling problem as a logic formula	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA solvers to reason about valid schedules.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following scheduling constraint using QF_UF and basic arithmetic constraints.	Use the following set of rules to derive the solution: (set-logic QF_UF) (declare-const X < 10) (assert X > 0) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA constraints to ensure fairness in resource allocation.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given a set of jobs with deadlines and resource requirements, determine the optimal assignment of jobs to machines without violating any deadlines or resource constraints.	Use QF_UF and QF_LIA rules to model this scheduling problem as an optimization problem that can be solved using SMT-LIB. Include assertions for machine availability and job deadlines.	"(declare-const a_to Bool)
(declare-const of_to Bool)
(declare-const or_to Bool)
(assert (= (+
  (ite a_to 1 0)
  (ite of_to 1 0)
  (ite or_to 1 0)
) 1))
(assert (<= (+
  (ite a_to 1 0)
) 1))
(assert (<= (+
  (ite of_to 1 0)
) 1))
(assert (<= (+
  (ite or_to 1 0)
) 1))
(check-sat)"
Scheduling Problem: Minimize Makespan	Given a set of tasks with start times and durations, find the order that minimizes the total makespan.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying an integer linear equation	(= (int x) ( (1 + 2)  = 3))	"(assert true)
(check-sat)"
scheduling_problem	derive_satisfiability_from_just_the_constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	(set-logic QF_UF)  define-variables   x: integer   y: boolean,   z: real  (assert (not (= x 0))) (assert (not (= y true))) (assert (= z 1.5))	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find the minimum number of machines required to schedule tasks with maximum utilization	This problem can be solved using First-Order Logic (FOL) constraints in SMT-LIB. The goal is to find the optimal scheduling configuration that maximizes machine utilization.	"(declare-const of Int)
(assert (and (<= 1 of) (<= of 3)))
(declare-const to Int)
(assert (and (<= 1 to) (<= to 3)))
(assert (distinct of to))
(check-sat)"
Scheduling Problem	{'type': 'Propositional Reasoning', 'reason': 'Using QF_UF with integer constraints and checking satisfiability'}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	Use QF_UF with set of variables and universal quantification to model a scheduling problem where tasks have start and end times.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Generate an exact solution for the following linear programming relaxation of the 5-hour delivery problem	Use QF_UF and QF_LIA constraints to model integer variables representing hours worked by drivers, and use assert statements to enforce non-negativity.	"(declare-const an Int)
(declare-const of Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct an of))
(check-sat)"
\(set-logic QF_UF \n\n(declare-const X true \n  \n  (assert Y = 1) \n  (assert Z < 5))\n	This is a valid SMT-LIB program that includes the necessary logic for model checking and satisfiability.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find optimal assignment of tasks to machines	Use QF_UF and QF_LIA solvers with simple constraints, e.g., (set-logic QF_UF)   (declare-const machine <1..4>   (declare-const task <1..5>))   (assert (>= 0 (size of task)))	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to prove that it is NP-complete.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA to enforce valid scheduling constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA to model the scheduling problem	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find the optimal assignment of tasks to machines	Use QF_UF and QF_LIA constraints to reason about machine resource allocation.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to enforce precedence constraints on tasks	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF to model the scheduling of tasks with deadlines and resource constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA constraints to model this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Determine if it is possible to assign all tasks to employees within a given time frame.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to model scheduling problems.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF with valid constraints to solve this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a scheduling constraint	Use QF_UF and QF_LIA constraints to model the problem	"(assert true)
(check-sat)"
Modeling scheduling conflicts in a production line	\n\n\n(\n  \n    \n    (\n      \n      \n      \n      \n      \n      \n      \n    ),\n\n  \n\n  (\n    \n    (\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    )\n\n  \n)	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Scheduling Problem	Using QF_UF and QF_LIA rules to reason about scheduling constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	This problem requires the use of QF_UF and QF_LIA rules to reason about scheduling constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Using QF_UF and set-logic to model scheduling problems with multiple tasks and resource constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	Use QF_UF rules to model the scheduling of tasks with dependencies.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following integer linear program: P = { x, y | x + y <= 5, x >= 0, y >= 0 }	Use QF_UF and QF_LIA constraints to ensure satisfiability, then check for valid solutions.	"(declare-const P Int)
(declare-const x Int)
(assert (and (<= 1 P) (<= P 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct P x))
(check-sat)"
Scheduling Problem: Given two tasks t1 and t2, assign task t1 to machine M1 and task t2 to machine M2 if both machines are not busy	Propositional Reasoner	"(declare-const M1_t1 Bool)
(declare-const M1_t2 Bool)
(declare-const M2_t1 Bool)
(declare-const M2_t2 Bool)
(declare-const if_t1 Bool)
(declare-const if_t2 Bool)
(assert (= (+
  (ite M1_t1 1 0)
  (ite M2_t1 1 0)
  (ite if_t1 1 0)
) 1))
(assert (= (+
  (ite M1_t2 1 0)
  (ite M2_t2 1 0)
  (ite if_t2 1 0)
) 1))
(assert (<= (+
  (ite M1_t1 1 0)
  (ite M1_t2 1 0)
) 1))
(assert (<= (+
  (ite M2_t1 1 0)
  (ite M2_t2 1 0)
) 1))
(assert (<= (+
  (ite if_t1 1 0)
  (ite if_t2 1 0)
) 1))
(check-sat)"
scheduling:make-schedule	show that it is impossible to schedule two tasks with different start times and one task can be delayed by any amount of time without violating the constraints.	"(declare-const X Int)
(assert (and (<= 1 X) (<= X 3)))
(declare-const Y Int)
(assert (and (<= 1 Y) (<= Y 3)))
(declare-const Z Int)
(assert (and (<= 1 Z) (<= Z 3)))
(assert (distinct X Y Z))
(check-sat)"
{'solver': 'smt2', 'input': '\\{(\\x0 \\y -5) + (\\z + 10) <= 15; \\x1 = (\\x3 + 2) * (\\x4 - 3); \\z = 12; \\v = true; \\w = false;\\n\\(\\x0 < 0 \\n\\n(\\y - 5) * (\\z + 10) <= 15 \\n\\n(\\x1 = (\\x3 + 2) * (\\x4 - 3))\\n\\n(check-sat)'}	{'solver': 'smt2', 'input': '\\{(\\x0 \\y -5) + (\\z + 10) <= 15; \\x1 = (\\x3 + 2) * (\\x4 - 3); \\z = 12; \\v = true; \\w = false;\\n\\(\\x0 < 0 \\n\\n(\\y - 5) * (\\z + 10) <= 15 \\n\\n(\\x1 = (\\x3 + 2) * (\\x4 - 3))\\n\\n(check-sat)'}	"(declare-const n Int)
(declare-const v Int)
(assert (and (<= 1 n) (<= n 10)))
(assert (and (<= 1 v) (<= v 10)))
(assert (distinct n v))
(check-sat)"
Satisfying the constraint that all tasks in a scheduling problem have at least one feasible solution	Use QF_UF and QF_LIA axioms to ensure feasibility, then use modus ponens and contradiction elimination to prove satisfiability.	"(declare-const a Int)
(declare-const at Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 at) (<= at 10)))
(assert (distinct a at))
(check-sat)"
Scheduling Problem: Find the optimal assignment of tasks to machines in a factory	Use QF_UF or QF_LIA constraints and simple integer or boolean constraints to model the problem.	"(declare-const a_to Bool)
(declare-const in_to Bool)
(declare-const of_to Bool)
(assert (= (+
  (ite a_to 1 0)
  (ite in_to 1 0)
  (ite of_to 1 0)
) 1))
(assert (<= (+
  (ite a_to 1 0)
) 1))
(assert (<= (+
  (ite in_to 1 0)
) 1))
(assert (<= (+
  (ite of_to 1 0)
) 1))
(check-sat)"
Satisfy the following system of linear equations with two variables x and y	Use the QF_UF rule to introduce new variables, then use QF_LIA to eliminate them, and finally assert the truth of the resulting equation.	"(declare-const of Int)
(declare-const x Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct of x))
(check-sat)"
Satisfy the constraints of a finite automaton	Use QF_UF and QF_LIA rules to express the constraints of the automaton	"(declare-const a Int)
(declare-const of Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct a of))
(check-sat)"
Satisfy the following linear equations using QF_UF and QF_LIA rules	Use simple integer constraints to represent the relationships between variables.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following constraint using QF_UF and QF_LIA	Use simple integer constraints and   newlines to separate logical statements	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Using QF_UF and QF_LIA rules to derive a valid scheduling plan from a set of constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Resource Allocation Problem	Use QF_UF to model the allocation of resources.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation: Assigning Resources to Tasks	{'variables': ['x', 'y'], 'constraints': ['(set-logic QF_UF)', '(declare-const x Integer)', '(declare-const y Boolean)', '(assert x >= 0)'], 'solver': 'SMT-LIB'}	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA axioms to model this problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Prove that there exists an integer x such that x = 1 and (x + 2) mod 3 = 0	Using the properties of modular arithmetic, we can show that this equation is true for all values of x.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Resource Allocation	Use QF_UF or QF_LIA with simple integer and boolean constraints to solve a resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to ensure valid integer solutions.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
{'name': 'Resource Allocation', 'description': 'A resource allocation problem in a cloud computing environment'}	Using QF_UF and set-logic, we can model this problem as follows:  set-logic QF_UF; assert (declare-const x:integer >= 0); assert (declare-const y:integer > 0); check-sat;	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation: Minimize Number of Server Assignments	(set-logic QF_UF) (declare-const x : integer) (assert (x > 0)) (check-sat)	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF to enforce unit-of-formula equality	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: 3 resources available, 4 requests to allocate	Use QF_UF and QF_LIA constraints to ensure integer solutions are found	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF logic to model this resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA solvers to find an optimal assignment of resources to tasks.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model a resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to define a set of constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	To allocate resources to tasks, we need to minimize waste and maximize efficiency.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use of QF_UF or QF_LIA constraints to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA formulas to model this resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
(set-logic QF_UF (declare-const x int : 1) (assert (equivalent? (add 2 x) (add 5 x)))	Using the properties of arithmetic operations and addition, we can deduce that if (add 2 x) = (add 5 x), then (add 3 x) must be true.	"(assert true)
(check-sat)"
Resource allocation problem	Satisfiability Reasoning and Computation System	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to processes	Using QF_UF and QF_LIA, derive that there exists a valid assignment of resources to each process such that the total resource usage is non-negative.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to ensure fairness in resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: 5 machines, 3 software licenses	Using QF_UF with constraints on machine availability and license usage.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA to model resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to reason about resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to processes	Use QF_UF and QF_LIA constraints to model resource allocation, considering bounds on resources and process demands.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Using QF_UF with set-logic and declare-const constraints to model the allocation of resources between two processes.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation	Using QF_UF with linear constraints to optimize resource usage.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Allocate resources to tasks with minimum latency	{'variables': [{'name': 'latency', 'type': 'int'}], 'assumptions': ['(set-logic QF_UF)', '(declare-const task1-latency 10)', '(declare-const task2-latency 5)'], 'conclusions': ['(assert (leq task1-latency task2-latency 5))']}	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA logical frameworks to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
{'name': 'Resource Allocation', 'description': 'A problem of resource allocation in a computer system', 'satisfiability': False}	{'rule1': '(set-logic QF_UF)', 'rule2': '(declare-const x integer)', 'rule3': '(declare-const y boolean)'}	"(declare-const A_of Bool)
(declare-const a_of Bool)
(declare-const in_of Bool)
(assert (= (+
  (ite A_of 1 0)
  (ite a_of 1 0)
  (ite in_of 1 0)
) 1))
(assert (<= (+
  (ite A_of 1 0)
) 1))
(assert (<= (+
  (ite a_of 1 0)
) 1))
(assert (<= (+
  (ite in_of 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Using QF_UF and set-logic to model resource allocation problem	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
(set-logic QF_UF (declare-const x y Z)	This is a valid program, and it will always find a solution.	"(declare-const Z Int)
(declare-const x Int)
(assert (and (<= 1 Z) (<= Z 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct Z x))
(check-sat)"
Resource allocation: Assigning resources to tasks	Use QF_UF and QF_LIA rules to reason about resource availability	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation	Use QF_UF or QF_LIA to specify the resource constraints and then assert them using set-logic.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to model resource allocation problems, ensuring that resources are allocated in an optimal manner.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF to find valid assignments that satisfy all constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Using QF_UF with set of variables and assertions to solve a resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
\(set-logic QF_UF\) \(declare-const x_0 bool\) \(assert (x_0 = true)\)	\(check-sat\)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to model resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA constraints to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA solvers to find an optimal assignment of resources.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA axioms to reason about resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA quantifiers to model the problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to tasks	Use QF_UF and QF_LIA rules to constrain resource allocation.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation: Minimize the number of machines used in the data center	Use QF_UF and QF_LIA to model this problem, and ensure that it includes  - (set-logic QF_UF) or QF_LIA. Use simple integer constraints for machine utilization.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation: Assigning resources to tasks	Using QF_UF and QF_LIA constraints to ensure fairness in resource allocation, while also ensuring that the system is satisfiable.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Prove that it is possible to allocate resources such that all devices are used and no device is idle	(set-logic QF_UF) # Define the universe of discourse as integers from 0 to N-1 (where N is the number of devices)  (set-logic QF_UF)(declare-const N: int)  (assert (>= N 2))  (check-sat)	"(declare-const is_to Bool)
(declare-const it_to Bool)
(declare-const no_to Bool)
(assert (= (+
  (ite is_to 1 0)
  (ite it_to 1 0)
  (ite no_to 1 0)
) 1))
(assert (<= (+
  (ite is_to 1 0)
) 1))
(assert (<= (+
  (ite it_to 1 0)
) 1))
(assert (<= (+
  (ite no_to 1 0)
) 1))
(check-sat)"
Resource Allocation: Assigning Resources to Jobs	Use QF_UF and QF_LIA constraints, and ensure that all constraints are linear and integer/boolean.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Integer Variables with Bounds	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to servers in a cloud-based data center	Use QF_UF and QF_LIA constraints to model the resource allocation decision.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and set-logic to model resource allocation with multiple constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA logic to reason about resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Using QF_UF and QF_LIA rules, derive a valid solution that maximizes resource utilization.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Minimize the number of printers used	Using QF_UF and QF_LIA constraints, prove that it is not possible to allocate enough printers to satisfy all user requests without exceeding the available capacity.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	To ensure efficient resource allocation, we use the QF_UF and QF_LIA rules.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA theory to reason about resource constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use the QF_UF and QF_LIA logics to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
{'smtplib': 'int(x) <= x + 1'}	Satisfiability with constraints (set-logic QF_UF; assert x > 0; check-sat)	"(assert true)
(check-sat)"
Resource allocation problem	This problem involves allocating resources to tasks with different priorities and constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	To allocate resources efficiently, we need to minimize waste and maximize utilization of available resources.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA to represent resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA rules to model resource allocation problems	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	{'type': 'model-checking', 'description': 'Verify that a resource allocation model satisfies QF_UF and QF_LIA constraints.'}	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use set-logic QF_UF and declare-const to specify resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA rules to formulate a valid resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA solvers, and assert that the program produces exactly one solution.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Maximize production of 5 units while minimizing waste	Using QF_LIA and set-logic QF_UF, the following constraints can be derived.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
{'input': '\\(set-logic QF_UF\\) \\n \\n (declare-const x Int\\n \\n assert (x = 0)\n \\n check-sat)'}	This SMT-LIB program checks if a number is zero	"(declare-const n Int)
(declare-const x Int)
(assert (and (<= 1 n) (<= n 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct n x))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA to model this problem and ensure validity.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: assigning 10 units of CPU to process 1 and 5 units to process 2	Use QF_UF and QF_LIA constraints to model the resource allocation problem. Ensure that the total number of units allocated is exactly 15.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation: 3 cars and 4 passengers	Use QF_UF and set-logic to ensure that each passenger has at least one seat	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation optimization	Use QF_UF and QF_LIA constraints to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation	Use QF_UF and assert/declare/check-sat to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	(set-logic QF_UF) (declare-const x (int)) (assert (not (= 2, 0))) (check-sat)	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA to specify the resource allocation model.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Ensure that the minimum number of units required to satisfy all resource constraints is met	Use QF_UF and QF_LIA to reason about the satisfiability of the program, and check for validity using SMT solver.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF with assert statements to model this problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA rules to ensure feasibility.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: 5 agents, each with capacity 2 and deadline 10	Use QF_UF and QF_LIA rules to prove existence of a solution that satisfies all constraints	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	 - {set-logic QF_UF         assert (2 > 0)}	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to solve this optimization problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA solvers with simple integer constraints to model this problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Ensure that the maximum number of employees is allocated to each department	Use QF_UF or QF_LIA quantifier, and simple integer constraints (e.g., <=) to represent the relationship between departments and employees.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A woman has two coins that total 30 cents. One coin is not a nickel, and one coin is not a quarter. What type of coin are they?	To solve this problem, we can use QF_UF (Universal First-Order Formula) to represent the given constraints. We need to find two integers x and y such that x + y = 30, x is not equal to 5 (nickel), and y is not equal to 10 (quarter).	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
A farmer has a rectangular field with integer coordinates in pixels, and she wants to know if it's possible to place a row of n x m flowers on this field such that no two flowers are adjacent.	This problem can be solved using QF_UF (Unfolding Formulas) or QF_LIA (Linear Arithmetic Inequality).	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
Solve for x: 2*x + 5 = 11	Use QF_LIA and set-logic to model this equation as an equality of integer constraints.	"(assert true)
(check-sat)"
A farmer has a field with 3 rows and 4 columns. Each cell can hold either an integer from 1 to 10, inclusive.	{   (set-logic QF_UF)   (declare-const row1 int   row2 int   row3 int),   (declare-const col1 int   col2 int   col3 int),   (assert (>= row1 1)            (<= row1 10))   (assert (>= row2 1)            (<= row2 10))   (assert (>= col1 1)            (<= col1 4))   (assert (>= col2 1)            (<= col2 3))   (assert (>= col3 1)            (<= col3 4))   (check-sat)}	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
3+2=5	Using QF_LIA, we can assert that the sum of two integers less than or equal to 10 is greater than 1 and less than or equal to 15.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Solve for x: 2*x + 5 = 11	Use QF_LIA with constraints: x >= 0, 2x <= 6	"(assert true)
(check-sat)"
(set-logic QF_UF (declare-const x 1) (assert (>= x 0)) (check-sat)	This is a simple satisfiability problem, where we need to find an assignment of values to the variable x such that all constraints are satisfied.	"(assert true)
(check-sat)"
Solve the following logic puzzle: A bat and a ball together cost $1.10. The bat costs $1.00 more than the ball. If you have 5 times as many bats as balls, how much will you pay?	Let B represent the number of balls and B+ represent the number of bats. From the first equation, we get: B + (B+1) = 10. This simplifies to 2B + 1 = 10, or B = 4.5. Since you can't pay for a fraction of a bat, this means that the only possible solution is to have 5 balls and 4 bats.	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
The Five Switches	Use QF_LIA and set-logic QF_UF to prove that there is exactly one way to program a computer to switch between five lights on, one at a time, while the lights are off.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that there exists an integer x such that x^2 + x - 5 = 0	Use QF_UF and set-logic to prove the existence of a solution, and use check-sat to find it.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The Five Houses	Using set-logic QF_UF and quantifiers, prove that there exists a house on each row such that at least one of its doors is open.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF and QF_LIA to prove that there exists a number between 1 and 3 that has exactly one switch on.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	(set-logic QF_UF) (declare-const x true) (declare-const y false) (declare-const z true)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Five Houses Problem	To solve this problem, we need to use the QF_UF and QF_LIA SMT-LIB rules.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A man, a plan, a canal, Panama!	(set-logic QF_UF   (declare-const X 0 5)   (declare-const Y 5 10))(assert (>= X 1) (<= Y 4))   (check-sat)	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Three Switches	Use QF_UF and assert statements to prove that there is a unique solution to this puzzle.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Five Houses Problem	To solve this puzzle, we need to find a valid assignment of integers from 1 to 5 to the five houses such that no two adjacent houses have more than one occupant.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF to represent three switches, and assert that they are either all on or none of them is on.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has 'a' apples and 'b' bananas in his orchard. The number of apples is greater than twice the number of bananas, and both fruits must be non-negative.	The constraints are: (set-logic QF_UF) (declare-const a int > 0) (declare-const b int > 0) (assert (a > 2 * b) (check-sat)	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
A farmer has three fields: A, B, and C. Field A can hold values 0 through 9. Field B can hold values -1 through 1. Field C can only hold the number 5.	The farmer needs to ensure that field C holds a value of either 0 or 4. If field A holds any other value, then field C must be 0. Otherwise, if field A is 5 or greater, then field B must be -1.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
(set-logic QF_UF   (declare-const x 9)   (declare-const y 10)   assert (>= x 0)   assert (<= y 100)   check-sat)	Satisfiability isomorphism using UFL constraints and linear integer programming.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Satisfy the following set of constraints on the variable x.	Use the quantifier 'for all' to generalize over all natural numbers n.	"(declare-const of Int)
(declare-const on Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 on) (<= on 10)))
(assert (distinct of on))
(check-sat)"
A farmer has 5 sheep and 3 goats. How many animals does she have?	(set-logic QF_UF  (declare-const A int  (A = 5)  (G int  (G = 3)))  (assert < A + G > 0))	"(assert true)
(check-sat)"
The Set of Twin Primes	- Prove that there do not exist two prime numbers p and q such that pq = 2.	"(assert true)
(check-sat)"
A 5-person committee needs to decide on a project leader.	Use QF_UF and assert constraints like (equal (= 1 2)) or (not (equal (= 3 4))).	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
Solve for x: 2x + 5 = 11	Use QF_UF and set-logic (maximize) to find an optimal solution.	"(assert true)
(check-sat)"
The Five Houses Problem	To solve this problem, we need to assign numbers to each of the five houses such that each house is assigned a number between 1 and 5 (inclusive), and no two adjacent houses have the same number.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use the rules provided by the problem to construct a valid solution.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Five Houses Puzzle	To solve this puzzle, we need to find a valid assignment of integers from 1 to 5 to the five houses such that each house is either occupied by an integer or not.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer wants to optimize his irrigation system to minimize water waste.	To solve this problem, we can use QF_UF and QF_LIA SMT-LIB rules to check if it's possible to irrigate all fields with the given amount of water.	"(declare-const A Int)
(declare-const to Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct A to))
(check-sat)"
Solve the following puzzle:  3 x + y = 6, 2x - y = 4.	(set-logic QF_UF) (declare-const x Int) (declare-const y Int) (assert (>= x 0) (assert (>= y 0)) (verify-sat)	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
A person is standing next to a box with an unknown weight. The box has a label that says 'Heavy' if its weight is greater than 10 kg and 'Light' otherwise. The person is holding the box, but they don't know which side it's on. What can be said about the box?	Using QF_UF, we can assert that the box is either Heavy or Light.	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
There are three switches: hot, cold and off.  You can turn on any two switches at once using one of the following operations:  1. Turn on switch A and then off switch B.  2. Turn on switch C and then off switch D.  3. Turn on switch B and then off switch D.  4. Turn on switch A and then turn on switch C.  5. Turn on switch C and then turn on switch D.	This is a classic puzzle that can be solved by applying the rules of logic, using simple Boolean constraints (AND/OR) to represent the conditions for each step.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A man, a plan, a canal, Panama!	(set-logic QF_UF   (declare-const X 0 5)   assert (<= X 0)   check-sat)	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Five Houses Puzzle	To solve this puzzle, we need to use QF_UF constraints to represent the relationships between the houses and their occupants.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF to create a function symbol and apply it to three variables in a predicate.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following statement	Use the QF_UF and QF_LIA rules to generate a model that satisfies this statement.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a linear equation with two variables	Use QF_UF to ensure equality and QF_LIA to allow variable combination.	"(assert true)
(check-sat)"
Find integers x such that x^2 + 1 = x+3	This equation can be solved using QF_UF with the following constraints: (set-logic QF_UF) and (declare-const x integer)	"(assert true)
(check-sat)"
Prove that there exists an integer x such that x^2 + 4x - 7 = 0 and x is even	To prove this, we can use the QF_UF rules to find a model for the equation x^2 + 4x - 7 = 0. We can then analyze the models to determine which ones satisfy the condition that x is even.	"(declare-const an Int)
(declare-const is Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct an is))
(check-sat)"
(set-logic QF_UF (declare-const x 1 x < 5) (declare-const y 2 y = x + 3) assert (>= y 4)	To prove that the assertion is true, we can use a model with x >= 0 and y > 0.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
(set-logic QF_UF) (declare-const x 1) (assert (not (= x 0))) (check-sat)	To prove that x is not equal to 0, we can use the property of equality that if a = b then a = b.	"(assert true)
(check-sat)"
(set-logic QF_UF  define-const X 0  assert (<= X 5)  check-sat	This puzzle requires the solver to find a value for X such that it is less than or equal to 5.	"(assert true)
(check-sat)"
A farmer has a field that is 100 meters long and 50 meters wide. The field must be fenced in by a fence that is at least 2 meters high on all sides.	The farmer can use the following constraints to solve this problem:  - (declare-const field-width 50 :integer) - (declare-const field-length 100 :integer) - (assert (>= (add (multiply field-width 2) (add field-length 2)) (add field-width 2)))	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The set-builder logic asserts that there exists an integer x such that x^2 + 4x - 3 = 0.	\n\nThe given equation can be solved using the quadratic formula: x = (-b  sqrt(b^2 - 4ac)) / 2a. In this case, a=1, b=4, and c=-3. \nThe solution to the equation is x = (-(4)  sqrt((4)^2 - 4*1*(-3))) / (2*1), which simplifies to x = (-4  sqrt(16 + 12)) / 2, or x = (-4  sqrt(28)) / 2. Since sqrt(28) is not a perfect square, there are two solutions: x = (-4 + sqrt(28)) / 2 and x = (-4 - sqrt(28)) / 2. \nThe set-builder logic asserts that exactly one of these two solutions exists.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The Five Houses Problem	Use set-logic QF_UF and declare variables for each house number.  (declare-const house1-number 1) (declare-const house2-number 2) (declare-const house3-number 3) (declare-const house4-number 4) (declare-const house5-number 5)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Find an infinite set {x: [0, 1]}.	This problem can be solved using QF_UF.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that there exists an integer x such that x^2 + 4 = 13	Use QF_UF and set-logic to derive the desired formula.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
(set-logic QF_UF  (declare-const x 1)  (declare-const y 2)	This problem is a simple example of using set-logic QF_UF to reason about the satisfiability of a given formula.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
A farmer wants to ensure that all cows are wearing collars of a certain color.	The farmer has ordered 100 cows, each with one collar. The collar can be either red or blue. Use QF_UF and QF_LIA constraints to prove that there is an assignment of colors to the collars such that all 100 cows are wearing their assigned colors.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Flipped Coins	Use QF_UF with a set of variables and constraints to prove that it's impossible to flip all coins such that one side always shows the opposite number.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Prove that there exists an integer x such that exactly three switches are open.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF to prove that exactly one of three boolean variables can be false at any given time.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Prove that it is impossible to assign colors to three switches such that each switch corresponds to one of three colors and the corresponding color switch is red.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
\(\{\n  x: \n    # Introduce a variable and constraint\n    assert(x > 0);\n  y: \n    # Introduce another variable and constraint\n    assert(y < x);\n  z: \n    # Use SMT-LIB to prove the variables are equal\n  (set-logic QF_UF \n    (declare-const x : int) \n    (declare-const y : int) \n    (declare-const z : bool))\n  \n  assert(z);\n  \n  (check-sat)	\(\{\n  # We use the fact that x > 0 and x + y = z to prove x == z\n  assert(x + y = z + x);\n  \n  # Since z is True, we can deduce x == z\n  assert(x == z);\n  \n  \n  # Use the assumption that x < 0 and x - y = z to prove x != z\n  assert(x > 0 && x - y = z);\n  \n  # Since z is False, we can deduce x != z\n  assert(x != z);\n  \n  \n  \n  (check-sat)	"(declare-const a Int)
(declare-const n Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 n) (<= n 10)))
(assert (distinct a n))
(check-sat)"
A prisoner needs to escape from a cell with multiple locks, each of which has two possible keys: the correct key or the wrong key. The guards enter a room and check one lock at a time in order.	To solve this problem using QF_UF, we need to model the guards' behavior as a set of rules that specify when they should consider each lock as the correct key. We can use (set-logic QF_UF) to define this logic, and then add rules for checking each lock's key.	"(declare-const A Int)
(assert (and (<= 1 A) (<= A 3)))
(declare-const a Int)
(assert (and (<= 1 a) (<= a 3)))
(declare-const and Int)
(assert (and (<= 1 and) (<= and 3)))
(assert (distinct A a and))
(check-sat)"
A woman has two coins that weigh differently. One coin weighs 1 kg and the other weighs 0.9 kg. How much does the lighter one weigh?	Use set-logic QF_UF and assert   (weigh < 1kg)  and (not (weigh = 0.9kg))	"(declare-const A Int)
(declare-const kg Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 kg) (<= kg 10)))
(assert (distinct A kg))
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 0 and x is not odd	To prove this statement, we can use the QF_UF rule to generate a set of solutions for the equation x^2 + 1 = 0. We then check if any of these solutions are integers that satisfy the condition x is not odd.	"(declare-const an Int)
(declare-const is Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct an is))
(check-sat)"
A farmer has two fields, A and B. Field A has 5 apples, and field B has 3 oranges. The farmer wants to know if there are any common fruits between the two fields.	The farmer can find the intersection of sets containing apples and oranges in both fields.	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
A bat and a ball together cost $1.10. The bat costs $1.00 more than the ball. If the ball costs x dollars, how much does the bat cost?	Let b = number of cents in the ball. Then the equation is (100 - b) + b = 110. Solve for b.	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
Satisfying the union of two sets with distinct elements	Use QF_UF and set-builder constraints to model the union of two sets A = {1, 2} and B = {3, 4}. The constraint (set-logic QF_UF) ensures that each element in both sets is present. The constraint (declare-const x : setof int) defines a set of integers containing all elements from both sets. Finally, the constraint (assert all of A | B) asserts that any element in either set is present.	"(assert true)
(check-sat)"
A farmer has two fields, A and B. Field A is 3 units long, while field B is only 2 units long. The farmer wants to know if there are enough spaces on both fields.	The problem can be solved using the QF_UF rule with a conjunction of constraints representing the length of each field and its relationship with the number of rows.	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Satisfying a set of rules on the number of apples	Use QF_UF to generate constraints for the number of apples in each basket and then solve using check-sat.	"(declare-const a Int)
(declare-const of Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct a of))
(check-sat)"
A farmer has two fields: Field A and Field B. If it rains, both fields receive water, but only if it's not too hot.	let (   0:     assert (>= 20 any x) => (x = 'hot')   1:     assert (= 100 any y) => (y = 80)   2:     let (       z: set of string       f0: {x | x = 'hot', x < 20}       f1: {x | x = 'hot', x >= 20, x <= 30}       f2: {x | x = 'hot', x > 30})     assert (in z f0)     & (not in f1 f0)    & (in f2 f1)	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A farmer wants to irrigate all but two rows of his garden, and then water one row. What are the possible values for k?	To find the exact number of rows that will be irrigated, we need to use the set-logic QF_UF and check-sat constraints.	"(declare-const A Int)
(declare-const k Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 k) (<= k 10)))
(assert (distinct A k))
(check-sat)"
"{   'problem': ""Solve the following puzzle: There are three switches, but they are not labelled. Each switch corresponds to one of three light bulbs in a room. Each bulb is either on or off. You can turn the switches on and off as many times as you want, but you can only enter the room one time to observe the bulbs. How can you figure out which switch corresponds to which light bulb?"""	{   (set-logic QF_UF)   (declare-const bulb1 bool   bulb2 bool   bulb3 bool)   (declare-const switches [ bulb1 true    bulb2 false    bulb3 true ]   (assert not (switches[0]            or switches[1]            or switches[2]))   (check-sat)	"(declare-const a Int)
(assert (and (<= 1 a) (<= a 3)))
(declare-const as Int)
(assert (and (<= 1 as) (<= as 3)))
(declare-const in Int)
(assert (and (<= 1 in) (<= in 3)))
(assert (distinct a as in))
(check-sat)"
(set-logic QF_UF (declare-const x int) (declare-const y bool) (assert (>= x 0) (check-sat)	This is a simple problem that can be solved using basic arithmetic and logical constraints. The goal is to determine if the value of x is greater than or equal to 0, given that it is an integer.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
(set-logic QF_UF   (declare-const x y int)   (assert x > 0))	This is a simple logic puzzle where we are asked to prove that if x is greater than 0, then x is positive.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
A farmer has a field that can hold up to 1000 square meters of land. The field is currently empty, and it needs to be fenced in.	The farmer needs to fence in at least 800 square meters of land for this task.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Three Switches	Use set-logic QF_UF and assert/declare/declare-const to model a problem where a person has three switches, labelled A, B and C, and each switch corresponds to one of three light bulbs in a room. The lights are initially off, and we can turn the lights on or off at most once per switch. We want to determine if it is possible to turn all the lights on with just two switch flips.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
(set-logic QF_UF (declare-const x y 1))	(assert y = 1) && (check-sat)	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
The Three Switches	{'type': 'deductive', 'constraints': ['\n  assert (x = 0)\n', '\n  assert (y = 1)\n', '\n  assert (z = 2)\n']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use set-logic QF_UF and assert/unify to prove that there is no valid assignment of colors to switches such that each switch corresponds to either red or green.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the following system of linear equations with integer coefficients and constraints	Use QF_LIA or QF_UF to generate the model, then solve it using a solver like DPLL or CDT.	"(assert true)
(check-sat)"
(set-logic QF_UF (declare-const x 1 #t) (declare-const y 2 #f) (assert (x = true) (y = false)))	to prove that x and not y are both true or both false using only basic arithmetic operations and equality checks	"(declare-const f Int)
(declare-const t Int)
(assert (and (<= 1 f) (<= f 10)))
(assert (and (<= 1 t) (<= t 10)))
(assert (distinct f t))
(check-sat)"
The set of all perfect numbers	This is a classic problem in number theory, and it can be solved using QF_UF with constraints such as (forall x (<= 1000) (odd? x))	"(assert true)
(check-sat)"
Solve the puzzle: 5 cars are parked on the street, and each car has a different color. If we add 2 more cars with the same color, can you find the color of all 7 cars?	Use mod 3 to solve this problem by assuming that the total number of cars is divisible by 3.	"(declare-const If Int)
(declare-const a Int)
(assert (and (<= 1 If) (<= If 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct If a))
(check-sat)"
A farmer has a field with two rows and two columns. Each cell in the field can be either red or green. The farmer wants to know if it is possible to reach every cell from one corner to the other using only right and up moves.	This problem is a classic example of a constraint satisfaction problem (CSP) that can be solved using QF_UF and QF_LIA solvers in SMT-LIB. We need to find all possible valid paths from the top-left corner to the bottom-right corner while respecting the constraints.	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
Satisfy the following proposition: 2 + 2 = true.	This can be proved using the QF_UF rule and simple arithmetic constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use a model with three variables and two constraints to solve this puzzle.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given integers a and b, find all pairs of distinct positive integers c and d such that a + b = c + d	Prove the validity of the following system using QF_UF or QF_LIA with integer constraints: (set-logic QF_UF)   (declare-const a Int)   (declare-const b Int)   (declare-const c Int)   (declare-const d Int)   (assert (a + b = c + d))   (check-sat)	"(declare-const a Int)
(declare-const b Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 b) (<= b 10)))
(assert (distinct a b))
(check-sat)"
Prove that the following statement is true: x = 5 and y != 3	Use the QF_UF rule to combine the assertions of x = 5 and y != 3, then use the QF_LIA rule to prove the conjunction of these two statements. Finally, add a check-sat clause to verify that the system is satisfiable.	"(declare-const is Int)
(declare-const x Int)
(assert (and (<= 1 is) (<= is 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct is x))
(check-sat)"
Solve the following puzzle: A bat and a ball together cost $1.10. The bat costs $1.00 more than the ball. If the ball costs x dollars, how much does the bat cost? y.	$y-x=0.10\quad$y>x$	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
A 5-person committee must be formed from a group of 8 people, and each person can only speak on one topic.	Use set-logic QF_UF to ensure that each member speaks only once and use   for newlines inside the SMT string.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Five Houses Puzzle	Use QF_UF to express that each house is occupied by either a person or an animal.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has N cows to milk. The first cow can be milked at most once per day, and each cow takes at least one hour to milk. If the farmer starts with an empty fridge, how many days will they need to milk all their cows?	To solve this problem, we can use the QF_UF logic, which allows us to represent the constraints as a set of clauses with atomic propositions representing the number of cows and hours spent milking. We can then use the 'check-sat' solver to find an optimal solution.	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
The Three Switches	(set-logic QF_UF) (declare-const x 1) (assert (x = 0)) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has two fields, A and B. Field A contains all the apples from both fields combined. If field C contains only apples that are red, then field D must contain at least half of field A's apple count.	Use QF_UF and QF_LIA to solve this problem. Consider the constraints (set-logic QF_UF) and (declare-const ...). Use assert statements to define field A and field B. Assume all apples are either red or not red for field C, then use modularity on field D.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A farmer has 5 sheep and wants to build a fence around them. The fence must be at least 3 meters long and can have a maximum of 10 meters in the middle.	Use QF_UF constraints to ensure that the fence can accommodate all the sheep while leaving some buffer space on each side.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
A farmer has 'm' chickens and wants to know if they are all happy.	The answer is yes if and only if m = 5 or m = 6	"(declare-const A_friend_if Bool)
(declare-const if_friend_A Bool)
(assert (= A_friend_if if_friend_A))
(assert (= true A_friend_if))
(check-sat)"
The Life of Pi	Use QF_UF and assert constraints on pi, x, and y.	"(declare-const Pi Int)
(declare-const of Int)
(assert (and (<= 1 Pi) (<= Pi 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct Pi of))
(check-sat)"
A farmer has three fields: A, B and C. Field A has 4 rows and 5 columns, field B has 3 rows and 6 columns and field C has 2 rows and 8 columns. The farmer wants to know how many hot peppers are in each field.	The total number of hot peppers in all fields is equal to the sum of the products of the number of rows and columns in each field, multiplied by a constant (1).	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
\(\(\{1:2, 3:4} \) -> (false))	(set-logic QF_UF) (declare-const X int) (assert (X = 1) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
(set-logic QF_UF) (declare-const x 1  # t) (assert (<= 0 (and x 2) (add 3 x))) (check-sat)	"Using the <a href=""https://www.sat.inf.u-bremen.de/"">SAT solver</a> to verify the satisfiability of the given formula. We found that it is unsatisfiable for all values of x."	"(declare-const t Int)
(declare-const x Int)
(assert (and (<= 1 t) (<= t 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct t x))
(check-sat)"
The Three Switches	"(set-logic QF_UF 	(declare-const x 1) 	(declare-const y 2) 	(assert (not (= x 0))) 	(check-sat)"	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	QF_UF and set-logic QF_LIA	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has 5 rows of flowers in her garden, and each row can have at most 3 flowers. The number of flowers in each row must be an integer between 0 and 4 (inclusive).	The number of flowers is a valid integer.	"(declare-const A Int)
(declare-const an Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 an) (<= an 10)))
(assert (distinct A an))
(check-sat)"
Satisfying a simple equation	Use <~{ to enforce an inequality, and <~~ to enforce equality.	"(assert true)
(check-sat)"
Satisfying the Chicken McNugget Theorem	The Chicken McNugget Theorem states that the sum of two relatively prime numbers has a unique representation as a linear combination of those two numbers. Prove this theorem using QF_UF and SMT-LIB.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use a switch statement to determine which color shirt to wear based on the day of the week.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has three fields of wheat: Field A, Field B, and Field C. Each field can hold either 0 or 1 units of wheat. The farmer needs to determine which field holds how many units of wheat based on the following clues.	Use QF_UF (Universal Forcing) and assert constraints for each field to deduce its contents.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A farmer has two fields, A and B. Field A can hold at most 1000 units of soil, and field B can hold at most 2000 units of soil. The farmer wants to know if it is possible to allocate the soil between the two fields such that field A does not exceed its capacity and field B does not exceed its capacity.	use QF_UF to add constraints on the number of units in each field, check-sat to verify the validity of the constraints	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Solve the following logic puzzle: There are three switches, but they are not labelled. Each switch corresponds to one of three light bulbs in a room. Each bulb is either on or off. You can turn the lights on and off as many times as you want, but you can only enter the room one time to observe the bulbs.	Use QF_UF to model the switches and their corresponding light bulbs. The only constraints should be integer variables for the number of times each switch has been turned on or off.	"(declare-const a Int)
(assert (and (<= 1 a) (<= a 3)))
(declare-const as Int)
(assert (and (<= 1 as) (<= as 3)))
(declare-const in Int)
(assert (and (<= 1 in) (<= in 3)))
(assert (distinct a as in))
(check-sat)"
The set of all perfect squares between 0 and 100	Use QF_UF to express that a number is either even or odd, then use the property (forall x (x = 0) -> (not (x^2))) to assert that there are no perfect squares less than 100.	"(assert true)
(check-sat)"
The Five Houses Problem	Use QF_UF and QF_LIA solvers to prove the following statement: There exists an integer x such that x^2 + x + 1 = 5x + 4 or (x == 0 and y == 2) or (x == 3 and y == 1)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
\u03c0\u202f\u2228\u221a\u203b\u2153\u2192\u2115\u20d1\u2164\u217e\u22cc\u2202\u2189\u2164\u223b\u2193\u214f\u2187\u212a\u215c\u2236\u219d\u2210\u2135\u2188\u217c\u2221\u218a\u216f\u220e\u2192\u211c\u2153	\u03b7\u2129\u20ac\u201d\u2060\u2035\u2130\u2211\u2148\u218a\u2164\u217e\u22cc\u2202\u218f\u2153\u219b\u222c\u2207\u2189\u207d\u2066\u2120\u20ac\u201d\u2035\u2130	"(declare-const u2115 Int)
(declare-const u2135 Int)
(assert (and (<= 1 u2115) (<= u2115 10)))
(assert (and (<= 1 u2135) (<= u2135 10)))
(assert (distinct u2115 u2135))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that two people are friends if and only if they have a mutual friend	Use QF_UF to prove the biconditional, and use set-logic to add the necessary constraints	"(declare-const a_friend_if Bool)
(declare-const if_friend_a Bool)
(assert (= a_friend_if if_friend_a))
(assert (= true a_friend_if))
(check-sat)"
(set-logic QF_UF   (declare-const x int)   (assert (not (= x 0)))   (check-sat)	The assertion will only be true if x is not equal to 0.	"(assert true)
(check-sat)"
Social inequality	Use QF_UF to model the relationship between income and education level, where higher income leads to higher education level.  (declare-const X (integer : LessThan 5))  (declare-const Y (integer : GreaterThan 0))  (assert (QF_UF (     X Y              <= 4 ? true : false) )	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given a social network with people of different ages, find all pairs of individuals who are friends.	To solve this problem, we can use QF_UF and check-sat constraints to derive the friendships between people. We can first list all possible pairs of individuals, then constrain each pair using simple integer or boolean constraints (e.g., `age(a, b) <= 18 && age(b, a)`), and finally check for satisfiability.	"(declare-const a_friend_of Bool)
(declare-const of_friend_a Bool)
(assert (= a_friend_of of_friend_a))
(assert (= true a_friend_of))
(check-sat)"
Prove that there exists an integer x such that x + 1 = 3 and x - 2 > 0	Use the QF_UF rule to combine x + 1 = 3 with x - 2 > 0 to get (x+1) - (x-2) = 5 > 0	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The given social constraint is inconsistent and cannot be satisfied by any assignment of integers or booleans.	A valid solution would require the existence of a finite set of integer values that can satisfy all constraints simultaneously.	"(declare-const be_of Bool)
(declare-const be_or Bool)
(declare-const by_of Bool)
(declare-const by_or Bool)
(declare-const is_of Bool)
(declare-const is_or Bool)
(assert (= (+
  (ite be_of 1 0)
  (ite by_of 1 0)
  (ite is_of 1 0)
) 1))
(assert (= (+
  (ite be_or 1 0)
  (ite by_or 1 0)
  (ite is_or 1 0)
) 1))
(assert (<= (+
  (ite be_of 1 0)
  (ite be_or 1 0)
) 1))
(assert (<= (+
  (ite by_of 1 0)
  (ite by_or 1 0)
) 1))
(assert (<= (+
  (ite is_of 1 0)
  (ite is_or 1 0)
) 1))
(check-sat)"
Prove that John and Mary are married	Use QF_LIA and assert the following equations to prove this statement, then check-sat.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Ensure that no two people in a friendship network have more than one connection to each other	"model  	 globeforall x y z:  		headgedd (x, y)  		and  		( x  eq z |  			not ( 			y, z)  	))"	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (= a_friend_in in_friend_a))
(assert (= true a_friend_in))
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 2x and x is less than or equal to 10	{'method': 'modelChecking'}	"(declare-const an Int)
(declare-const is Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct an is))
(check-sat)"
Prove that there exist two distinct integers x and y such that x + y = 5	Using QF_UF with constraints x >= 0, y <= 5, and x + y = 5, derive the existence of a solution.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that it is not possible to construct a directed acyclic graph (DAG) with more than 5 nodes and 10 edges.	This can be proven using the properties of finite state machines, specifically the pumping lemma for regular languages. The pumping lemma states that there exists a positive integer k such that any string s in the language must contain at least one character that appears at least k times in blocks of length at most 2k.	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Prove that there exists an integer x such that x^2 + 4 = 8 and x^2 - 3 < 0.	This problem can be solved using the QF_UF rule, which states that for any formula f(X) of type 'quantifier-free' with one free variable X, we have either f(X) or f(X). We will use this rule to derive a contradiction. First, we show that 3^2 - 4 = 5 and 3^2 + 4 > 8. Then, we can conclude that there exists an integer x such that x^2 < 0.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that 'John' is not equal to 'Alice'	Use QF_UF with set-logic and assert constraints.	"(declare-const is Int)
(declare-const to Int)
(assert (and (<= 1 is) (<= is 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct is to))
(check-sat)"
Prove that there exists an integer $x$ such that x^2 + 3x - 4 = 0	The quadratic equation has at least one real root according to the Fundamental Theorem of Algebra, and we can show this by attempting to solve it manually.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that there exists an integer x such that x > 0 and (x + 1) mod 3 = 2	Using the properties of modular arithmetic, we can derive that if x is positive, then (x + 1) mod 3 must be equal to 2. This implies that there exists a unique integer solution for x.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that John and Mary are married.	(set-logic QF_UF) (declare-const John mary : pair (string , string)) (assert (John mary) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that a person is not married to themselves.	(not (set-of-facts (set-of-constants 'x) (set-of-constants 'y)))	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Prove that for all integers n >= 2, (1 + n) mod 3 = 0.	This statement can be proven using the properties of modular arithmetic and the fact that 1 + n is always even when n is odd or a multiple of 4.	"(assert true)
(check-sat)"
Prove that there are at least two distinct social connections between individuals in a small community.	Use QF_UF and QF_LIA rules to derive the existence of at least two distinct social connections, given the following assumptions: people have no social connections with themselves, people can be connected by exactly one other person, people cannot be connected by multiple people.	"(declare-const a Int)
(declare-const at Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 at) (<= at 10)))
(assert (distinct a at))
(check-sat)"
Verify that the following relation holds: (x, y) <- (x, z) && (y, z)	Use QF_UF and QF_LIA rules to derive the implication.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that it is impossible to have two people who are friends with each other	{'description': 'Use QF_UF and set-logic to model this relationship.', 'smtlib': 'set-logic QF_UF\ndeclare-const Alice:Int\ndeclare-const Bob:Int'}	"(declare-const is_friend_it Bool)
(declare-const it_friend_is Bool)
(assert (= is_friend_it it_friend_is))
(assert (= true is_friend_it))
(check-sat)"
Given the following social network structure: [1, 2; 2, 3; 3, 4], define the minimum number of friendships required to satisfy all constraints.	To solve this problem, we can use QF_LIA with a set of constraints that enforce the presence of at least one friendship between each pair of nodes in the network. We can then check if the resulting model is satisfiable using check-sat.	"(declare-const of_friend_to Bool)
(declare-const to_friend_of Bool)
(assert (= of_friend_to to_friend_of))
(assert (= true of_friend_to))
(check-sat)"
Prove that any two people are connected in a social network	Use QF_UF and QF_LIA rules to reason about graph connectivity	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Verify that a social relationship graph is consistent.	{   (set-logic QF_UF)   (declare-const person1 person2 : FRIENDS)   (assert (forall (x person)         (           (person1 x)                        (person2 x))         (not (eq x x)))   )	"(declare-const a_friend_is Bool)
(declare-const is_friend_a Bool)
(assert (= a_friend_is is_friend_a))
(assert (= true a_friend_is))
(check-sat)"
Prove that two people are friends if and only if they share a common interest.	Use QF_UF to combine two literals representing friendship and two literals representing shared interests, then use assert to prove that the first literal is true if and only if the second literal is true. Finally, check-sat to verify that the system satisfiable.	"(declare-const a_friend_if Bool)
(declare-const if_friend_a Bool)
(assert (= a_friend_if if_friend_a))
(assert (= true a_friend_if))
(check-sat)"
Determine whether a person is married to their spouse	Use QF_LIA and (set-logic QF_UF) with valid constraints to prove that a person is not married to their spouse.	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Prove that there does not exist an integer x such that x^2 + 1 = 0	This statement can be proven using the QF_LIA theory, specifically by assuming x is an integer and then deriving a contradiction.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that if person A is friends with person B and person C, then person A and person C are connected by a friendship chain	Use QF_UF to represent friendships between people and QF_LIA to ensure the structure of the friendship graph is consistent.	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Determine if all people in a social network have at least one friend.	Use QF_UF and assert statements to model relationships between individuals, then use the check-sat solver to verify validity.	"(declare-const a_friend_at Bool)
(declare-const at_friend_a Bool)
(assert (= a_friend_at at_friend_a))
(assert (= true a_friend_at))
(check-sat)"
Prove that there exist two people in a social network such that they are friends and not spouses.	Use QF_UF with constraints on friendships and non-spousality, then add an assumption about the existence of at least one pair of people who could be friends but not spouses.	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (not a_friend_in))
(assert (not in_friend_a))
(check-sat)"
Prove that there does not exist an integer k such that k^2 + 5k - 6 = 0	(assert (integer s) (> 0 ? 1 : 2)) (assert (syms x k real) > 0) (assert (satisfies (e (univariate x) (- 6 x 6 k^2 + 5 k))) > 0) ((set-logic QF_UF) (declare-const s real)) ((check-sat))	"(declare-const an Int)
(declare-const k Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 k) (<= k 10)))
(assert (distinct an k))
(check-sat)"
Determine whether it is possible to construct a social network where all individuals are connected and no two individuals are friends	The graph of friendships can be represented as an undirected graph with weighted edges, where each edge has a weight representing the strength of the friendship. A valid solution would require that there is at least one strongly connected component in the graph.	"(declare-const a_friend_is Bool)
(declare-const is_friend_a Bool)
(assert (= a_friend_is is_friend_a))
(assert (= true a_friend_is))
(check-sat)"
Prove that if Alice is friends with Bob and Bob is friends with Charlie, then Alice is friends with Charlie	Use QF_UF with constraints that express the friendship relationships as valid integer solutions. Ensure the model is satisfiable by checking for consistency.	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (= if_friend_is is_friend_if))
(assert (= true if_friend_is))
(check-sat)"
Prove the following sentence is valid in QF_UF	Use the set-logic QF_UF and assert statements to derive the sentence.	"(declare-const in Int)
(declare-const is Int)
(assert (and (<= 1 in) (<= in 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct in is))
(check-sat)"
Given a person A with age 25 and friend B, prove that if A's friends are all friends of C then A is friends of B.	(declare-const A Person (0: 1) (declare-const B Person (0: 1) (declare-const C Person (0: 1))  (   (            (forall x (Person (x)) (         (set-of y (Set-of-z) z)))        ) )  (   (assert (or (A= B) (All-of-A-Friend-Of-B-C A C))))	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Prove that if person1 is friends with person2 and person3, then person4 is not friends with person5.	{'method': 'existential', 'variables': ['person1', 'person2', 'person3', 'person4', 'person5'], 'constraints': ['(set-logic QF_UF)\n\n', '(declare-const person1 person1)\n', '(declare-const person2 person2)\n', '(declare-const person3 person3)\n', '(assert (person1 <> person2))\n', '(assert (person1 <> person3))\n', '(assert (not (person4 <>) (person5 <)))']}	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (not if_friend_is))
(assert (not is_friend_if))
(check-sat)"
The relationship 'John Doe' and 'Jane Smith' are friends.	To verify this statement, we can use the QF_UF (Universal Forcing) logic with a set of constraints involving relationships between individuals. We will also utilize the assert clause to enforce the validity of the given statements.	"(declare-const X_friend_Y Bool)
(declare-const Y_friend_X Bool)
(assert (= X_friend_Y Y_friend_X))
(assert (= true X_friend_Y))
(check-sat)"
The given social network of friends has exactly 5 people.	A person can only be friends with themselves, and no one is friends with each other if their number of friends is odd. This means that the total number of pairs of friends should equal half of 15 (the total number of people).	
Prove that there exists an integer x such that x + 1 = 2x	Use the QF_UF and QF_LIA rules to derive the desired consequence.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that there are no cycles in the graph G = ({a, b, c}, R), where R is an undirected relation and 'a' and 'b' are related to each other, but not both.	Use QF_UF and set-logic to reason about the satisfiability of this graph. Assume X = {a, b} such that X  G. Prove by contradiction that there exists a path from a to c in G if and only if for all y  X, (y, x)  R.	"(declare-const G Int)
(declare-const R Int)
(assert (and (<= 1 G) (<= G 10)))
(assert (and (<= 1 R) (<= R 10)))
(assert (distinct G R))
(check-sat)"
Pigeonhole Principle	Given n pigeons and m pigeonholes, show that at least one pigeonhole must contain more than one pigeon.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The following social relationship constraint is valid: P(x, y) |= Q(x, z), where P, Q are predicates and x, y, z are atoms.	To prove the validity of this constraint, we need to show that it is satisfiable using a finite model.	"(declare-const P_friend_Q Bool)
(declare-const Q_friend_P Bool)
(assert (= P_friend_Q Q_friend_P))
(assert (= true P_friend_Q))
(check-sat)"
Verify that a social constraint involving two individuals and their relationships holds true	{'method': 'existential quantification'}	
Prove that all employees in the company are working	Using set-logic QF_UF and QF_LIA, derive the following implications: (set-of-people employee1 ... employee5) => (work(employee1, employee2), work(employee3, employee4), work(employee5, employee6))	"(assert true)
(check-sat)"
Prove that John and Mary are married	(set-logic QF_UF) (declare-const John mary : bool) (assert (== John mary)) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that if person1 is friends with person2, and person2 is friends with person3, then person1 is friends with person3.	Use the transitive property of friendship to prove this implication.	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (= if_friend_is is_friend_if))
(assert (= true if_friend_is))
(check-sat)"
Prove that a person is either in their hometown or not.	This can be represented as a disjunction of two constraints: (set-of-variables-person home-town) and (not-set-of-variables-person elsewhere).	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Find all pairs of people in a social network where one person is friends with another.	Use QF_UF to model friendship relationships and check-sat to solve the problem	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (not a_friend_in))
(assert (not in_friend_a))
(check-sat)"
Prove that any person is either a student or an employee of the same company.	{   (set-logic QF_UF)   (declare-const C (Symbol('Company'))   (declare-const S (Symbol('Student'))   (declare-const E (Symbol('Employee'))   (assert (not (or (= C S) (= C E))))   (assert (not (and (= S C) (= E C)))   (assert (not (or (= S E) (= C E)))))   (check-sat) }	"(declare-const a Int)
(declare-const an Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 an) (<= an 10)))
(assert (distinct a an))
(check-sat)"
Prove that a person is either married to their spouse or not married at all	Use QF_UF and assert variables for marriage status, then check-sat	"(declare-const a Int)
(declare-const at Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 at) (<= at 10)))
(assert (distinct a at))
(check-sat)"
Prove that John and Mary have different favorite sports.	Use QF_UF with (set-logic QF_UF) to express the relationship between two individuals. Then, use (assert ...) to assert a specific property about their preferences. Finally, check-sat to prove this property holds true.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that John and Alice are friends.	(john = alice) -> (friend john alicia)	"(declare-const X_friend_Y Bool)
(declare-const Y_friend_X Bool)
(assert (= X_friend_Y Y_friend_X))
(assert (= true X_friend_Y))
(check-sat)"
A university has two social constraints regarding friendships between students.	These constraints can be represented using QF_UF and QF_LIA axioms.	
Prove that a person is either in the US or has a valid US driver's license.	Use QF_LIA and assert that the person is in the US or their driver's license is valid.	"(declare-const US Int)
(declare-const a Int)
(assert (and (<= 1 US) (<= US 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct US a))
(check-sat)"
Prove that every person has at least one friend	Use QF_LIA and QF_UF to model the friendship relationship between people	"(declare-const at_friend_has Bool)
(declare-const has_friend_at Bool)
(assert (= at_friend_has has_friend_at))
(assert (= true at_friend_has))
(check-sat)"
Satisfies QF_UF rule with a valid JSON payload	"{'solver': 'CPVEX', 'input': '{""solution"": ""1"", ""constraints"": [""x + y = 2""]}', 'expected_solution': '[0, 3]'}"	"(assert true)
(check-sat)"
The social network has a relationship between John and Alice, but they are not friends.	{'constraints': ['(set-logic QF_UF)\n', '(declare-const person1 person2)\n', '(assert (not (person1 = person2)))\n', '(check-sat)']}	
\(set-logic QF_UF\) \(declare-const x = 5\) \(assert \((\u'== 4\)\))	This proof uses QF_UF to prove a simple equality and QF_LIA to derive the truth of the assertion.	"(declare-const u Int)
(declare-const x Int)
(assert (and (<= 1 u) (<= u 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct u x))
(check-sat)"
The relationship between person A and person B is that they are friends.	This can be expressed as (set-logic QF_UF)      (declare-const personA personA   declare-const personB personB   assert (personA == personB))   (assert (not (personA != personB)))	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
\(set-of\(\{x| x #= 1\} \) && \(set-of\(\{y| y #!= 2 && !x || y #<= 3\} \))\)	\(declare-const x 1; \(declare-const y 2; \(assert (xor (and (not (eq x 1) (neq x 2)) (not (eq x 1) (lt x 3))) (and (neq x 1) (gt x 3)));\)	"(declare-const of Int)
(declare-const x Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct of x))
(check-sat)"
Prove that there exists an integer x such that 2*x + 3 >= 5 and x^2 <= 4	Use QF_UF to model the system of linear inequalities: 2x + 3 >= 5 --> 2x >= 2 --> x >= 1; x^2 <= 4 --> x <= -2	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that for all integers x and y, if x > y then x + y = 2y	Using QF_UF with the set of integers and the implication rule, derive the following:   (declare-const x Int) (declare-const y Int) (assert (x > y)) (check-sat)	"(declare-const if Int)
(declare-const x Int)
(assert (and (<= 1 if) (<= if 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct if x))
(check-sat)"
{'solver': 'QF_UB', 'reasoning': '(set-logic QF_LIA (declare-const x 0: INTEGER) (assert (>= x 1)) (check-sat))'}	(assert (>= 2 3)) (check-sat)	"(assert true)
(check-sat)"
Prove that if Alice and Bob are friends, then Carol is also friends with both of them.	(set-logic QF_UF)                (declare-const alice friend bob)     (assert (not (friend bob alice)))     (declare-const carol friend alicebob)     (assert (and (friend alicebob carol) (friend alice carol)))	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (= if_friend_is is_friend_if))
(assert (= true if_friend_is))
(check-sat)"
Prove that there are no friends among five people.	To prove this, we can use QF_LIA and assert that each person is either friend with themselves or not.	
A person is either married to their spouse or in a consensual relationship with someone else.	This property can be expressed using QF_UF (Unions of First-Order) and constraints such as <person> marry <other_person>	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
Verify that there are no social connections between all individuals in a network of 10 people with no mutual friends	Use QF_UF to model the relationship as a graph, and then use QF_LIA to check if the graph is acyclic. If it is not, then there must be some cycle of edges, meaning that someone is connected to everyone else, which means they have mutual friends.	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (= a_friend_in in_friend_a))
(assert (= true a_friend_in))
(check-sat)"
(set-logic QF_UF (declare-const x y z (integer :pred <)) (assert (not (= x 5))) (check-sat)	(check-sat)	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that there exist distinct integers x, y such that x + y = 3 and x  y	Using QF_UF and the constraints x + y = 3 and x  y, derive a contradiction if neither x nor y is equal to zero.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that a person who has friends with people they know personally and strangers, but does not have acquaintances outside of their social circle, cannot be a friend to any one specific stranger.	Use QF_UF or QF_LIA with the following constraints: (set-logic QF_UF) (declare-const person1 <person1> (friend-of-person1 person2 (friend-of-person1 person3) ... (not acquaintances person4 person5))) (assert (for-all x (forall y (not friend-of-person1 y x))) (not (in-a-social-circle x)))	"(declare-const a_friend_be Bool)
(declare-const be_friend_a Bool)
(assert (not a_friend_be))
(assert (not be_friend_a))
(check-sat)"
Prove that there exist non-empty sets A and B of people such that A  B = 	"The following set constraints ensure the existence of such sets:  - A (A  X)   	B (B  A);"	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
Social Network Problem	The following friendship relationships hold: (Alice, Bob), (Bob, Charlie), (Charlie, Alice). Find the maximum number of friends each person can have.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given two people A and B, where person A is related to person B by marriage if A's age is greater than B's age.	Use QF_UF or QF_LIA with set-logic to express the relationship between ages of individuals for any positive integers n and m (where n <= m).	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
Prove that if person A has degree 3 and person B has degree 4, then person A's age is greater than or equal to person B's age	This implication can be proved using QF_UF or QF_LIA.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
Prove that there exists an integer x such that x^2 = 5 and x^4 + 2x^2 - 1	Use QF_UF to reason about the existence of a solution and then use QLIA to solve for x.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that two people are acquaintances if they have met at least once	(set-logic QF_UF) (declare-const person1 :: int) (declare-const person2 :: int) (assert (person1 = person2)) (check-sat)	"(declare-const at Int)
(declare-const if Int)
(assert (and (<= 1 at) (<= at 10)))
(assert (and (<= 1 if) (<= if 10)))
(assert (distinct at if))
(check-sat)"
Given the social network of individuals with attributes 'name' and 'relationship_type', find the maximum number of people who are directly related to each other.	This can be solved using QF_UF or QF_LIA, where we express a relationship between two individuals as an equivalence relation. We then use the fact that the size of an equivalence relation is equal to the number of pairs of distinct elements in the set. This allows us to compute the maximum number of people who are directly related to each other.	"(declare-const of_friend_to Bool)
(declare-const to_friend_of Bool)
(assert (= of_friend_to to_friend_of))
(assert (= true of_friend_to))
(check-sat)"
Prove that there exists an integer x such that x + 1 = 2 * x	Use QF_UF and set-logic to prove the statement	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that a person can go to exactly two different cities if they travel between cities in different countries.	Using the QF_UF model with a set of cities and countries, prove that the person's travel history is consistent.	"(declare-const a Int)
(declare-const can Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 can) (<= can 10)))
(assert (distinct a can))
(check-sat)"
Prove that a person is either married or single.	(set-of-values x:Person; (set-of-assertions x:-single | x:-married))	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Use QF_LIA to express the relationship between friends and their relationships with others.	Use QF_UF with a set of 'not' constraints to express the relationship between individuals.	
Find all triples (a, b, c) where a has degree 2 in graph G and b is adjacent to both a and c	Use QF_LIA constraints to enforce the properties of the relationships.	"(declare-const G Int)
(declare-const a Int)
(assert (and (<= 1 G) (<= G 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct G a))
(check-sat)"
Find all pairs of distinct people in a university with exactly one common friend.	Use QF_UF to model this relationship and QLIA to restrict the number of friends each person can have.	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (= a_friend_in in_friend_a))
(assert (= true a_friend_in))
(check-sat)"
The set of all prime numbers less than or equal to 100	{(set-logic QF_UF) {(declare-const P UU)   assert (forall (x UU) ( eg ((xor x P) (xor P x))))	"(declare-const of Int)
(declare-const or Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 or) (<= or 10)))
(assert (distinct of or))
(check-sat)"
The given social relationship is valid.	Use QF_UF and set-logic QF_UF to ensure validity of constraints.	
Prove that every person is related to themselves.	Use QF_UF to assert that each person is connected to at least one other person, and then use QF_LIA to conclude that there are no cycles in the graph.	"(declare-const is Int)
(declare-const to Int)
(assert (and (<= 1 is) (<= is 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct is to))
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 0	Use QF_UF and set-logic to reason about the existence of solutions to this equation.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that if person A is friends with person B, and person B is friends with person C, then person A is friends with person C	Use QF_UF and QF_LIA constraints to derive the desired implication. Use the following assumptions: (A,B) and (B,C), and (C,A).	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Prove that for all integers n >= 5, n^2 + n - 13 > 0	The following statements are true:  - set-logic QF_UF - set-logic QF_LIA - declare-const n_ int - declare-variable x int - assert (x = 5) - assert (x^2 + x - 13 > 0)	"(assert true)
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 4x and 2x > 0	Using QF_UF with the set of variables {x} and the constraints from the problem statement, we can derive the following expression: 2 * (x^2 - 4) = 0. Solving for x, we get x = 16. Therefore, there exists an integer solution to the equation.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The friends of Alice are married, but Bob is not	To ensure this is true, we need to assert that (set-of-people x y) != (set-of-people x z)	"(declare-const is_friend_of Bool)
(declare-const of_friend_is Bool)
(assert (not is_friend_of))
(assert (not of_friend_is))
(check-sat)"
Prove that there exists an integer x such that x^2 + 4x - 3 = 0	To prove this equation has a solution, we can use the fact that it is a quadratic equation with two roots. We can also use the method of completing the square to simplify the equation.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that a person is not a friend of themselves	Use   to separate the reasoning into two parts: first, prove that an individual is friends with another if they have at least one movie in common, and second, prove the converse	"(declare-const a_friend_is Bool)
(declare-const is_friend_a Bool)
(assert (not a_friend_is))
(assert (not is_friend_a))
(check-sat)"
Prove that there exists an integer x such that 2*x + 3 >= 0	To prove this, we can use the QF_UF logic with 2*u + 3 <= -u for u >= 0. This is because for any non-negative integer u, 2*u + 3 will always be greater than or equal to 1, satisfying the condition.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The following social constraint is invalid: \nIt states that Alice and Bob are friends when they do not have a mutual friend, which is a contradiction.	\nTo resolve this conflict, we can add constraints to ensure that if Alice is friends with X, then X must also be friends with Alice. This can be achieved using the following QF_UF clause: (\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n)	"(declare-const a_friend_do Bool)
(declare-const do_friend_a Bool)
(assert (not a_friend_do))
(assert (not do_friend_a))
(check-sat)"
Prove that there does not exist an ordered pair of integers (x, y) such that x = 2 and y = 4	This statement can be proven using the QF_UF rule and the fact that x cannot be both even and odd.	"(declare-const an Int)
(declare-const of Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct an of))
(check-sat)"
Prove that there exists an integer x such that x + 1 = 2*x	"\begin{align*} (\exists x (\forall y (y < x \ 2*y == x+y))) &
ightarrow ((\exists z (z >= 0 \ z != -1)))) \end{align*}"	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Satisfying the social constraint: No two people in the same group.	Use QF_UF or QF_LIA to ensure that each person is in a unique set of groups.	"(declare-const No Int)
(declare-const in Int)
(assert (and (<= 1 No) (<= No 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct No in))
(check-sat)"
Prove that there exists an integer x such that 2x + 1 > 0	To prove this, we can use the QF_LIA solver with the following constraints: (set-logic QF_UF) (declare-const x Int) (assert (>= 0 (1 + 2 * x)))	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
A university has two classes: History and English.	The class that starts later must be the one with more students	"(declare-const A Int)
(assert (and (<= 1 A) (<= A 3)))
(check-sat)"
Prove that if Alice and Bob both have a pet cat, then they are friends.	\begin{qf uf} \setof(x:person) (x ~ x.pet.cat) & (x ~ y.pet.cat) \declare-relation(p,q:friend)(p.y ~ q.y) \check-sat	"(declare-const a_friend_if Bool)
(declare-const if_friend_a Bool)
(assert (= a_friend_if if_friend_a))
(assert (= true a_friend_if))
(check-sat)"
PREDicates and Atomic Variables: Prove that there exists an integer x such that x^2 = 0	The solution to this problem can be proven using QF_UF, given the constraints (set-logic QF_UF) and (declare-const x :: int). The key insight is to recognize that if there does not exist an integer x such that x^2 = 0, then we must have a contradiction. This would mean that either x or x+1 cannot be zero, which implies that x is not an integer, leading to a contradiction.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	Use QF_UF and QF_LIA axioms to prove that a valid schedule can be constructed from a given set of jobs with different durations.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the linear programming relaxation of the knapsack problem	Using QF_UF with an interval representation to solve this linear program	"(assert true)
(check-sat)"
Scheduling Problem	Integer linear programming to optimize task allocation on a machine with multiple processing units.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	# Use QF_UF and QF_LIA rules with simple integer constraints to model the scheduling problem. The SMT-LIB program should include the following constraints: # A must be executed by processor C1 P_A <= P_C1 * 2; # Assign tasks to processors based on their capabilities # B must be executed by processor C2 P_B <= P_C2 * 3; # Assign tasks to processors based on their capabilities # Check if the assignment satisfies all constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfies the linear programming relaxation of the flow network of scheduling problem with three nodes and four edges, where each edge has two capacities.	This problem can be solved using the flow network solver of SMT-LIB.	"(assert true)
(check-sat)"
Scheduling Problem	Construct a scheduling problem with two tasks that cannot be scheduled together.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling: max-work-hours	assert (set-logic QF_UF) and (declare-const hours 1: integer) and (declare-const total_hours 0: integer) and (assert (=, total_hours, sumhours(hours))) and (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA with simple integer and boolean constraints to model a scheduling algorithm that assigns jobs to machines based on their processing time and machine capacity.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF with integer variables	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF to solve this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
\(\setoflucore uf) \+ (\declareconst i32 x 10)	\(\checksat (\assert true) \| (\checksat false))	"(declare-const i32 Int)
(declare-const uf Int)
(assert (and (<= 1 i32) (<= i32 10)))
(assert (and (<= 1 uf) (<= uf 10)))
(assert (distinct i32 uf))
(check-sat)"
Scheduling Problem	Use QF_UF to model scheduling as a maximization problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
{'type': 'scheduling', 'domain': 'transportation'}	{'type': 'explanation', 'domain': 'scheduling'}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Check if this scheduling problem is solvable in practice.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a scheduling problem	{'approach': 'brute-force', 'search': 'depth-first'}	"(assert true)
(check-sat)"
\(declare-const x 0: Int\); (set-logic QF_UF)\n(declare-const y 1: Boolean; (assert \(x = true; \))\n(check-sat)	Using the properties of equality and union to derive new constraints	"(declare-const n Int)
(declare-const x Int)
(assert (and (<= 1 n) (<= n 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct n x))
(check-sat)"
Scheduling Problem	Use QF_LIA and set-logic QF_UF to generate constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling problem to minimize make times and meet deadlines	Use QF_UF and QF_LIA rules to analyze constraints on machine times and resource utilization.	"(assert true)
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to enforce valid scheduling rules	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF with linear constraints to model a scheduling problem where tasks are assigned to time slots and their start times must be within a certain range.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to model the scheduling of tasks on a shared resource.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA SMT-LIB rules to derive a valid scheduling plan.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to generate valid constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Minimize Latency	Use QF_LIA and set-logic QF_UF to ensure validity and correctness.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find an assignment that satisfies all constraints	Using QF_UF and QF_LIA, derive valid integer constraints to satisfy the scheduling problem.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_LIA to reason about scheduling constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Maximize the number of customers served while minimizing idle time	Use QF_UF and QF_LIA rules to model the scheduling problem, including constraints on customer arrival and departure times, as well as idle time.	"(assert true)
(check-sat)"
Scheduling Problem: Find an optimal assignment of jobs to machines in a factory	Use QF_UF and QF_LIA rules to solve this scheduling problem, ensuring that all constraints are satisfied exactly.	"(declare-const a_of Bool)
(declare-const a_to Bool)
(declare-const an_of Bool)
(declare-const an_to Bool)
(declare-const in_of Bool)
(declare-const in_to Bool)
(assert (= (+
  (ite a_of 1 0)
  (ite an_of 1 0)
  (ite in_of 1 0)
) 1))
(assert (= (+
  (ite a_to 1 0)
  (ite an_to 1 0)
  (ite in_to 1 0)
) 1))
(assert (<= (+
  (ite a_of 1 0)
  (ite a_to 1 0)
) 1))
(assert (<= (+
  (ite an_of 1 0)
  (ite an_to 1 0)
) 1))
(assert (<= (+
  (ite in_of 1 0)
  (ite in_to 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to solve the scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
(set-logic QF_UF  (declare-const x int)  (declare-const y int)  (assert (>= x 0)    (<= y 10) )	This is a problem that will be solved using SMT-LIB.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Scheduling Problem	Formally specify scheduling constraints using QF_UF and QF_LIA.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the parity of three signals in a 3D system	Use QF_UF with equality constraints and set-logic QF_LIA to enforce non-increasing order.	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Satisfy the following scheduling constraint: Minimize make_time(1, 2) + make_time(3, 4)	Use QF_UF and QF_LIA constraints to ensure that make_time(1, 2) <= make_time(3, 4).	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to prove the satisfiability of the scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA clauses to model the scheduling of tasks on a single processor.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a scheduling conflict on multiple servers	Using QF_UF and QF_LIA to ensure tight coupling between tasks and servers, while respecting resource constraints.	"(declare-const a Int)
(declare-const on Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 on) (<= on 10)))
(assert (distinct a on))
(check-sat)"
Scheduling Problem: Resource Allocation	Use QF_UF and QF_LIA constraints to model resource allocation in a scheduling problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF to define sets of variables and use QF_LIA to check consistency.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Maximize Productivity with Limited Time	This problem can be solved using QF_UF and QF_LIA constraints to ensure that the production of products does not exceed the available time.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	{'constraints': ['(set-logic QF_UF)', '(declare-const X 1)', '(declare-const Y 2)', '(assert (<= X 10))'], 'clauses': ['(check-sat)']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling problem with no conflicts	Use QF_LIA to model this scheduling problem without conflicts.	"(assert true)
(check-sat)"
Scheduling Problem	This problem uses QF_UF and QF_LIA formulas to model a real-time system.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and check-sat to prove the validity of the program, which asserts that there exists an integer solution to the scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	{'constraint_type': 'integer_lower_bound', 'variables': ['x', 'y'], 'constraints': ['(set-logic QF_UF)', '(declare-const x int)', '(declare-const y int)', '(assert (>= x 0))', '(assert (<= y 10))']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Integer Constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the following linear programming relaxation of the 8-hour workday problem with additional constraints	Using QF_UF and QF_LIA, derive the solution to a system of linear equations representing the 8-hour workday problem, where employees are only allowed to work up to 40 hours per week.	"(assert true)
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to prove validity	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Maximize Customer Satisfaction	Use QF_UF or QF_LIA to generate a valid model and check its satisfiability.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Formulate a valid schedule that satisfies all constraints and meets the deadline.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	{'type': 'clausal', 'constraints': ['(set-logic QF_UF)', '(declare-const x Int)', '(declare-const y Bool)', '(assert (not (= x 0)))']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to model this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Find all valid solutions to the following system of linear equations with two variables.	Use QF_LIA and integer constraints to solve this system.	"(declare-const of Int)
(declare-const to Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct of to))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to ensure valid constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling: maximize {x, y} where x is the number of customers served in the first hour and y is the number of customers served in the last hour	The goal is to maximize the total number of customers served within a fixed time frame. This can be achieved by prioritizing customers based on their arrival times.	"(declare-const in Int)
(declare-const is Int)
(assert (and (<= 1 in) (<= in 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct in is))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA constraints to model a scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	To solve the scheduling problem, we need to find an assignment of tasks to machines that satisfies all constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find the optimal assignment of tasks to machines	Use QF_UF and QF_LIA constraints to enforce valid scheduling rules, and check for satisfiability using QBF or DPLL-SAT.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA to represent the scheduling problem as a logic formula	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA solvers to reason about valid schedules.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following scheduling constraint using QF_UF and basic arithmetic constraints.	Use the following set of rules to derive the solution: (set-logic QF_UF) (declare-const X < 10) (assert X > 0) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA constraints to ensure fairness in resource allocation.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given a set of jobs with deadlines and resource requirements, determine the optimal assignment of jobs to machines without violating any deadlines or resource constraints.	Use QF_UF and QF_LIA rules to model this scheduling problem as an optimization problem that can be solved using SMT-LIB. Include assertions for machine availability and job deadlines.	"(declare-const a_to Bool)
(declare-const of_to Bool)
(declare-const or_to Bool)
(assert (= (+
  (ite a_to 1 0)
  (ite of_to 1 0)
  (ite or_to 1 0)
) 1))
(assert (<= (+
  (ite a_to 1 0)
) 1))
(assert (<= (+
  (ite of_to 1 0)
) 1))
(assert (<= (+
  (ite or_to 1 0)
) 1))
(check-sat)"
Scheduling Problem: Minimize Makespan	Given a set of tasks with start times and durations, find the order that minimizes the total makespan.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying an integer linear equation	(= (int x) ( (1 + 2)  = 3))	"(assert true)
(check-sat)"
scheduling_problem	derive_satisfiability_from_just_the_constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	(set-logic QF_UF)  define-variables   x: integer   y: boolean,   z: real  (assert (not (= x 0))) (assert (not (= y true))) (assert (= z 1.5))	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find the minimum number of machines required to schedule tasks with maximum utilization	This problem can be solved using First-Order Logic (FOL) constraints in SMT-LIB. The goal is to find the optimal scheduling configuration that maximizes machine utilization.	"(declare-const of Int)
(assert (and (<= 1 of) (<= of 3)))
(declare-const to Int)
(assert (and (<= 1 to) (<= to 3)))
(assert (distinct of to))
(check-sat)"
Scheduling Problem	{'type': 'Propositional Reasoning', 'reason': 'Using QF_UF with integer constraints and checking satisfiability'}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	Use QF_UF with set of variables and universal quantification to model a scheduling problem where tasks have start and end times.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Generate an exact solution for the following linear programming relaxation of the 5-hour delivery problem	Use QF_UF and QF_LIA constraints to model integer variables representing hours worked by drivers, and use assert statements to enforce non-negativity.	"(declare-const an Int)
(declare-const of Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct an of))
(check-sat)"
\(set-logic QF_UF \n\n(declare-const X true \n  \n  (assert Y = 1) \n  (assert Z < 5))\n	This is a valid SMT-LIB program that includes the necessary logic for model checking and satisfiability.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find optimal assignment of tasks to machines	Use QF_UF and QF_LIA solvers with simple constraints, e.g., (set-logic QF_UF)   (declare-const machine <1..4>   (declare-const task <1..5>))   (assert (>= 0 (size of task)))	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to prove that it is NP-complete.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA to enforce valid scheduling constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA to model the scheduling problem	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find the optimal assignment of tasks to machines	Use QF_UF and QF_LIA constraints to reason about machine resource allocation.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to enforce precedence constraints on tasks	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF to model the scheduling of tasks with deadlines and resource constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA constraints to model this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Determine if it is possible to assign all tasks to employees within a given time frame.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to model scheduling problems.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF with valid constraints to solve this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a scheduling constraint	Use QF_UF and QF_LIA constraints to model the problem	"(assert true)
(check-sat)"
Modeling scheduling conflicts in a production line	\n\n\n(\n  \n    \n    (\n      \n      \n      \n      \n      \n      \n      \n    ),\n\n  \n\n  (\n    \n    (\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    )\n\n  \n)	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Scheduling Problem	Using QF_UF and QF_LIA rules to reason about scheduling constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	This problem requires the use of QF_UF and QF_LIA rules to reason about scheduling constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Using QF_UF and set-logic to model scheduling problems with multiple tasks and resource constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	Use QF_UF rules to model the scheduling of tasks with dependencies.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following integer linear program: P = { x, y | x + y <= 5, x >= 0, y >= 0 }	Use QF_UF and QF_LIA constraints to ensure satisfiability, then check for valid solutions.	"(declare-const P Int)
(declare-const x Int)
(assert (and (<= 1 P) (<= P 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct P x))
(check-sat)"
Scheduling Problem: Given two tasks t1 and t2, assign task t1 to machine M1 and task t2 to machine M2 if both machines are not busy	Propositional Reasoner	"(declare-const M1_t1 Bool)
(declare-const M1_t2 Bool)
(declare-const M2_t1 Bool)
(declare-const M2_t2 Bool)
(declare-const if_t1 Bool)
(declare-const if_t2 Bool)
(assert (= (+
  (ite M1_t1 1 0)
  (ite M2_t1 1 0)
  (ite if_t1 1 0)
) 1))
(assert (= (+
  (ite M1_t2 1 0)
  (ite M2_t2 1 0)
  (ite if_t2 1 0)
) 1))
(assert (<= (+
  (ite M1_t1 1 0)
  (ite M1_t2 1 0)
) 1))
(assert (<= (+
  (ite M2_t1 1 0)
  (ite M2_t2 1 0)
) 1))
(assert (<= (+
  (ite if_t1 1 0)
  (ite if_t2 1 0)
) 1))
(check-sat)"
scheduling:make-schedule	show that it is impossible to schedule two tasks with different start times and one task can be delayed by any amount of time without violating the constraints.	"(declare-const X Int)
(assert (and (<= 1 X) (<= X 3)))
(declare-const Y Int)
(assert (and (<= 1 Y) (<= Y 3)))
(declare-const Z Int)
(assert (and (<= 1 Z) (<= Z 3)))
(assert (distinct X Y Z))
(check-sat)"
{'solver': 'smt2', 'input': '\\{(\\x0 \\y -5) + (\\z + 10) <= 15; \\x1 = (\\x3 + 2) * (\\x4 - 3); \\z = 12; \\v = true; \\w = false;\\n\\(\\x0 < 0 \\n\\n(\\y - 5) * (\\z + 10) <= 15 \\n\\n(\\x1 = (\\x3 + 2) * (\\x4 - 3))\\n\\n(check-sat)'}	{'solver': 'smt2', 'input': '\\{(\\x0 \\y -5) + (\\z + 10) <= 15; \\x1 = (\\x3 + 2) * (\\x4 - 3); \\z = 12; \\v = true; \\w = false;\\n\\(\\x0 < 0 \\n\\n(\\y - 5) * (\\z + 10) <= 15 \\n\\n(\\x1 = (\\x3 + 2) * (\\x4 - 3))\\n\\n(check-sat)'}	"(declare-const n Int)
(declare-const v Int)
(assert (and (<= 1 n) (<= n 10)))
(assert (and (<= 1 v) (<= v 10)))
(assert (distinct n v))
(check-sat)"
Satisfying the constraint that all tasks in a scheduling problem have at least one feasible solution	Use QF_UF and QF_LIA axioms to ensure feasibility, then use modus ponens and contradiction elimination to prove satisfiability.	"(declare-const a Int)
(declare-const at Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 at) (<= at 10)))
(assert (distinct a at))
(check-sat)"
Scheduling Problem: Find the optimal assignment of tasks to machines in a factory	Use QF_UF or QF_LIA constraints and simple integer or boolean constraints to model the problem.	"(declare-const a_to Bool)
(declare-const in_to Bool)
(declare-const of_to Bool)
(assert (= (+
  (ite a_to 1 0)
  (ite in_to 1 0)
  (ite of_to 1 0)
) 1))
(assert (<= (+
  (ite a_to 1 0)
) 1))
(assert (<= (+
  (ite in_to 1 0)
) 1))
(assert (<= (+
  (ite of_to 1 0)
) 1))
(check-sat)"
Satisfy the following system of linear equations with two variables x and y	Use the QF_UF rule to introduce new variables, then use QF_LIA to eliminate them, and finally assert the truth of the resulting equation.	"(declare-const of Int)
(declare-const x Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct of x))
(check-sat)"
Satisfy the constraints of a finite automaton	Use QF_UF and QF_LIA rules to express the constraints of the automaton	"(declare-const a Int)
(declare-const of Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct a of))
(check-sat)"
Satisfy the following linear equations using QF_UF and QF_LIA rules	Use simple integer constraints to represent the relationships between variables.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following constraint using QF_UF and QF_LIA	Use simple integer constraints and   newlines to separate logical statements	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Using QF_UF and QF_LIA rules to derive a valid scheduling plan from a set of constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Resource Allocation Problem	Use QF_UF to model the allocation of resources.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation: Assigning Resources to Tasks	{'variables': ['x', 'y'], 'constraints': ['(set-logic QF_UF)', '(declare-const x Integer)', '(declare-const y Boolean)', '(assert x >= 0)'], 'solver': 'SMT-LIB'}	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA axioms to model this problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Prove that there exists an integer x such that x = 1 and (x + 2) mod 3 = 0	Using the properties of modular arithmetic, we can show that this equation is true for all values of x.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Resource Allocation	Use QF_UF or QF_LIA with simple integer and boolean constraints to solve a resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to ensure valid integer solutions.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
{'name': 'Resource Allocation', 'description': 'A resource allocation problem in a cloud computing environment'}	Using QF_UF and set-logic, we can model this problem as follows:  set-logic QF_UF; assert (declare-const x:integer >= 0); assert (declare-const y:integer > 0); check-sat;	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation: Minimize Number of Server Assignments	(set-logic QF_UF) (declare-const x : integer) (assert (x > 0)) (check-sat)	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF to enforce unit-of-formula equality	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: 3 resources available, 4 requests to allocate	Use QF_UF and QF_LIA constraints to ensure integer solutions are found	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF logic to model this resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA solvers to find an optimal assignment of resources to tasks.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model a resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to define a set of constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	To allocate resources to tasks, we need to minimize waste and maximize efficiency.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use of QF_UF or QF_LIA constraints to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA formulas to model this resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
(set-logic QF_UF (declare-const x int : 1) (assert (equivalent? (add 2 x) (add 5 x)))	Using the properties of arithmetic operations and addition, we can deduce that if (add 2 x) = (add 5 x), then (add 3 x) must be true.	"(assert true)
(check-sat)"
Resource allocation problem	Satisfiability Reasoning and Computation System	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to processes	Using QF_UF and QF_LIA, derive that there exists a valid assignment of resources to each process such that the total resource usage is non-negative.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to ensure fairness in resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: 5 machines, 3 software licenses	Using QF_UF with constraints on machine availability and license usage.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA to model resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to reason about resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to processes	Use QF_UF and QF_LIA constraints to model resource allocation, considering bounds on resources and process demands.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Using QF_UF with set-logic and declare-const constraints to model the allocation of resources between two processes.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation	Using QF_UF with linear constraints to optimize resource usage.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Allocate resources to tasks with minimum latency	{'variables': [{'name': 'latency', 'type': 'int'}], 'assumptions': ['(set-logic QF_UF)', '(declare-const task1-latency 10)', '(declare-const task2-latency 5)'], 'conclusions': ['(assert (leq task1-latency task2-latency 5))']}	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA logical frameworks to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
{'name': 'Resource Allocation', 'description': 'A problem of resource allocation in a computer system', 'satisfiability': False}	{'rule1': '(set-logic QF_UF)', 'rule2': '(declare-const x integer)', 'rule3': '(declare-const y boolean)'}	"(declare-const A_of Bool)
(declare-const a_of Bool)
(declare-const in_of Bool)
(assert (= (+
  (ite A_of 1 0)
  (ite a_of 1 0)
  (ite in_of 1 0)
) 1))
(assert (<= (+
  (ite A_of 1 0)
) 1))
(assert (<= (+
  (ite a_of 1 0)
) 1))
(assert (<= (+
  (ite in_of 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Using QF_UF and set-logic to model resource allocation problem	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
(set-logic QF_UF (declare-const x y Z)	This is a valid program, and it will always find a solution.	"(declare-const Z Int)
(declare-const x Int)
(assert (and (<= 1 Z) (<= Z 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct Z x))
(check-sat)"
Resource allocation: Assigning resources to tasks	Use QF_UF and QF_LIA rules to reason about resource availability	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation	Use QF_UF or QF_LIA to specify the resource constraints and then assert them using set-logic.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to model resource allocation problems, ensuring that resources are allocated in an optimal manner.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF to find valid assignments that satisfy all constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Using QF_UF with set of variables and assertions to solve a resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
\(set-logic QF_UF\) \(declare-const x_0 bool\) \(assert (x_0 = true)\)	\(check-sat\)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to model resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA constraints to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA solvers to find an optimal assignment of resources.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA axioms to reason about resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA quantifiers to model the problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to tasks	Use QF_UF and QF_LIA rules to constrain resource allocation.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation: Minimize the number of machines used in the data center	Use QF_UF and QF_LIA to model this problem, and ensure that it includes  - (set-logic QF_UF) or QF_LIA. Use simple integer constraints for machine utilization.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation: Assigning resources to tasks	Using QF_UF and QF_LIA constraints to ensure fairness in resource allocation, while also ensuring that the system is satisfiable.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Prove that it is possible to allocate resources such that all devices are used and no device is idle	(set-logic QF_UF) # Define the universe of discourse as integers from 0 to N-1 (where N is the number of devices)  (set-logic QF_UF)(declare-const N: int)  (assert (>= N 2))  (check-sat)	"(declare-const is_to Bool)
(declare-const it_to Bool)
(declare-const no_to Bool)
(assert (= (+
  (ite is_to 1 0)
  (ite it_to 1 0)
  (ite no_to 1 0)
) 1))
(assert (<= (+
  (ite is_to 1 0)
) 1))
(assert (<= (+
  (ite it_to 1 0)
) 1))
(assert (<= (+
  (ite no_to 1 0)
) 1))
(check-sat)"
Resource Allocation: Assigning Resources to Jobs	Use QF_UF and QF_LIA constraints, and ensure that all constraints are linear and integer/boolean.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Integer Variables with Bounds	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to servers in a cloud-based data center	Use QF_UF and QF_LIA constraints to model the resource allocation decision.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and set-logic to model resource allocation with multiple constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA logic to reason about resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Using QF_UF and QF_LIA rules, derive a valid solution that maximizes resource utilization.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Minimize the number of printers used	Using QF_UF and QF_LIA constraints, prove that it is not possible to allocate enough printers to satisfy all user requests without exceeding the available capacity.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	To ensure efficient resource allocation, we use the QF_UF and QF_LIA rules.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA theory to reason about resource constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use the QF_UF and QF_LIA logics to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
{'smtplib': 'int(x) <= x + 1'}	Satisfiability with constraints (set-logic QF_UF; assert x > 0; check-sat)	"(assert true)
(check-sat)"
Resource allocation problem	This problem involves allocating resources to tasks with different priorities and constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	To allocate resources efficiently, we need to minimize waste and maximize utilization of available resources.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA to represent resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA rules to model resource allocation problems	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	{'type': 'model-checking', 'description': 'Verify that a resource allocation model satisfies QF_UF and QF_LIA constraints.'}	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use set-logic QF_UF and declare-const to specify resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA rules to formulate a valid resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA solvers, and assert that the program produces exactly one solution.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Maximize production of 5 units while minimizing waste	Using QF_LIA and set-logic QF_UF, the following constraints can be derived.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
{'input': '\\(set-logic QF_UF\\) \\n \\n (declare-const x Int\\n \\n assert (x = 0)\n \\n check-sat)'}	This SMT-LIB program checks if a number is zero	"(declare-const n Int)
(declare-const x Int)
(assert (and (<= 1 n) (<= n 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct n x))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA to model this problem and ensure validity.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: assigning 10 units of CPU to process 1 and 5 units to process 2	Use QF_UF and QF_LIA constraints to model the resource allocation problem. Ensure that the total number of units allocated is exactly 15.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation: 3 cars and 4 passengers	Use QF_UF and set-logic to ensure that each passenger has at least one seat	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation optimization	Use QF_UF and QF_LIA constraints to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation	Use QF_UF and assert/declare/check-sat to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	(set-logic QF_UF) (declare-const x (int)) (assert (not (= 2, 0))) (check-sat)	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA to specify the resource allocation model.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Ensure that the minimum number of units required to satisfy all resource constraints is met	Use QF_UF and QF_LIA to reason about the satisfiability of the program, and check for validity using SMT solver.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF with assert statements to model this problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA rules to ensure feasibility.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: 5 agents, each with capacity 2 and deadline 10	Use QF_UF and QF_LIA rules to prove existence of a solution that satisfies all constraints	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	 - {set-logic QF_UF         assert (2 > 0)}	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to solve this optimization problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA solvers with simple integer constraints to model this problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Ensure that the maximum number of employees is allocated to each department	Use QF_UF or QF_LIA quantifier, and simple integer constraints (e.g., <=) to represent the relationship between departments and employees.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A woman has two coins that total 30 cents. One coin is not a nickel, and one coin is not a quarter. What type of coin are they?	To solve this problem, we can use QF_UF (Universal First-Order Formula) to represent the given constraints. We need to find two integers x and y such that x + y = 30, x is not equal to 5 (nickel), and y is not equal to 10 (quarter).	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
A farmer has a rectangular field with integer coordinates in pixels, and she wants to know if it's possible to place a row of n x m flowers on this field such that no two flowers are adjacent.	This problem can be solved using QF_UF (Unfolding Formulas) or QF_LIA (Linear Arithmetic Inequality).	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
Solve for x: 2*x + 5 = 11	Use QF_LIA and set-logic to model this equation as an equality of integer constraints.	"(assert true)
(check-sat)"
A farmer has a field with 3 rows and 4 columns. Each cell can hold either an integer from 1 to 10, inclusive.	{   (set-logic QF_UF)   (declare-const row1 int   row2 int   row3 int),   (declare-const col1 int   col2 int   col3 int),   (assert (>= row1 1)            (<= row1 10))   (assert (>= row2 1)            (<= row2 10))   (assert (>= col1 1)            (<= col1 4))   (assert (>= col2 1)            (<= col2 3))   (assert (>= col3 1)            (<= col3 4))   (check-sat)}	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
3+2=5	Using QF_LIA, we can assert that the sum of two integers less than or equal to 10 is greater than 1 and less than or equal to 15.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Solve for x: 2*x + 5 = 11	Use QF_LIA with constraints: x >= 0, 2x <= 6	"(assert true)
(check-sat)"
(set-logic QF_UF (declare-const x 1) (assert (>= x 0)) (check-sat)	This is a simple satisfiability problem, where we need to find an assignment of values to the variable x such that all constraints are satisfied.	"(assert true)
(check-sat)"
Solve the following logic puzzle: A bat and a ball together cost $1.10. The bat costs $1.00 more than the ball. If you have 5 times as many bats as balls, how much will you pay?	Let B represent the number of balls and B+ represent the number of bats. From the first equation, we get: B + (B+1) = 10. This simplifies to 2B + 1 = 10, or B = 4.5. Since you can't pay for a fraction of a bat, this means that the only possible solution is to have 5 balls and 4 bats.	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
The Five Switches	Use QF_LIA and set-logic QF_UF to prove that there is exactly one way to program a computer to switch between five lights on, one at a time, while the lights are off.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that there exists an integer x such that x^2 + x - 5 = 0	Use QF_UF and set-logic to prove the existence of a solution, and use check-sat to find it.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The Five Houses	Using set-logic QF_UF and quantifiers, prove that there exists a house on each row such that at least one of its doors is open.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF and QF_LIA to prove that there exists a number between 1 and 3 that has exactly one switch on.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	(set-logic QF_UF) (declare-const x true) (declare-const y false) (declare-const z true)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Five Houses Problem	To solve this problem, we need to use the QF_UF and QF_LIA SMT-LIB rules.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A man, a plan, a canal, Panama!	(set-logic QF_UF   (declare-const X 0 5)   (declare-const Y 5 10))(assert (>= X 1) (<= Y 4))   (check-sat)	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Three Switches	Use QF_UF and assert statements to prove that there is a unique solution to this puzzle.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Five Houses Problem	To solve this puzzle, we need to find a valid assignment of integers from 1 to 5 to the five houses such that no two adjacent houses have more than one occupant.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF to represent three switches, and assert that they are either all on or none of them is on.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has 'a' apples and 'b' bananas in his orchard. The number of apples is greater than twice the number of bananas, and both fruits must be non-negative.	The constraints are: (set-logic QF_UF) (declare-const a int > 0) (declare-const b int > 0) (assert (a > 2 * b) (check-sat)	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
A farmer has three fields: A, B, and C. Field A can hold values 0 through 9. Field B can hold values -1 through 1. Field C can only hold the number 5.	The farmer needs to ensure that field C holds a value of either 0 or 4. If field A holds any other value, then field C must be 0. Otherwise, if field A is 5 or greater, then field B must be -1.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
(set-logic QF_UF   (declare-const x 9)   (declare-const y 10)   assert (>= x 0)   assert (<= y 100)   check-sat)	Satisfiability isomorphism using UFL constraints and linear integer programming.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Satisfy the following set of constraints on the variable x.	Use the quantifier 'for all' to generalize over all natural numbers n.	"(declare-const of Int)
(declare-const on Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 on) (<= on 10)))
(assert (distinct of on))
(check-sat)"
A farmer has 5 sheep and 3 goats. How many animals does she have?	(set-logic QF_UF  (declare-const A int  (A = 5)  (G int  (G = 3)))  (assert < A + G > 0))	"(assert true)
(check-sat)"
The Set of Twin Primes	- Prove that there do not exist two prime numbers p and q such that pq = 2.	"(assert true)
(check-sat)"
A 5-person committee needs to decide on a project leader.	Use QF_UF and assert constraints like (equal (= 1 2)) or (not (equal (= 3 4))).	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
Solve for x: 2x + 5 = 11	Use QF_UF and set-logic (maximize) to find an optimal solution.	"(assert true)
(check-sat)"
The Five Houses Problem	To solve this problem, we need to assign numbers to each of the five houses such that each house is assigned a number between 1 and 5 (inclusive), and no two adjacent houses have the same number.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use the rules provided by the problem to construct a valid solution.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Five Houses Puzzle	To solve this puzzle, we need to find a valid assignment of integers from 1 to 5 to the five houses such that each house is either occupied by an integer or not.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer wants to optimize his irrigation system to minimize water waste.	To solve this problem, we can use QF_UF and QF_LIA SMT-LIB rules to check if it's possible to irrigate all fields with the given amount of water.	"(declare-const A Int)
(declare-const to Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct A to))
(check-sat)"
Solve the following puzzle:  3 x + y = 6, 2x - y = 4.	(set-logic QF_UF) (declare-const x Int) (declare-const y Int) (assert (>= x 0) (assert (>= y 0)) (verify-sat)	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
A person is standing next to a box with an unknown weight. The box has a label that says 'Heavy' if its weight is greater than 10 kg and 'Light' otherwise. The person is holding the box, but they don't know which side it's on. What can be said about the box?	Using QF_UF, we can assert that the box is either Heavy or Light.	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
There are three switches: hot, cold and off.  You can turn on any two switches at once using one of the following operations:  1. Turn on switch A and then off switch B.  2. Turn on switch C and then off switch D.  3. Turn on switch B and then off switch D.  4. Turn on switch A and then turn on switch C.  5. Turn on switch C and then turn on switch D.	This is a classic puzzle that can be solved by applying the rules of logic, using simple Boolean constraints (AND/OR) to represent the conditions for each step.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A man, a plan, a canal, Panama!	(set-logic QF_UF   (declare-const X 0 5)   assert (<= X 0)   check-sat)	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Five Houses Puzzle	To solve this puzzle, we need to use QF_UF constraints to represent the relationships between the houses and their occupants.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF to create a function symbol and apply it to three variables in a predicate.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following statement	Use the QF_UF and QF_LIA rules to generate a model that satisfies this statement.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a linear equation with two variables	Use QF_UF to ensure equality and QF_LIA to allow variable combination.	"(assert true)
(check-sat)"
Find integers x such that x^2 + 1 = x+3	This equation can be solved using QF_UF with the following constraints: (set-logic QF_UF) and (declare-const x integer)	"(assert true)
(check-sat)"
Prove that there exists an integer x such that x^2 + 4x - 7 = 0 and x is even	To prove this, we can use the QF_UF rules to find a model for the equation x^2 + 4x - 7 = 0. We can then analyze the models to determine which ones satisfy the condition that x is even.	"(declare-const an Int)
(declare-const is Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct an is))
(check-sat)"
(set-logic QF_UF (declare-const x 1 x < 5) (declare-const y 2 y = x + 3) assert (>= y 4)	To prove that the assertion is true, we can use a model with x >= 0 and y > 0.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
(set-logic QF_UF) (declare-const x 1) (assert (not (= x 0))) (check-sat)	To prove that x is not equal to 0, we can use the property of equality that if a = b then a = b.	"(assert true)
(check-sat)"
(set-logic QF_UF  define-const X 0  assert (<= X 5)  check-sat	This puzzle requires the solver to find a value for X such that it is less than or equal to 5.	"(assert true)
(check-sat)"
A farmer has a field that is 100 meters long and 50 meters wide. The field must be fenced in by a fence that is at least 2 meters high on all sides.	The farmer can use the following constraints to solve this problem:  - (declare-const field-width 50 :integer) - (declare-const field-length 100 :integer) - (assert (>= (add (multiply field-width 2) (add field-length 2)) (add field-width 2)))	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The set-builder logic asserts that there exists an integer x such that x^2 + 4x - 3 = 0.	\n\nThe given equation can be solved using the quadratic formula: x = (-b  sqrt(b^2 - 4ac)) / 2a. In this case, a=1, b=4, and c=-3. \nThe solution to the equation is x = (-(4)  sqrt((4)^2 - 4*1*(-3))) / (2*1), which simplifies to x = (-4  sqrt(16 + 12)) / 2, or x = (-4  sqrt(28)) / 2. Since sqrt(28) is not a perfect square, there are two solutions: x = (-4 + sqrt(28)) / 2 and x = (-4 - sqrt(28)) / 2. \nThe set-builder logic asserts that exactly one of these two solutions exists.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The Five Houses Problem	Use set-logic QF_UF and declare variables for each house number.  (declare-const house1-number 1) (declare-const house2-number 2) (declare-const house3-number 3) (declare-const house4-number 4) (declare-const house5-number 5)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Find an infinite set {x: [0, 1]}.	This problem can be solved using QF_UF.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that there exists an integer x such that x^2 + 4 = 13	Use QF_UF and set-logic to derive the desired formula.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
(set-logic QF_UF  (declare-const x 1)  (declare-const y 2)	This problem is a simple example of using set-logic QF_UF to reason about the satisfiability of a given formula.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
A farmer wants to ensure that all cows are wearing collars of a certain color.	The farmer has ordered 100 cows, each with one collar. The collar can be either red or blue. Use QF_UF and QF_LIA constraints to prove that there is an assignment of colors to the collars such that all 100 cows are wearing their assigned colors.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Flipped Coins	Use QF_UF with a set of variables and constraints to prove that it's impossible to flip all coins such that one side always shows the opposite number.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Prove that there exists an integer x such that exactly three switches are open.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF to prove that exactly one of three boolean variables can be false at any given time.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Prove that it is impossible to assign colors to three switches such that each switch corresponds to one of three colors and the corresponding color switch is red.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
\(\{\n  x: \n    # Introduce a variable and constraint\n    assert(x > 0);\n  y: \n    # Introduce another variable and constraint\n    assert(y < x);\n  z: \n    # Use SMT-LIB to prove the variables are equal\n  (set-logic QF_UF \n    (declare-const x : int) \n    (declare-const y : int) \n    (declare-const z : bool))\n  \n  assert(z);\n  \n  (check-sat)	\(\{\n  # We use the fact that x > 0 and x + y = z to prove x == z\n  assert(x + y = z + x);\n  \n  # Since z is True, we can deduce x == z\n  assert(x == z);\n  \n  \n  # Use the assumption that x < 0 and x - y = z to prove x != z\n  assert(x > 0 && x - y = z);\n  \n  # Since z is False, we can deduce x != z\n  assert(x != z);\n  \n  \n  \n  (check-sat)	"(declare-const a Int)
(declare-const n Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 n) (<= n 10)))
(assert (distinct a n))
(check-sat)"
A prisoner needs to escape from a cell with multiple locks, each of which has two possible keys: the correct key or the wrong key. The guards enter a room and check one lock at a time in order.	To solve this problem using QF_UF, we need to model the guards' behavior as a set of rules that specify when they should consider each lock as the correct key. We can use (set-logic QF_UF) to define this logic, and then add rules for checking each lock's key.	"(declare-const A Int)
(assert (and (<= 1 A) (<= A 3)))
(declare-const a Int)
(assert (and (<= 1 a) (<= a 3)))
(declare-const and Int)
(assert (and (<= 1 and) (<= and 3)))
(assert (distinct A a and))
(check-sat)"
A woman has two coins that weigh differently. One coin weighs 1 kg and the other weighs 0.9 kg. How much does the lighter one weigh?	Use set-logic QF_UF and assert   (weigh < 1kg)  and (not (weigh = 0.9kg))	"(declare-const A Int)
(declare-const kg Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 kg) (<= kg 10)))
(assert (distinct A kg))
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 0 and x is not odd	To prove this statement, we can use the QF_UF rule to generate a set of solutions for the equation x^2 + 1 = 0. We then check if any of these solutions are integers that satisfy the condition x is not odd.	"(declare-const an Int)
(declare-const is Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct an is))
(check-sat)"
A farmer has two fields, A and B. Field A has 5 apples, and field B has 3 oranges. The farmer wants to know if there are any common fruits between the two fields.	The farmer can find the intersection of sets containing apples and oranges in both fields.	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
A bat and a ball together cost $1.10. The bat costs $1.00 more than the ball. If the ball costs x dollars, how much does the bat cost?	Let b = number of cents in the ball. Then the equation is (100 - b) + b = 110. Solve for b.	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
Satisfying the union of two sets with distinct elements	Use QF_UF and set-builder constraints to model the union of two sets A = {1, 2} and B = {3, 4}. The constraint (set-logic QF_UF) ensures that each element in both sets is present. The constraint (declare-const x : setof int) defines a set of integers containing all elements from both sets. Finally, the constraint (assert all of A | B) asserts that any element in either set is present.	"(assert true)
(check-sat)"
A farmer has two fields, A and B. Field A is 3 units long, while field B is only 2 units long. The farmer wants to know if there are enough spaces on both fields.	The problem can be solved using the QF_UF rule with a conjunction of constraints representing the length of each field and its relationship with the number of rows.	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Satisfying a set of rules on the number of apples	Use QF_UF to generate constraints for the number of apples in each basket and then solve using check-sat.	"(declare-const a Int)
(declare-const of Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct a of))
(check-sat)"
A farmer has two fields: Field A and Field B. If it rains, both fields receive water, but only if it's not too hot.	let (   0:     assert (>= 20 any x) => (x = 'hot')   1:     assert (= 100 any y) => (y = 80)   2:     let (       z: set of string       f0: {x | x = 'hot', x < 20}       f1: {x | x = 'hot', x >= 20, x <= 30}       f2: {x | x = 'hot', x > 30})     assert (in z f0)     & (not in f1 f0)    & (in f2 f1)	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A farmer wants to irrigate all but two rows of his garden, and then water one row. What are the possible values for k?	To find the exact number of rows that will be irrigated, we need to use the set-logic QF_UF and check-sat constraints.	"(declare-const A Int)
(declare-const k Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 k) (<= k 10)))
(assert (distinct A k))
(check-sat)"
"{   'problem': ""Solve the following puzzle: There are three switches, but they are not labelled. Each switch corresponds to one of three light bulbs in a room. Each bulb is either on or off. You can turn the switches on and off as many times as you want, but you can only enter the room one time to observe the bulbs. How can you figure out which switch corresponds to which light bulb?"""	{   (set-logic QF_UF)   (declare-const bulb1 bool   bulb2 bool   bulb3 bool)   (declare-const switches [ bulb1 true    bulb2 false    bulb3 true ]   (assert not (switches[0]            or switches[1]            or switches[2]))   (check-sat)	"(declare-const a Int)
(assert (and (<= 1 a) (<= a 3)))
(declare-const as Int)
(assert (and (<= 1 as) (<= as 3)))
(declare-const in Int)
(assert (and (<= 1 in) (<= in 3)))
(assert (distinct a as in))
(check-sat)"
(set-logic QF_UF (declare-const x int) (declare-const y bool) (assert (>= x 0) (check-sat)	This is a simple problem that can be solved using basic arithmetic and logical constraints. The goal is to determine if the value of x is greater than or equal to 0, given that it is an integer.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
(set-logic QF_UF   (declare-const x y int)   (assert x > 0))	This is a simple logic puzzle where we are asked to prove that if x is greater than 0, then x is positive.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
A farmer has a field that can hold up to 1000 square meters of land. The field is currently empty, and it needs to be fenced in.	The farmer needs to fence in at least 800 square meters of land for this task.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Three Switches	Use set-logic QF_UF and assert/declare/declare-const to model a problem where a person has three switches, labelled A, B and C, and each switch corresponds to one of three light bulbs in a room. The lights are initially off, and we can turn the lights on or off at most once per switch. We want to determine if it is possible to turn all the lights on with just two switch flips.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
(set-logic QF_UF (declare-const x y 1))	(assert y = 1) && (check-sat)	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
The Three Switches	{'type': 'deductive', 'constraints': ['\n  assert (x = 0)\n', '\n  assert (y = 1)\n', '\n  assert (z = 2)\n']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use set-logic QF_UF and assert/unify to prove that there is no valid assignment of colors to switches such that each switch corresponds to either red or green.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the following system of linear equations with integer coefficients and constraints	Use QF_LIA or QF_UF to generate the model, then solve it using a solver like DPLL or CDT.	"(assert true)
(check-sat)"
(set-logic QF_UF (declare-const x 1 #t) (declare-const y 2 #f) (assert (x = true) (y = false)))	to prove that x and not y are both true or both false using only basic arithmetic operations and equality checks	"(declare-const f Int)
(declare-const t Int)
(assert (and (<= 1 f) (<= f 10)))
(assert (and (<= 1 t) (<= t 10)))
(assert (distinct f t))
(check-sat)"
The set of all perfect numbers	This is a classic problem in number theory, and it can be solved using QF_UF with constraints such as (forall x (<= 1000) (odd? x))	"(assert true)
(check-sat)"
Solve the puzzle: 5 cars are parked on the street, and each car has a different color. If we add 2 more cars with the same color, can you find the color of all 7 cars?	Use mod 3 to solve this problem by assuming that the total number of cars is divisible by 3.	"(declare-const If Int)
(declare-const a Int)
(assert (and (<= 1 If) (<= If 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct If a))
(check-sat)"
A farmer has a field with two rows and two columns. Each cell in the field can be either red or green. The farmer wants to know if it is possible to reach every cell from one corner to the other using only right and up moves.	This problem is a classic example of a constraint satisfaction problem (CSP) that can be solved using QF_UF and QF_LIA solvers in SMT-LIB. We need to find all possible valid paths from the top-left corner to the bottom-right corner while respecting the constraints.	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
Satisfy the following proposition: 2 + 2 = true.	This can be proved using the QF_UF rule and simple arithmetic constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use a model with three variables and two constraints to solve this puzzle.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given integers a and b, find all pairs of distinct positive integers c and d such that a + b = c + d	Prove the validity of the following system using QF_UF or QF_LIA with integer constraints: (set-logic QF_UF)   (declare-const a Int)   (declare-const b Int)   (declare-const c Int)   (declare-const d Int)   (assert (a + b = c + d))   (check-sat)	"(declare-const a Int)
(declare-const b Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 b) (<= b 10)))
(assert (distinct a b))
(check-sat)"
Prove that the following statement is true: x = 5 and y != 3	Use the QF_UF rule to combine the assertions of x = 5 and y != 3, then use the QF_LIA rule to prove the conjunction of these two statements. Finally, add a check-sat clause to verify that the system is satisfiable.	"(declare-const is Int)
(declare-const x Int)
(assert (and (<= 1 is) (<= is 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct is x))
(check-sat)"
Solve the following puzzle: A bat and a ball together cost $1.10. The bat costs $1.00 more than the ball. If the ball costs x dollars, how much does the bat cost? y.	$y-x=0.10\quad$y>x$	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
A 5-person committee must be formed from a group of 8 people, and each person can only speak on one topic.	Use set-logic QF_UF to ensure that each member speaks only once and use   for newlines inside the SMT string.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Five Houses Puzzle	Use QF_UF to express that each house is occupied by either a person or an animal.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has N cows to milk. The first cow can be milked at most once per day, and each cow takes at least one hour to milk. If the farmer starts with an empty fridge, how many days will they need to milk all their cows?	To solve this problem, we can use the QF_UF logic, which allows us to represent the constraints as a set of clauses with atomic propositions representing the number of cows and hours spent milking. We can then use the 'check-sat' solver to find an optimal solution.	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
The Three Switches	(set-logic QF_UF) (declare-const x 1) (assert (x = 0)) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has two fields, A and B. Field A contains all the apples from both fields combined. If field C contains only apples that are red, then field D must contain at least half of field A's apple count.	Use QF_UF and QF_LIA to solve this problem. Consider the constraints (set-logic QF_UF) and (declare-const ...). Use assert statements to define field A and field B. Assume all apples are either red or not red for field C, then use modularity on field D.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A farmer has 5 sheep and wants to build a fence around them. The fence must be at least 3 meters long and can have a maximum of 10 meters in the middle.	Use QF_UF constraints to ensure that the fence can accommodate all the sheep while leaving some buffer space on each side.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
A farmer has 'm' chickens and wants to know if they are all happy.	The answer is yes if and only if m = 5 or m = 6	"(declare-const A_friend_if Bool)
(declare-const if_friend_A Bool)
(assert (= A_friend_if if_friend_A))
(assert (= true A_friend_if))
(check-sat)"
The Life of Pi	Use QF_UF and assert constraints on pi, x, and y.	"(declare-const Pi Int)
(declare-const of Int)
(assert (and (<= 1 Pi) (<= Pi 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct Pi of))
(check-sat)"
A farmer has three fields: A, B and C. Field A has 4 rows and 5 columns, field B has 3 rows and 6 columns and field C has 2 rows and 8 columns. The farmer wants to know how many hot peppers are in each field.	The total number of hot peppers in all fields is equal to the sum of the products of the number of rows and columns in each field, multiplied by a constant (1).	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
\(\(\{1:2, 3:4} \) -> (false))	(set-logic QF_UF) (declare-const X int) (assert (X = 1) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
(set-logic QF_UF) (declare-const x 1  # t) (assert (<= 0 (and x 2) (add 3 x))) (check-sat)	"Using the <a href=""https://www.sat.inf.u-bremen.de/"">SAT solver</a> to verify the satisfiability of the given formula. We found that it is unsatisfiable for all values of x."	"(declare-const t Int)
(declare-const x Int)
(assert (and (<= 1 t) (<= t 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct t x))
(check-sat)"
The Three Switches	"(set-logic QF_UF 	(declare-const x 1) 	(declare-const y 2) 	(assert (not (= x 0))) 	(check-sat)"	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	QF_UF and set-logic QF_LIA	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has 5 rows of flowers in her garden, and each row can have at most 3 flowers. The number of flowers in each row must be an integer between 0 and 4 (inclusive).	The number of flowers is a valid integer.	"(declare-const A Int)
(declare-const an Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 an) (<= an 10)))
(assert (distinct A an))
(check-sat)"
Satisfying a simple equation	Use <~{ to enforce an inequality, and <~~ to enforce equality.	"(assert true)
(check-sat)"
Satisfying the Chicken McNugget Theorem	The Chicken McNugget Theorem states that the sum of two relatively prime numbers has a unique representation as a linear combination of those two numbers. Prove this theorem using QF_UF and SMT-LIB.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use a switch statement to determine which color shirt to wear based on the day of the week.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has three fields of wheat: Field A, Field B, and Field C. Each field can hold either 0 or 1 units of wheat. The farmer needs to determine which field holds how many units of wheat based on the following clues.	Use QF_UF (Universal Forcing) and assert constraints for each field to deduce its contents.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A farmer has two fields, A and B. Field A can hold at most 1000 units of soil, and field B can hold at most 2000 units of soil. The farmer wants to know if it is possible to allocate the soil between the two fields such that field A does not exceed its capacity and field B does not exceed its capacity.	use QF_UF to add constraints on the number of units in each field, check-sat to verify the validity of the constraints	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Solve the following logic puzzle: There are three switches, but they are not labelled. Each switch corresponds to one of three light bulbs in a room. Each bulb is either on or off. You can turn the lights on and off as many times as you want, but you can only enter the room one time to observe the bulbs.	Use QF_UF to model the switches and their corresponding light bulbs. The only constraints should be integer variables for the number of times each switch has been turned on or off.	"(declare-const a Int)
(assert (and (<= 1 a) (<= a 3)))
(declare-const as Int)
(assert (and (<= 1 as) (<= as 3)))
(declare-const in Int)
(assert (and (<= 1 in) (<= in 3)))
(assert (distinct a as in))
(check-sat)"
The set of all perfect squares between 0 and 100	Use QF_UF to express that a number is either even or odd, then use the property (forall x (x = 0) -> (not (x^2))) to assert that there are no perfect squares less than 100.	"(assert true)
(check-sat)"
The Five Houses Problem	Use QF_UF and QF_LIA solvers to prove the following statement: There exists an integer x such that x^2 + x + 1 = 5x + 4 or (x == 0 and y == 2) or (x == 3 and y == 1)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
\u03c0\u202f\u2228\u221a\u203b\u2153\u2192\u2115\u20d1\u2164\u217e\u22cc\u2202\u2189\u2164\u223b\u2193\u214f\u2187\u212a\u215c\u2236\u219d\u2210\u2135\u2188\u217c\u2221\u218a\u216f\u220e\u2192\u211c\u2153	\u03b7\u2129\u20ac\u201d\u2060\u2035\u2130\u2211\u2148\u218a\u2164\u217e\u22cc\u2202\u218f\u2153\u219b\u222c\u2207\u2189\u207d\u2066\u2120\u20ac\u201d\u2035\u2130	"(declare-const u2115 Int)
(declare-const u2135 Int)
(assert (and (<= 1 u2115) (<= u2115 10)))
(assert (and (<= 1 u2135) (<= u2135 10)))
(assert (distinct u2115 u2135))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that two people are friends if and only if they have a mutual friend	Use QF_UF to prove the biconditional, and use set-logic to add the necessary constraints	"(declare-const a_friend_if Bool)
(declare-const if_friend_a Bool)
(assert (= a_friend_if if_friend_a))
(assert (= true a_friend_if))
(check-sat)"
(set-logic QF_UF   (declare-const x int)   (assert (not (= x 0)))   (check-sat)	The assertion will only be true if x is not equal to 0.	"(assert true)
(check-sat)"
Social inequality	Use QF_UF to model the relationship between income and education level, where higher income leads to higher education level.  (declare-const X (integer : LessThan 5))  (declare-const Y (integer : GreaterThan 0))  (assert (QF_UF (     X Y              <= 4 ? true : false) )	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given a social network with people of different ages, find all pairs of individuals who are friends.	To solve this problem, we can use QF_UF and check-sat constraints to derive the friendships between people. We can first list all possible pairs of individuals, then constrain each pair using simple integer or boolean constraints (e.g., `age(a, b) <= 18 && age(b, a)`), and finally check for satisfiability.	"(declare-const a_friend_of Bool)
(declare-const of_friend_a Bool)
(assert (= a_friend_of of_friend_a))
(assert (= true a_friend_of))
(check-sat)"
Prove that there exists an integer x such that x + 1 = 3 and x - 2 > 0	Use the QF_UF rule to combine x + 1 = 3 with x - 2 > 0 to get (x+1) - (x-2) = 5 > 0	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The given social constraint is inconsistent and cannot be satisfied by any assignment of integers or booleans.	A valid solution would require the existence of a finite set of integer values that can satisfy all constraints simultaneously.	"(declare-const be_of Bool)
(declare-const be_or Bool)
(declare-const by_of Bool)
(declare-const by_or Bool)
(declare-const is_of Bool)
(declare-const is_or Bool)
(assert (= (+
  (ite be_of 1 0)
  (ite by_of 1 0)
  (ite is_of 1 0)
) 1))
(assert (= (+
  (ite be_or 1 0)
  (ite by_or 1 0)
  (ite is_or 1 0)
) 1))
(assert (<= (+
  (ite be_of 1 0)
  (ite be_or 1 0)
) 1))
(assert (<= (+
  (ite by_of 1 0)
  (ite by_or 1 0)
) 1))
(assert (<= (+
  (ite is_of 1 0)
  (ite is_or 1 0)
) 1))
(check-sat)"
Prove that John and Mary are married	Use QF_LIA and assert the following equations to prove this statement, then check-sat.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Ensure that no two people in a friendship network have more than one connection to each other	"model  	 globeforall x y z:  		headgedd (x, y)  		and  		( x  eq z |  			not ( 			y, z)  	))"	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (= a_friend_in in_friend_a))
(assert (= true a_friend_in))
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 2x and x is less than or equal to 10	{'method': 'modelChecking'}	"(declare-const an Int)
(declare-const is Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct an is))
(check-sat)"
Prove that there exist two distinct integers x and y such that x + y = 5	Using QF_UF with constraints x >= 0, y <= 5, and x + y = 5, derive the existence of a solution.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that it is not possible to construct a directed acyclic graph (DAG) with more than 5 nodes and 10 edges.	This can be proven using the properties of finite state machines, specifically the pumping lemma for regular languages. The pumping lemma states that there exists a positive integer k such that any string s in the language must contain at least one character that appears at least k times in blocks of length at most 2k.	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Prove that there exists an integer x such that x^2 + 4 = 8 and x^2 - 3 < 0.	This problem can be solved using the QF_UF rule, which states that for any formula f(X) of type 'quantifier-free' with one free variable X, we have either f(X) or f(X). We will use this rule to derive a contradiction. First, we show that 3^2 - 4 = 5 and 3^2 + 4 > 8. Then, we can conclude that there exists an integer x such that x^2 < 0.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that 'John' is not equal to 'Alice'	Use QF_UF with set-logic and assert constraints.	"(declare-const is Int)
(declare-const to Int)
(assert (and (<= 1 is) (<= is 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct is to))
(check-sat)"
Prove that there exists an integer $x$ such that x^2 + 3x - 4 = 0	The quadratic equation has at least one real root according to the Fundamental Theorem of Algebra, and we can show this by attempting to solve it manually.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that there exists an integer x such that x > 0 and (x + 1) mod 3 = 2	Using the properties of modular arithmetic, we can derive that if x is positive, then (x + 1) mod 3 must be equal to 2. This implies that there exists a unique integer solution for x.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that John and Mary are married.	(set-logic QF_UF) (declare-const John mary : pair (string , string)) (assert (John mary) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that a person is not married to themselves.	(not (set-of-facts (set-of-constants 'x) (set-of-constants 'y)))	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Prove that for all integers n >= 2, (1 + n) mod 3 = 0.	This statement can be proven using the properties of modular arithmetic and the fact that 1 + n is always even when n is odd or a multiple of 4.	"(assert true)
(check-sat)"
Prove that there are at least two distinct social connections between individuals in a small community.	Use QF_UF and QF_LIA rules to derive the existence of at least two distinct social connections, given the following assumptions: people have no social connections with themselves, people can be connected by exactly one other person, people cannot be connected by multiple people.	"(declare-const a Int)
(declare-const at Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 at) (<= at 10)))
(assert (distinct a at))
(check-sat)"
Verify that the following relation holds: (x, y) <- (x, z) && (y, z)	Use QF_UF and QF_LIA rules to derive the implication.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that it is impossible to have two people who are friends with each other	{'description': 'Use QF_UF and set-logic to model this relationship.', 'smtlib': 'set-logic QF_UF\ndeclare-const Alice:Int\ndeclare-const Bob:Int'}	"(declare-const is_friend_it Bool)
(declare-const it_friend_is Bool)
(assert (= is_friend_it it_friend_is))
(assert (= true is_friend_it))
(check-sat)"
Given the following social network structure: [1, 2; 2, 3; 3, 4], define the minimum number of friendships required to satisfy all constraints.	To solve this problem, we can use QF_LIA with a set of constraints that enforce the presence of at least one friendship between each pair of nodes in the network. We can then check if the resulting model is satisfiable using check-sat.	"(declare-const of_friend_to Bool)
(declare-const to_friend_of Bool)
(assert (= of_friend_to to_friend_of))
(assert (= true of_friend_to))
(check-sat)"
Prove that any two people are connected in a social network	Use QF_UF and QF_LIA rules to reason about graph connectivity	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Verify that a social relationship graph is consistent.	{   (set-logic QF_UF)   (declare-const person1 person2 : FRIENDS)   (assert (forall (x person)         (           (person1 x)                        (person2 x))         (not (eq x x)))   )	"(declare-const a_friend_is Bool)
(declare-const is_friend_a Bool)
(assert (= a_friend_is is_friend_a))
(assert (= true a_friend_is))
(check-sat)"
Prove that two people are friends if and only if they share a common interest.	Use QF_UF to combine two literals representing friendship and two literals representing shared interests, then use assert to prove that the first literal is true if and only if the second literal is true. Finally, check-sat to verify that the system satisfiable.	"(declare-const a_friend_if Bool)
(declare-const if_friend_a Bool)
(assert (= a_friend_if if_friend_a))
(assert (= true a_friend_if))
(check-sat)"
Determine whether a person is married to their spouse	Use QF_LIA and (set-logic QF_UF) with valid constraints to prove that a person is not married to their spouse.	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Prove that there does not exist an integer x such that x^2 + 1 = 0	This statement can be proven using the QF_LIA theory, specifically by assuming x is an integer and then deriving a contradiction.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that if person A is friends with person B and person C, then person A and person C are connected by a friendship chain	Use QF_UF to represent friendships between people and QF_LIA to ensure the structure of the friendship graph is consistent.	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Determine if all people in a social network have at least one friend.	Use QF_UF and assert statements to model relationships between individuals, then use the check-sat solver to verify validity.	"(declare-const a_friend_at Bool)
(declare-const at_friend_a Bool)
(assert (= a_friend_at at_friend_a))
(assert (= true a_friend_at))
(check-sat)"
Prove that there exist two people in a social network such that they are friends and not spouses.	Use QF_UF with constraints on friendships and non-spousality, then add an assumption about the existence of at least one pair of people who could be friends but not spouses.	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (not a_friend_in))
(assert (not in_friend_a))
(check-sat)"
Prove that there does not exist an integer k such that k^2 + 5k - 6 = 0	(assert (integer s) (> 0 ? 1 : 2)) (assert (syms x k real) > 0) (assert (satisfies (e (univariate x) (- 6 x 6 k^2 + 5 k))) > 0) ((set-logic QF_UF) (declare-const s real)) ((check-sat))	"(declare-const an Int)
(declare-const k Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 k) (<= k 10)))
(assert (distinct an k))
(check-sat)"
Determine whether it is possible to construct a social network where all individuals are connected and no two individuals are friends	The graph of friendships can be represented as an undirected graph with weighted edges, where each edge has a weight representing the strength of the friendship. A valid solution would require that there is at least one strongly connected component in the graph.	"(declare-const a_friend_is Bool)
(declare-const is_friend_a Bool)
(assert (= a_friend_is is_friend_a))
(assert (= true a_friend_is))
(check-sat)"
Prove that if Alice is friends with Bob and Bob is friends with Charlie, then Alice is friends with Charlie	Use QF_UF with constraints that express the friendship relationships as valid integer solutions. Ensure the model is satisfiable by checking for consistency.	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (= if_friend_is is_friend_if))
(assert (= true if_friend_is))
(check-sat)"
Prove the following sentence is valid in QF_UF	Use the set-logic QF_UF and assert statements to derive the sentence.	"(declare-const in Int)
(declare-const is Int)
(assert (and (<= 1 in) (<= in 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct in is))
(check-sat)"
Given a person A with age 25 and friend B, prove that if A's friends are all friends of C then A is friends of B.	(declare-const A Person (0: 1) (declare-const B Person (0: 1) (declare-const C Person (0: 1))  (   (            (forall x (Person (x)) (         (set-of y (Set-of-z) z)))        ) )  (   (assert (or (A= B) (All-of-A-Friend-Of-B-C A C))))	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Prove that if person1 is friends with person2 and person3, then person4 is not friends with person5.	{'method': 'existential', 'variables': ['person1', 'person2', 'person3', 'person4', 'person5'], 'constraints': ['(set-logic QF_UF)\n\n', '(declare-const person1 person1)\n', '(declare-const person2 person2)\n', '(declare-const person3 person3)\n', '(assert (person1 <> person2))\n', '(assert (person1 <> person3))\n', '(assert (not (person4 <>) (person5 <)))']}	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (not if_friend_is))
(assert (not is_friend_if))
(check-sat)"
The relationship 'John Doe' and 'Jane Smith' are friends.	To verify this statement, we can use the QF_UF (Universal Forcing) logic with a set of constraints involving relationships between individuals. We will also utilize the assert clause to enforce the validity of the given statements.	"(declare-const X_friend_Y Bool)
(declare-const Y_friend_X Bool)
(assert (= X_friend_Y Y_friend_X))
(assert (= true X_friend_Y))
(check-sat)"
The given social network of friends has exactly 5 people.	A person can only be friends with themselves, and no one is friends with each other if their number of friends is odd. This means that the total number of pairs of friends should equal half of 15 (the total number of people).	
Prove that there exists an integer x such that x + 1 = 2x	Use the QF_UF and QF_LIA rules to derive the desired consequence.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that there are no cycles in the graph G = ({a, b, c}, R), where R is an undirected relation and 'a' and 'b' are related to each other, but not both.	Use QF_UF and set-logic to reason about the satisfiability of this graph. Assume X = {a, b} such that X  G. Prove by contradiction that there exists a path from a to c in G if and only if for all y  X, (y, x)  R.	"(declare-const G Int)
(declare-const R Int)
(assert (and (<= 1 G) (<= G 10)))
(assert (and (<= 1 R) (<= R 10)))
(assert (distinct G R))
(check-sat)"
Pigeonhole Principle	Given n pigeons and m pigeonholes, show that at least one pigeonhole must contain more than one pigeon.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The following social relationship constraint is valid: P(x, y) |= Q(x, z), where P, Q are predicates and x, y, z are atoms.	To prove the validity of this constraint, we need to show that it is satisfiable using a finite model.	"(declare-const P_friend_Q Bool)
(declare-const Q_friend_P Bool)
(assert (= P_friend_Q Q_friend_P))
(assert (= true P_friend_Q))
(check-sat)"
Verify that a social constraint involving two individuals and their relationships holds true	{'method': 'existential quantification'}	
Prove that all employees in the company are working	Using set-logic QF_UF and QF_LIA, derive the following implications: (set-of-people employee1 ... employee5) => (work(employee1, employee2), work(employee3, employee4), work(employee5, employee6))	"(assert true)
(check-sat)"
Prove that John and Mary are married	(set-logic QF_UF) (declare-const John mary : bool) (assert (== John mary)) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that if person1 is friends with person2, and person2 is friends with person3, then person1 is friends with person3.	Use the transitive property of friendship to prove this implication.	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (= if_friend_is is_friend_if))
(assert (= true if_friend_is))
(check-sat)"
Prove that a person is either in their hometown or not.	This can be represented as a disjunction of two constraints: (set-of-variables-person home-town) and (not-set-of-variables-person elsewhere).	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Find all pairs of people in a social network where one person is friends with another.	Use QF_UF to model friendship relationships and check-sat to solve the problem	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (not a_friend_in))
(assert (not in_friend_a))
(check-sat)"
Prove that any person is either a student or an employee of the same company.	{   (set-logic QF_UF)   (declare-const C (Symbol('Company'))   (declare-const S (Symbol('Student'))   (declare-const E (Symbol('Employee'))   (assert (not (or (= C S) (= C E))))   (assert (not (and (= S C) (= E C)))   (assert (not (or (= S E) (= C E)))))   (check-sat) }	"(declare-const a Int)
(declare-const an Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 an) (<= an 10)))
(assert (distinct a an))
(check-sat)"
Prove that a person is either married to their spouse or not married at all	Use QF_UF and assert variables for marriage status, then check-sat	"(declare-const a Int)
(declare-const at Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 at) (<= at 10)))
(assert (distinct a at))
(check-sat)"
Prove that John and Mary have different favorite sports.	Use QF_UF with (set-logic QF_UF) to express the relationship between two individuals. Then, use (assert ...) to assert a specific property about their preferences. Finally, check-sat to prove this property holds true.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that John and Alice are friends.	(john = alice) -> (friend john alicia)	"(declare-const X_friend_Y Bool)
(declare-const Y_friend_X Bool)
(assert (= X_friend_Y Y_friend_X))
(assert (= true X_friend_Y))
(check-sat)"
A university has two social constraints regarding friendships between students.	These constraints can be represented using QF_UF and QF_LIA axioms.	
Prove that a person is either in the US or has a valid US driver's license.	Use QF_LIA and assert that the person is in the US or their driver's license is valid.	"(declare-const US Int)
(declare-const a Int)
(assert (and (<= 1 US) (<= US 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct US a))
(check-sat)"
Prove that every person has at least one friend	Use QF_LIA and QF_UF to model the friendship relationship between people	"(declare-const at_friend_has Bool)
(declare-const has_friend_at Bool)
(assert (= at_friend_has has_friend_at))
(assert (= true at_friend_has))
(check-sat)"
Satisfies QF_UF rule with a valid JSON payload	"{'solver': 'CPVEX', 'input': '{""solution"": ""1"", ""constraints"": [""x + y = 2""]}', 'expected_solution': '[0, 3]'}"	"(assert true)
(check-sat)"
The social network has a relationship between John and Alice, but they are not friends.	{'constraints': ['(set-logic QF_UF)\n', '(declare-const person1 person2)\n', '(assert (not (person1 = person2)))\n', '(check-sat)']}	
\(set-logic QF_UF\) \(declare-const x = 5\) \(assert \((\u'== 4\)\))	This proof uses QF_UF to prove a simple equality and QF_LIA to derive the truth of the assertion.	"(declare-const u Int)
(declare-const x Int)
(assert (and (<= 1 u) (<= u 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct u x))
(check-sat)"
The relationship between person A and person B is that they are friends.	This can be expressed as (set-logic QF_UF)      (declare-const personA personA   declare-const personB personB   assert (personA == personB))   (assert (not (personA != personB)))	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
\(set-of\(\{x| x #= 1\} \) && \(set-of\(\{y| y #!= 2 && !x || y #<= 3\} \))\)	\(declare-const x 1; \(declare-const y 2; \(assert (xor (and (not (eq x 1) (neq x 2)) (not (eq x 1) (lt x 3))) (and (neq x 1) (gt x 3)));\)	"(declare-const of Int)
(declare-const x Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct of x))
(check-sat)"
Prove that there exists an integer x such that 2*x + 3 >= 5 and x^2 <= 4	Use QF_UF to model the system of linear inequalities: 2x + 3 >= 5 --> 2x >= 2 --> x >= 1; x^2 <= 4 --> x <= -2	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that for all integers x and y, if x > y then x + y = 2y	Using QF_UF with the set of integers and the implication rule, derive the following:   (declare-const x Int) (declare-const y Int) (assert (x > y)) (check-sat)	"(declare-const if Int)
(declare-const x Int)
(assert (and (<= 1 if) (<= if 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct if x))
(check-sat)"
{'solver': 'QF_UB', 'reasoning': '(set-logic QF_LIA (declare-const x 0: INTEGER) (assert (>= x 1)) (check-sat))'}	(assert (>= 2 3)) (check-sat)	"(assert true)
(check-sat)"
Prove that if Alice and Bob are friends, then Carol is also friends with both of them.	(set-logic QF_UF)                (declare-const alice friend bob)     (assert (not (friend bob alice)))     (declare-const carol friend alicebob)     (assert (and (friend alicebob carol) (friend alice carol)))	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (= if_friend_is is_friend_if))
(assert (= true if_friend_is))
(check-sat)"
Prove that there are no friends among five people.	To prove this, we can use QF_LIA and assert that each person is either friend with themselves or not.	
A person is either married to their spouse or in a consensual relationship with someone else.	This property can be expressed using QF_UF (Unions of First-Order) and constraints such as <person> marry <other_person>	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
Verify that there are no social connections between all individuals in a network of 10 people with no mutual friends	Use QF_UF to model the relationship as a graph, and then use QF_LIA to check if the graph is acyclic. If it is not, then there must be some cycle of edges, meaning that someone is connected to everyone else, which means they have mutual friends.	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (= a_friend_in in_friend_a))
(assert (= true a_friend_in))
(check-sat)"
(set-logic QF_UF (declare-const x y z (integer :pred <)) (assert (not (= x 5))) (check-sat)	(check-sat)	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that there exist distinct integers x, y such that x + y = 3 and x  y	Using QF_UF and the constraints x + y = 3 and x  y, derive a contradiction if neither x nor y is equal to zero.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that a person who has friends with people they know personally and strangers, but does not have acquaintances outside of their social circle, cannot be a friend to any one specific stranger.	Use QF_UF or QF_LIA with the following constraints: (set-logic QF_UF) (declare-const person1 <person1> (friend-of-person1 person2 (friend-of-person1 person3) ... (not acquaintances person4 person5))) (assert (for-all x (forall y (not friend-of-person1 y x))) (not (in-a-social-circle x)))	"(declare-const a_friend_be Bool)
(declare-const be_friend_a Bool)
(assert (not a_friend_be))
(assert (not be_friend_a))
(check-sat)"
Prove that there exist non-empty sets A and B of people such that A  B = 	"The following set constraints ensure the existence of such sets:  - A (A  X)   	B (B  A);"	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
Social Network Problem	The following friendship relationships hold: (Alice, Bob), (Bob, Charlie), (Charlie, Alice). Find the maximum number of friends each person can have.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given two people A and B, where person A is related to person B by marriage if A's age is greater than B's age.	Use QF_UF or QF_LIA with set-logic to express the relationship between ages of individuals for any positive integers n and m (where n <= m).	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
Prove that if person A has degree 3 and person B has degree 4, then person A's age is greater than or equal to person B's age	This implication can be proved using QF_UF or QF_LIA.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
Prove that there exists an integer x such that x^2 = 5 and x^4 + 2x^2 - 1	Use QF_UF to reason about the existence of a solution and then use QLIA to solve for x.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that two people are acquaintances if they have met at least once	(set-logic QF_UF) (declare-const person1 :: int) (declare-const person2 :: int) (assert (person1 = person2)) (check-sat)	"(declare-const at Int)
(declare-const if Int)
(assert (and (<= 1 at) (<= at 10)))
(assert (and (<= 1 if) (<= if 10)))
(assert (distinct at if))
(check-sat)"
Given the social network of individuals with attributes 'name' and 'relationship_type', find the maximum number of people who are directly related to each other.	This can be solved using QF_UF or QF_LIA, where we express a relationship between two individuals as an equivalence relation. We then use the fact that the size of an equivalence relation is equal to the number of pairs of distinct elements in the set. This allows us to compute the maximum number of people who are directly related to each other.	"(declare-const of_friend_to Bool)
(declare-const to_friend_of Bool)
(assert (= of_friend_to to_friend_of))
(assert (= true of_friend_to))
(check-sat)"
Prove that there exists an integer x such that x + 1 = 2 * x	Use QF_UF and set-logic to prove the statement	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that a person can go to exactly two different cities if they travel between cities in different countries.	Using the QF_UF model with a set of cities and countries, prove that the person's travel history is consistent.	"(declare-const a Int)
(declare-const can Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 can) (<= can 10)))
(assert (distinct a can))
(check-sat)"
Prove that a person is either married or single.	(set-of-values x:Person; (set-of-assertions x:-single | x:-married))	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Use QF_LIA to express the relationship between friends and their relationships with others.	Use QF_UF with a set of 'not' constraints to express the relationship between individuals.	
Find all triples (a, b, c) where a has degree 2 in graph G and b is adjacent to both a and c	Use QF_LIA constraints to enforce the properties of the relationships.	"(declare-const G Int)
(declare-const a Int)
(assert (and (<= 1 G) (<= G 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct G a))
(check-sat)"
Find all pairs of distinct people in a university with exactly one common friend.	Use QF_UF to model this relationship and QLIA to restrict the number of friends each person can have.	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (= a_friend_in in_friend_a))
(assert (= true a_friend_in))
(check-sat)"
The set of all prime numbers less than or equal to 100	{(set-logic QF_UF) {(declare-const P UU)   assert (forall (x UU) ( eg ((xor x P) (xor P x))))	"(declare-const of Int)
(declare-const or Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 or) (<= or 10)))
(assert (distinct of or))
(check-sat)"
The given social relationship is valid.	Use QF_UF and set-logic QF_UF to ensure validity of constraints.	
Prove that every person is related to themselves.	Use QF_UF to assert that each person is connected to at least one other person, and then use QF_LIA to conclude that there are no cycles in the graph.	"(declare-const is Int)
(declare-const to Int)
(assert (and (<= 1 is) (<= is 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct is to))
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 0	Use QF_UF and set-logic to reason about the existence of solutions to this equation.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that if person A is friends with person B, and person B is friends with person C, then person A is friends with person C	Use QF_UF and QF_LIA constraints to derive the desired implication. Use the following assumptions: (A,B) and (B,C), and (C,A).	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Prove that for all integers n >= 5, n^2 + n - 13 > 0	The following statements are true:  - set-logic QF_UF - set-logic QF_LIA - declare-const n_ int - declare-variable x int - assert (x = 5) - assert (x^2 + x - 13 > 0)	"(assert true)
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 4x and 2x > 0	Using QF_UF with the set of variables {x} and the constraints from the problem statement, we can derive the following expression: 2 * (x^2 - 4) = 0. Solving for x, we get x = 16. Therefore, there exists an integer solution to the equation.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The friends of Alice are married, but Bob is not	To ensure this is true, we need to assert that (set-of-people x y) != (set-of-people x z)	"(declare-const is_friend_of Bool)
(declare-const of_friend_is Bool)
(assert (not is_friend_of))
(assert (not of_friend_is))
(check-sat)"
Prove that there exists an integer x such that x^2 + 4x - 3 = 0	To prove this equation has a solution, we can use the fact that it is a quadratic equation with two roots. We can also use the method of completing the square to simplify the equation.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that a person is not a friend of themselves	Use   to separate the reasoning into two parts: first, prove that an individual is friends with another if they have at least one movie in common, and second, prove the converse	"(declare-const a_friend_is Bool)
(declare-const is_friend_a Bool)
(assert (not a_friend_is))
(assert (not is_friend_a))
(check-sat)"
Prove that there exists an integer x such that 2*x + 3 >= 0	To prove this, we can use the QF_UF logic with 2*u + 3 <= -u for u >= 0. This is because for any non-negative integer u, 2*u + 3 will always be greater than or equal to 1, satisfying the condition.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The following social constraint is invalid: \nIt states that Alice and Bob are friends when they do not have a mutual friend, which is a contradiction.	\nTo resolve this conflict, we can add constraints to ensure that if Alice is friends with X, then X must also be friends with Alice. This can be achieved using the following QF_UF clause: (\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n)	"(declare-const a_friend_do Bool)
(declare-const do_friend_a Bool)
(assert (not a_friend_do))
(assert (not do_friend_a))
(check-sat)"
Prove that there does not exist an ordered pair of integers (x, y) such that x = 2 and y = 4	This statement can be proven using the QF_UF rule and the fact that x cannot be both even and odd.	"(declare-const an Int)
(declare-const of Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct an of))
(check-sat)"
Prove that there exists an integer x such that x + 1 = 2*x	"\begin{align*} (\exists x (\forall y (y < x \ 2*y == x+y))) &
ightarrow ((\exists z (z >= 0 \ z != -1)))) \end{align*}"	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Satisfying the social constraint: No two people in the same group.	Use QF_UF or QF_LIA to ensure that each person is in a unique set of groups.	"(declare-const No Int)
(declare-const in Int)
(assert (and (<= 1 No) (<= No 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct No in))
(check-sat)"
Prove that there exists an integer x such that 2x + 1 > 0	To prove this, we can use the QF_LIA solver with the following constraints: (set-logic QF_UF) (declare-const x Int) (assert (>= 0 (1 + 2 * x)))	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
A university has two classes: History and English.	The class that starts later must be the one with more students	"(declare-const A Int)
(assert (and (<= 1 A) (<= A 3)))
(check-sat)"
Prove that if Alice and Bob both have a pet cat, then they are friends.	\begin{qf uf} \setof(x:person) (x ~ x.pet.cat) & (x ~ y.pet.cat) \declare-relation(p,q:friend)(p.y ~ q.y) \check-sat	"(declare-const a_friend_if Bool)
(declare-const if_friend_a Bool)
(assert (= a_friend_if if_friend_a))
(assert (= true a_friend_if))
(check-sat)"
PREDicates and Atomic Variables: Prove that there exists an integer x such that x^2 = 0	The solution to this problem can be proven using QF_UF, given the constraints (set-logic QF_UF) and (declare-const x :: int). The key insight is to recognize that if there does not exist an integer x such that x^2 = 0, then we must have a contradiction. This would mean that either x or x+1 cannot be zero, which implies that x is not an integer, leading to a contradiction.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	Use QF_UF and QF_LIA axioms to prove that a valid schedule can be constructed from a given set of jobs with different durations.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the linear programming relaxation of the knapsack problem	Using QF_UF with an interval representation to solve this linear program	"(assert true)
(check-sat)"
Scheduling Problem	Integer linear programming to optimize task allocation on a machine with multiple processing units.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	# Use QF_UF and QF_LIA rules with simple integer constraints to model the scheduling problem. The SMT-LIB program should include the following constraints: # A must be executed by processor C1 P_A <= P_C1 * 2; # Assign tasks to processors based on their capabilities # B must be executed by processor C2 P_B <= P_C2 * 3; # Assign tasks to processors based on their capabilities # Check if the assignment satisfies all constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfies the linear programming relaxation of the flow network of scheduling problem with three nodes and four edges, where each edge has two capacities.	This problem can be solved using the flow network solver of SMT-LIB.	"(assert true)
(check-sat)"
Scheduling Problem	Construct a scheduling problem with two tasks that cannot be scheduled together.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling: max-work-hours	assert (set-logic QF_UF) and (declare-const hours 1: integer) and (declare-const total_hours 0: integer) and (assert (=, total_hours, sumhours(hours))) and (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA with simple integer and boolean constraints to model a scheduling algorithm that assigns jobs to machines based on their processing time and machine capacity.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF with integer variables	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF to solve this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
\(\setoflucore uf) \+ (\declareconst i32 x 10)	\(\checksat (\assert true) \| (\checksat false))	"(declare-const i32 Int)
(declare-const uf Int)
(assert (and (<= 1 i32) (<= i32 10)))
(assert (and (<= 1 uf) (<= uf 10)))
(assert (distinct i32 uf))
(check-sat)"
Scheduling Problem	Use QF_UF to model scheduling as a maximization problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
{'type': 'scheduling', 'domain': 'transportation'}	{'type': 'explanation', 'domain': 'scheduling'}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Check if this scheduling problem is solvable in practice.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a scheduling problem	{'approach': 'brute-force', 'search': 'depth-first'}	"(assert true)
(check-sat)"
\(declare-const x 0: Int\); (set-logic QF_UF)\n(declare-const y 1: Boolean; (assert \(x = true; \))\n(check-sat)	Using the properties of equality and union to derive new constraints	"(declare-const n Int)
(declare-const x Int)
(assert (and (<= 1 n) (<= n 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct n x))
(check-sat)"
Scheduling Problem	Use QF_LIA and set-logic QF_UF to generate constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling problem to minimize make times and meet deadlines	Use QF_UF and QF_LIA rules to analyze constraints on machine times and resource utilization.	"(assert true)
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to enforce valid scheduling rules	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF with linear constraints to model a scheduling problem where tasks are assigned to time slots and their start times must be within a certain range.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to model the scheduling of tasks on a shared resource.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA SMT-LIB rules to derive a valid scheduling plan.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to generate valid constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Minimize Latency	Use QF_LIA and set-logic QF_UF to ensure validity and correctness.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find an assignment that satisfies all constraints	Using QF_UF and QF_LIA, derive valid integer constraints to satisfy the scheduling problem.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_LIA to reason about scheduling constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Maximize the number of customers served while minimizing idle time	Use QF_UF and QF_LIA rules to model the scheduling problem, including constraints on customer arrival and departure times, as well as idle time.	"(assert true)
(check-sat)"
Scheduling Problem: Find an optimal assignment of jobs to machines in a factory	Use QF_UF and QF_LIA rules to solve this scheduling problem, ensuring that all constraints are satisfied exactly.	"(declare-const a_of Bool)
(declare-const a_to Bool)
(declare-const an_of Bool)
(declare-const an_to Bool)
(declare-const in_of Bool)
(declare-const in_to Bool)
(assert (= (+
  (ite a_of 1 0)
  (ite an_of 1 0)
  (ite in_of 1 0)
) 1))
(assert (= (+
  (ite a_to 1 0)
  (ite an_to 1 0)
  (ite in_to 1 0)
) 1))
(assert (<= (+
  (ite a_of 1 0)
  (ite a_to 1 0)
) 1))
(assert (<= (+
  (ite an_of 1 0)
  (ite an_to 1 0)
) 1))
(assert (<= (+
  (ite in_of 1 0)
  (ite in_to 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to solve the scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
(set-logic QF_UF  (declare-const x int)  (declare-const y int)  (assert (>= x 0)    (<= y 10) )	This is a problem that will be solved using SMT-LIB.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Scheduling Problem	Formally specify scheduling constraints using QF_UF and QF_LIA.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the parity of three signals in a 3D system	Use QF_UF with equality constraints and set-logic QF_LIA to enforce non-increasing order.	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Satisfy the following scheduling constraint: Minimize make_time(1, 2) + make_time(3, 4)	Use QF_UF and QF_LIA constraints to ensure that make_time(1, 2) <= make_time(3, 4).	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to prove the satisfiability of the scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA clauses to model the scheduling of tasks on a single processor.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a scheduling conflict on multiple servers	Using QF_UF and QF_LIA to ensure tight coupling between tasks and servers, while respecting resource constraints.	"(declare-const a Int)
(declare-const on Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 on) (<= on 10)))
(assert (distinct a on))
(check-sat)"
Scheduling Problem: Resource Allocation	Use QF_UF and QF_LIA constraints to model resource allocation in a scheduling problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF to define sets of variables and use QF_LIA to check consistency.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Maximize Productivity with Limited Time	This problem can be solved using QF_UF and QF_LIA constraints to ensure that the production of products does not exceed the available time.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	{'constraints': ['(set-logic QF_UF)', '(declare-const X 1)', '(declare-const Y 2)', '(assert (<= X 10))'], 'clauses': ['(check-sat)']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling problem with no conflicts	Use QF_LIA to model this scheduling problem without conflicts.	"(assert true)
(check-sat)"
Scheduling Problem	This problem uses QF_UF and QF_LIA formulas to model a real-time system.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and check-sat to prove the validity of the program, which asserts that there exists an integer solution to the scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	{'constraint_type': 'integer_lower_bound', 'variables': ['x', 'y'], 'constraints': ['(set-logic QF_UF)', '(declare-const x int)', '(declare-const y int)', '(assert (>= x 0))', '(assert (<= y 10))']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Integer Constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the following linear programming relaxation of the 8-hour workday problem with additional constraints	Using QF_UF and QF_LIA, derive the solution to a system of linear equations representing the 8-hour workday problem, where employees are only allowed to work up to 40 hours per week.	"(assert true)
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to prove validity	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Maximize Customer Satisfaction	Use QF_UF or QF_LIA to generate a valid model and check its satisfiability.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Formulate a valid schedule that satisfies all constraints and meets the deadline.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	{'type': 'clausal', 'constraints': ['(set-logic QF_UF)', '(declare-const x Int)', '(declare-const y Bool)', '(assert (not (= x 0)))']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to model this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Find all valid solutions to the following system of linear equations with two variables.	Use QF_LIA and integer constraints to solve this system.	"(declare-const of Int)
(declare-const to Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct of to))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to ensure valid constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling: maximize {x, y} where x is the number of customers served in the first hour and y is the number of customers served in the last hour	The goal is to maximize the total number of customers served within a fixed time frame. This can be achieved by prioritizing customers based on their arrival times.	"(declare-const in Int)
(declare-const is Int)
(assert (and (<= 1 in) (<= in 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct in is))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA constraints to model a scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	To solve the scheduling problem, we need to find an assignment of tasks to machines that satisfies all constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find the optimal assignment of tasks to machines	Use QF_UF and QF_LIA constraints to enforce valid scheduling rules, and check for satisfiability using QBF or DPLL-SAT.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA to represent the scheduling problem as a logic formula	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA solvers to reason about valid schedules.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following scheduling constraint using QF_UF and basic arithmetic constraints.	Use the following set of rules to derive the solution: (set-logic QF_UF) (declare-const X < 10) (assert X > 0) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA constraints to ensure fairness in resource allocation.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given a set of jobs with deadlines and resource requirements, determine the optimal assignment of jobs to machines without violating any deadlines or resource constraints.	Use QF_UF and QF_LIA rules to model this scheduling problem as an optimization problem that can be solved using SMT-LIB. Include assertions for machine availability and job deadlines.	"(declare-const a_to Bool)
(declare-const of_to Bool)
(declare-const or_to Bool)
(assert (= (+
  (ite a_to 1 0)
  (ite of_to 1 0)
  (ite or_to 1 0)
) 1))
(assert (<= (+
  (ite a_to 1 0)
) 1))
(assert (<= (+
  (ite of_to 1 0)
) 1))
(assert (<= (+
  (ite or_to 1 0)
) 1))
(check-sat)"
Scheduling Problem: Minimize Makespan	Given a set of tasks with start times and durations, find the order that minimizes the total makespan.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying an integer linear equation	(= (int x) ( (1 + 2)  = 3))	"(assert true)
(check-sat)"
scheduling_problem	derive_satisfiability_from_just_the_constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	(set-logic QF_UF)  define-variables   x: integer   y: boolean,   z: real  (assert (not (= x 0))) (assert (not (= y true))) (assert (= z 1.5))	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find the minimum number of machines required to schedule tasks with maximum utilization	This problem can be solved using First-Order Logic (FOL) constraints in SMT-LIB. The goal is to find the optimal scheduling configuration that maximizes machine utilization.	"(declare-const of Int)
(assert (and (<= 1 of) (<= of 3)))
(declare-const to Int)
(assert (and (<= 1 to) (<= to 3)))
(assert (distinct of to))
(check-sat)"
Scheduling Problem	{'type': 'Propositional Reasoning', 'reason': 'Using QF_UF with integer constraints and checking satisfiability'}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	Use QF_UF with set of variables and universal quantification to model a scheduling problem where tasks have start and end times.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Generate an exact solution for the following linear programming relaxation of the 5-hour delivery problem	Use QF_UF and QF_LIA constraints to model integer variables representing hours worked by drivers, and use assert statements to enforce non-negativity.	"(declare-const an Int)
(declare-const of Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct an of))
(check-sat)"
\(set-logic QF_UF \n\n(declare-const X true \n  \n  (assert Y = 1) \n  (assert Z < 5))\n	This is a valid SMT-LIB program that includes the necessary logic for model checking and satisfiability.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find optimal assignment of tasks to machines	Use QF_UF and QF_LIA solvers with simple constraints, e.g., (set-logic QF_UF)   (declare-const machine <1..4>   (declare-const task <1..5>))   (assert (>= 0 (size of task)))	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to prove that it is NP-complete.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA to enforce valid scheduling constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA to model the scheduling problem	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find the optimal assignment of tasks to machines	Use QF_UF and QF_LIA constraints to reason about machine resource allocation.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to enforce precedence constraints on tasks	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF to model the scheduling of tasks with deadlines and resource constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA constraints to model this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Determine if it is possible to assign all tasks to employees within a given time frame.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to model scheduling problems.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF with valid constraints to solve this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a scheduling constraint	Use QF_UF and QF_LIA constraints to model the problem	"(assert true)
(check-sat)"
Modeling scheduling conflicts in a production line	\n\n\n(\n  \n    \n    (\n      \n      \n      \n      \n      \n      \n      \n    ),\n\n  \n\n  (\n    \n    (\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    )\n\n  \n)	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Scheduling Problem	Using QF_UF and QF_LIA rules to reason about scheduling constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	This problem requires the use of QF_UF and QF_LIA rules to reason about scheduling constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Using QF_UF and set-logic to model scheduling problems with multiple tasks and resource constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	Use QF_UF rules to model the scheduling of tasks with dependencies.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following integer linear program: P = { x, y | x + y <= 5, x >= 0, y >= 0 }	Use QF_UF and QF_LIA constraints to ensure satisfiability, then check for valid solutions.	"(declare-const P Int)
(declare-const x Int)
(assert (and (<= 1 P) (<= P 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct P x))
(check-sat)"
Scheduling Problem: Given two tasks t1 and t2, assign task t1 to machine M1 and task t2 to machine M2 if both machines are not busy	Propositional Reasoner	"(declare-const M1_t1 Bool)
(declare-const M1_t2 Bool)
(declare-const M2_t1 Bool)
(declare-const M2_t2 Bool)
(declare-const if_t1 Bool)
(declare-const if_t2 Bool)
(assert (= (+
  (ite M1_t1 1 0)
  (ite M2_t1 1 0)
  (ite if_t1 1 0)
) 1))
(assert (= (+
  (ite M1_t2 1 0)
  (ite M2_t2 1 0)
  (ite if_t2 1 0)
) 1))
(assert (<= (+
  (ite M1_t1 1 0)
  (ite M1_t2 1 0)
) 1))
(assert (<= (+
  (ite M2_t1 1 0)
  (ite M2_t2 1 0)
) 1))
(assert (<= (+
  (ite if_t1 1 0)
  (ite if_t2 1 0)
) 1))
(check-sat)"
scheduling:make-schedule	show that it is impossible to schedule two tasks with different start times and one task can be delayed by any amount of time without violating the constraints.	"(declare-const X Int)
(assert (and (<= 1 X) (<= X 3)))
(declare-const Y Int)
(assert (and (<= 1 Y) (<= Y 3)))
(declare-const Z Int)
(assert (and (<= 1 Z) (<= Z 3)))
(assert (distinct X Y Z))
(check-sat)"
{'solver': 'smt2', 'input': '\\{(\\x0 \\y -5) + (\\z + 10) <= 15; \\x1 = (\\x3 + 2) * (\\x4 - 3); \\z = 12; \\v = true; \\w = false;\\n\\(\\x0 < 0 \\n\\n(\\y - 5) * (\\z + 10) <= 15 \\n\\n(\\x1 = (\\x3 + 2) * (\\x4 - 3))\\n\\n(check-sat)'}	{'solver': 'smt2', 'input': '\\{(\\x0 \\y -5) + (\\z + 10) <= 15; \\x1 = (\\x3 + 2) * (\\x4 - 3); \\z = 12; \\v = true; \\w = false;\\n\\(\\x0 < 0 \\n\\n(\\y - 5) * (\\z + 10) <= 15 \\n\\n(\\x1 = (\\x3 + 2) * (\\x4 - 3))\\n\\n(check-sat)'}	"(declare-const n Int)
(declare-const v Int)
(assert (and (<= 1 n) (<= n 10)))
(assert (and (<= 1 v) (<= v 10)))
(assert (distinct n v))
(check-sat)"
Satisfying the constraint that all tasks in a scheduling problem have at least one feasible solution	Use QF_UF and QF_LIA axioms to ensure feasibility, then use modus ponens and contradiction elimination to prove satisfiability.	"(declare-const a Int)
(declare-const at Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 at) (<= at 10)))
(assert (distinct a at))
(check-sat)"
Scheduling Problem: Find the optimal assignment of tasks to machines in a factory	Use QF_UF or QF_LIA constraints and simple integer or boolean constraints to model the problem.	"(declare-const a_to Bool)
(declare-const in_to Bool)
(declare-const of_to Bool)
(assert (= (+
  (ite a_to 1 0)
  (ite in_to 1 0)
  (ite of_to 1 0)
) 1))
(assert (<= (+
  (ite a_to 1 0)
) 1))
(assert (<= (+
  (ite in_to 1 0)
) 1))
(assert (<= (+
  (ite of_to 1 0)
) 1))
(check-sat)"
Satisfy the following system of linear equations with two variables x and y	Use the QF_UF rule to introduce new variables, then use QF_LIA to eliminate them, and finally assert the truth of the resulting equation.	"(declare-const of Int)
(declare-const x Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct of x))
(check-sat)"
Satisfy the constraints of a finite automaton	Use QF_UF and QF_LIA rules to express the constraints of the automaton	"(declare-const a Int)
(declare-const of Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct a of))
(check-sat)"
Satisfy the following linear equations using QF_UF and QF_LIA rules	Use simple integer constraints to represent the relationships between variables.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following constraint using QF_UF and QF_LIA	Use simple integer constraints and   newlines to separate logical statements	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Using QF_UF and QF_LIA rules to derive a valid scheduling plan from a set of constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Resource Allocation Problem	Use QF_UF to model the allocation of resources.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation: Assigning Resources to Tasks	{'variables': ['x', 'y'], 'constraints': ['(set-logic QF_UF)', '(declare-const x Integer)', '(declare-const y Boolean)', '(assert x >= 0)'], 'solver': 'SMT-LIB'}	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA axioms to model this problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Prove that there exists an integer x such that x = 1 and (x + 2) mod 3 = 0	Using the properties of modular arithmetic, we can show that this equation is true for all values of x.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Resource Allocation	Use QF_UF or QF_LIA with simple integer and boolean constraints to solve a resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to ensure valid integer solutions.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
{'name': 'Resource Allocation', 'description': 'A resource allocation problem in a cloud computing environment'}	Using QF_UF and set-logic, we can model this problem as follows:  set-logic QF_UF; assert (declare-const x:integer >= 0); assert (declare-const y:integer > 0); check-sat;	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation: Minimize Number of Server Assignments	(set-logic QF_UF) (declare-const x : integer) (assert (x > 0)) (check-sat)	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF to enforce unit-of-formula equality	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: 3 resources available, 4 requests to allocate	Use QF_UF and QF_LIA constraints to ensure integer solutions are found	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF logic to model this resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA solvers to find an optimal assignment of resources to tasks.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model a resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to define a set of constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	To allocate resources to tasks, we need to minimize waste and maximize efficiency.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use of QF_UF or QF_LIA constraints to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA formulas to model this resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
(set-logic QF_UF (declare-const x int : 1) (assert (equivalent? (add 2 x) (add 5 x)))	Using the properties of arithmetic operations and addition, we can deduce that if (add 2 x) = (add 5 x), then (add 3 x) must be true.	"(assert true)
(check-sat)"
Resource allocation problem	Satisfiability Reasoning and Computation System	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to processes	Using QF_UF and QF_LIA, derive that there exists a valid assignment of resources to each process such that the total resource usage is non-negative.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to ensure fairness in resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: 5 machines, 3 software licenses	Using QF_UF with constraints on machine availability and license usage.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA to model resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to reason about resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to processes	Use QF_UF and QF_LIA constraints to model resource allocation, considering bounds on resources and process demands.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Using QF_UF with set-logic and declare-const constraints to model the allocation of resources between two processes.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation	Using QF_UF with linear constraints to optimize resource usage.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Allocate resources to tasks with minimum latency	{'variables': [{'name': 'latency', 'type': 'int'}], 'assumptions': ['(set-logic QF_UF)', '(declare-const task1-latency 10)', '(declare-const task2-latency 5)'], 'conclusions': ['(assert (leq task1-latency task2-latency 5))']}	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA logical frameworks to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
{'name': 'Resource Allocation', 'description': 'A problem of resource allocation in a computer system', 'satisfiability': False}	{'rule1': '(set-logic QF_UF)', 'rule2': '(declare-const x integer)', 'rule3': '(declare-const y boolean)'}	"(declare-const A_of Bool)
(declare-const a_of Bool)
(declare-const in_of Bool)
(assert (= (+
  (ite A_of 1 0)
  (ite a_of 1 0)
  (ite in_of 1 0)
) 1))
(assert (<= (+
  (ite A_of 1 0)
) 1))
(assert (<= (+
  (ite a_of 1 0)
) 1))
(assert (<= (+
  (ite in_of 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Using QF_UF and set-logic to model resource allocation problem	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
(set-logic QF_UF (declare-const x y Z)	This is a valid program, and it will always find a solution.	"(declare-const Z Int)
(declare-const x Int)
(assert (and (<= 1 Z) (<= Z 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct Z x))
(check-sat)"
Resource allocation: Assigning resources to tasks	Use QF_UF and QF_LIA rules to reason about resource availability	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation	Use QF_UF or QF_LIA to specify the resource constraints and then assert them using set-logic.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to model resource allocation problems, ensuring that resources are allocated in an optimal manner.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF to find valid assignments that satisfy all constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Using QF_UF with set of variables and assertions to solve a resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
\(set-logic QF_UF\) \(declare-const x_0 bool\) \(assert (x_0 = true)\)	\(check-sat\)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to model resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA constraints to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA solvers to find an optimal assignment of resources.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA axioms to reason about resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA quantifiers to model the problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to tasks	Use QF_UF and QF_LIA rules to constrain resource allocation.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation: Minimize the number of machines used in the data center	Use QF_UF and QF_LIA to model this problem, and ensure that it includes  - (set-logic QF_UF) or QF_LIA. Use simple integer constraints for machine utilization.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation: Assigning resources to tasks	Using QF_UF and QF_LIA constraints to ensure fairness in resource allocation, while also ensuring that the system is satisfiable.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Prove that it is possible to allocate resources such that all devices are used and no device is idle	(set-logic QF_UF) # Define the universe of discourse as integers from 0 to N-1 (where N is the number of devices)  (set-logic QF_UF)(declare-const N: int)  (assert (>= N 2))  (check-sat)	"(declare-const is_to Bool)
(declare-const it_to Bool)
(declare-const no_to Bool)
(assert (= (+
  (ite is_to 1 0)
  (ite it_to 1 0)
  (ite no_to 1 0)
) 1))
(assert (<= (+
  (ite is_to 1 0)
) 1))
(assert (<= (+
  (ite it_to 1 0)
) 1))
(assert (<= (+
  (ite no_to 1 0)
) 1))
(check-sat)"
Resource Allocation: Assigning Resources to Jobs	Use QF_UF and QF_LIA constraints, and ensure that all constraints are linear and integer/boolean.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Integer Variables with Bounds	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to servers in a cloud-based data center	Use QF_UF and QF_LIA constraints to model the resource allocation decision.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and set-logic to model resource allocation with multiple constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA logic to reason about resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Using QF_UF and QF_LIA rules, derive a valid solution that maximizes resource utilization.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Minimize the number of printers used	Using QF_UF and QF_LIA constraints, prove that it is not possible to allocate enough printers to satisfy all user requests without exceeding the available capacity.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	To ensure efficient resource allocation, we use the QF_UF and QF_LIA rules.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA theory to reason about resource constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use the QF_UF and QF_LIA logics to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
{'smtplib': 'int(x) <= x + 1'}	Satisfiability with constraints (set-logic QF_UF; assert x > 0; check-sat)	"(assert true)
(check-sat)"
Resource allocation problem	This problem involves allocating resources to tasks with different priorities and constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	To allocate resources efficiently, we need to minimize waste and maximize utilization of available resources.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA to represent resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA rules to model resource allocation problems	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	{'type': 'model-checking', 'description': 'Verify that a resource allocation model satisfies QF_UF and QF_LIA constraints.'}	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use set-logic QF_UF and declare-const to specify resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA rules to formulate a valid resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA solvers, and assert that the program produces exactly one solution.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Maximize production of 5 units while minimizing waste	Using QF_LIA and set-logic QF_UF, the following constraints can be derived.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
{'input': '\\(set-logic QF_UF\\) \\n \\n (declare-const x Int\\n \\n assert (x = 0)\n \\n check-sat)'}	This SMT-LIB program checks if a number is zero	"(declare-const n Int)
(declare-const x Int)
(assert (and (<= 1 n) (<= n 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct n x))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA to model this problem and ensure validity.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: assigning 10 units of CPU to process 1 and 5 units to process 2	Use QF_UF and QF_LIA constraints to model the resource allocation problem. Ensure that the total number of units allocated is exactly 15.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation: 3 cars and 4 passengers	Use QF_UF and set-logic to ensure that each passenger has at least one seat	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation optimization	Use QF_UF and QF_LIA constraints to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation	Use QF_UF and assert/declare/check-sat to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	(set-logic QF_UF) (declare-const x (int)) (assert (not (= 2, 0))) (check-sat)	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA to specify the resource allocation model.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Ensure that the minimum number of units required to satisfy all resource constraints is met	Use QF_UF and QF_LIA to reason about the satisfiability of the program, and check for validity using SMT solver.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF with assert statements to model this problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA rules to ensure feasibility.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: 5 agents, each with capacity 2 and deadline 10	Use QF_UF and QF_LIA rules to prove existence of a solution that satisfies all constraints	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	 - {set-logic QF_UF         assert (2 > 0)}	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to solve this optimization problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA solvers with simple integer constraints to model this problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Ensure that the maximum number of employees is allocated to each department	Use QF_UF or QF_LIA quantifier, and simple integer constraints (e.g., <=) to represent the relationship between departments and employees.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A woman has two coins that total 30 cents. One coin is not a nickel, and one coin is not a quarter. What type of coin are they?	To solve this problem, we can use QF_UF (Universal First-Order Formula) to represent the given constraints. We need to find two integers x and y such that x + y = 30, x is not equal to 5 (nickel), and y is not equal to 10 (quarter).	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
A farmer has a rectangular field with integer coordinates in pixels, and she wants to know if it's possible to place a row of n x m flowers on this field such that no two flowers are adjacent.	This problem can be solved using QF_UF (Unfolding Formulas) or QF_LIA (Linear Arithmetic Inequality).	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
Solve for x: 2*x + 5 = 11	Use QF_LIA and set-logic to model this equation as an equality of integer constraints.	"(assert true)
(check-sat)"
A farmer has a field with 3 rows and 4 columns. Each cell can hold either an integer from 1 to 10, inclusive.	{   (set-logic QF_UF)   (declare-const row1 int   row2 int   row3 int),   (declare-const col1 int   col2 int   col3 int),   (assert (>= row1 1)            (<= row1 10))   (assert (>= row2 1)            (<= row2 10))   (assert (>= col1 1)            (<= col1 4))   (assert (>= col2 1)            (<= col2 3))   (assert (>= col3 1)            (<= col3 4))   (check-sat)}	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
3+2=5	Using QF_LIA, we can assert that the sum of two integers less than or equal to 10 is greater than 1 and less than or equal to 15.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Solve for x: 2*x + 5 = 11	Use QF_LIA with constraints: x >= 0, 2x <= 6	"(assert true)
(check-sat)"
(set-logic QF_UF (declare-const x 1) (assert (>= x 0)) (check-sat)	This is a simple satisfiability problem, where we need to find an assignment of values to the variable x such that all constraints are satisfied.	"(assert true)
(check-sat)"
Solve the following logic puzzle: A bat and a ball together cost $1.10. The bat costs $1.00 more than the ball. If you have 5 times as many bats as balls, how much will you pay?	Let B represent the number of balls and B+ represent the number of bats. From the first equation, we get: B + (B+1) = 10. This simplifies to 2B + 1 = 10, or B = 4.5. Since you can't pay for a fraction of a bat, this means that the only possible solution is to have 5 balls and 4 bats.	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
The Five Switches	Use QF_LIA and set-logic QF_UF to prove that there is exactly one way to program a computer to switch between five lights on, one at a time, while the lights are off.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that there exists an integer x such that x^2 + x - 5 = 0	Use QF_UF and set-logic to prove the existence of a solution, and use check-sat to find it.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The Five Houses	Using set-logic QF_UF and quantifiers, prove that there exists a house on each row such that at least one of its doors is open.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF and QF_LIA to prove that there exists a number between 1 and 3 that has exactly one switch on.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	(set-logic QF_UF) (declare-const x true) (declare-const y false) (declare-const z true)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Five Houses Problem	To solve this problem, we need to use the QF_UF and QF_LIA SMT-LIB rules.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A man, a plan, a canal, Panama!	(set-logic QF_UF   (declare-const X 0 5)   (declare-const Y 5 10))(assert (>= X 1) (<= Y 4))   (check-sat)	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Three Switches	Use QF_UF and assert statements to prove that there is a unique solution to this puzzle.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Five Houses Problem	To solve this puzzle, we need to find a valid assignment of integers from 1 to 5 to the five houses such that no two adjacent houses have more than one occupant.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF to represent three switches, and assert that they are either all on or none of them is on.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has 'a' apples and 'b' bananas in his orchard. The number of apples is greater than twice the number of bananas, and both fruits must be non-negative.	The constraints are: (set-logic QF_UF) (declare-const a int > 0) (declare-const b int > 0) (assert (a > 2 * b) (check-sat)	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
A farmer has three fields: A, B, and C. Field A can hold values 0 through 9. Field B can hold values -1 through 1. Field C can only hold the number 5.	The farmer needs to ensure that field C holds a value of either 0 or 4. If field A holds any other value, then field C must be 0. Otherwise, if field A is 5 or greater, then field B must be -1.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
(set-logic QF_UF   (declare-const x 9)   (declare-const y 10)   assert (>= x 0)   assert (<= y 100)   check-sat)	Satisfiability isomorphism using UFL constraints and linear integer programming.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Satisfy the following set of constraints on the variable x.	Use the quantifier 'for all' to generalize over all natural numbers n.	"(declare-const of Int)
(declare-const on Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 on) (<= on 10)))
(assert (distinct of on))
(check-sat)"
A farmer has 5 sheep and 3 goats. How many animals does she have?	(set-logic QF_UF  (declare-const A int  (A = 5)  (G int  (G = 3)))  (assert < A + G > 0))	"(assert true)
(check-sat)"
The Set of Twin Primes	- Prove that there do not exist two prime numbers p and q such that pq = 2.	"(assert true)
(check-sat)"
A 5-person committee needs to decide on a project leader.	Use QF_UF and assert constraints like (equal (= 1 2)) or (not (equal (= 3 4))).	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
Solve for x: 2x + 5 = 11	Use QF_UF and set-logic (maximize) to find an optimal solution.	"(assert true)
(check-sat)"
The Five Houses Problem	To solve this problem, we need to assign numbers to each of the five houses such that each house is assigned a number between 1 and 5 (inclusive), and no two adjacent houses have the same number.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use the rules provided by the problem to construct a valid solution.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Five Houses Puzzle	To solve this puzzle, we need to find a valid assignment of integers from 1 to 5 to the five houses such that each house is either occupied by an integer or not.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer wants to optimize his irrigation system to minimize water waste.	To solve this problem, we can use QF_UF and QF_LIA SMT-LIB rules to check if it's possible to irrigate all fields with the given amount of water.	"(declare-const A Int)
(declare-const to Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct A to))
(check-sat)"
Solve the following puzzle:  3 x + y = 6, 2x - y = 4.	(set-logic QF_UF) (declare-const x Int) (declare-const y Int) (assert (>= x 0) (assert (>= y 0)) (verify-sat)	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
A person is standing next to a box with an unknown weight. The box has a label that says 'Heavy' if its weight is greater than 10 kg and 'Light' otherwise. The person is holding the box, but they don't know which side it's on. What can be said about the box?	Using QF_UF, we can assert that the box is either Heavy or Light.	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
There are three switches: hot, cold and off.  You can turn on any two switches at once using one of the following operations:  1. Turn on switch A and then off switch B.  2. Turn on switch C and then off switch D.  3. Turn on switch B and then off switch D.  4. Turn on switch A and then turn on switch C.  5. Turn on switch C and then turn on switch D.	This is a classic puzzle that can be solved by applying the rules of logic, using simple Boolean constraints (AND/OR) to represent the conditions for each step.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A man, a plan, a canal, Panama!	(set-logic QF_UF   (declare-const X 0 5)   assert (<= X 0)   check-sat)	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Five Houses Puzzle	To solve this puzzle, we need to use QF_UF constraints to represent the relationships between the houses and their occupants.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF to create a function symbol and apply it to three variables in a predicate.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following statement	Use the QF_UF and QF_LIA rules to generate a model that satisfies this statement.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a linear equation with two variables	Use QF_UF to ensure equality and QF_LIA to allow variable combination.	"(assert true)
(check-sat)"
Find integers x such that x^2 + 1 = x+3	This equation can be solved using QF_UF with the following constraints: (set-logic QF_UF) and (declare-const x integer)	"(assert true)
(check-sat)"
Prove that there exists an integer x such that x^2 + 4x - 7 = 0 and x is even	To prove this, we can use the QF_UF rules to find a model for the equation x^2 + 4x - 7 = 0. We can then analyze the models to determine which ones satisfy the condition that x is even.	"(declare-const an Int)
(declare-const is Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct an is))
(check-sat)"
(set-logic QF_UF (declare-const x 1 x < 5) (declare-const y 2 y = x + 3) assert (>= y 4)	To prove that the assertion is true, we can use a model with x >= 0 and y > 0.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
(set-logic QF_UF) (declare-const x 1) (assert (not (= x 0))) (check-sat)	To prove that x is not equal to 0, we can use the property of equality that if a = b then a = b.	"(assert true)
(check-sat)"
(set-logic QF_UF  define-const X 0  assert (<= X 5)  check-sat	This puzzle requires the solver to find a value for X such that it is less than or equal to 5.	"(assert true)
(check-sat)"
A farmer has a field that is 100 meters long and 50 meters wide. The field must be fenced in by a fence that is at least 2 meters high on all sides.	The farmer can use the following constraints to solve this problem:  - (declare-const field-width 50 :integer) - (declare-const field-length 100 :integer) - (assert (>= (add (multiply field-width 2) (add field-length 2)) (add field-width 2)))	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The set-builder logic asserts that there exists an integer x such that x^2 + 4x - 3 = 0.	\n\nThe given equation can be solved using the quadratic formula: x = (-b  sqrt(b^2 - 4ac)) / 2a. In this case, a=1, b=4, and c=-3. \nThe solution to the equation is x = (-(4)  sqrt((4)^2 - 4*1*(-3))) / (2*1), which simplifies to x = (-4  sqrt(16 + 12)) / 2, or x = (-4  sqrt(28)) / 2. Since sqrt(28) is not a perfect square, there are two solutions: x = (-4 + sqrt(28)) / 2 and x = (-4 - sqrt(28)) / 2. \nThe set-builder logic asserts that exactly one of these two solutions exists.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The Five Houses Problem	Use set-logic QF_UF and declare variables for each house number.  (declare-const house1-number 1) (declare-const house2-number 2) (declare-const house3-number 3) (declare-const house4-number 4) (declare-const house5-number 5)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Find an infinite set {x: [0, 1]}.	This problem can be solved using QF_UF.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that there exists an integer x such that x^2 + 4 = 13	Use QF_UF and set-logic to derive the desired formula.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
(set-logic QF_UF  (declare-const x 1)  (declare-const y 2)	This problem is a simple example of using set-logic QF_UF to reason about the satisfiability of a given formula.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
A farmer wants to ensure that all cows are wearing collars of a certain color.	The farmer has ordered 100 cows, each with one collar. The collar can be either red or blue. Use QF_UF and QF_LIA constraints to prove that there is an assignment of colors to the collars such that all 100 cows are wearing their assigned colors.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Flipped Coins	Use QF_UF with a set of variables and constraints to prove that it's impossible to flip all coins such that one side always shows the opposite number.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Prove that there exists an integer x such that exactly three switches are open.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF to prove that exactly one of three boolean variables can be false at any given time.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Prove that it is impossible to assign colors to three switches such that each switch corresponds to one of three colors and the corresponding color switch is red.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
\(\{\n  x: \n    # Introduce a variable and constraint\n    assert(x > 0);\n  y: \n    # Introduce another variable and constraint\n    assert(y < x);\n  z: \n    # Use SMT-LIB to prove the variables are equal\n  (set-logic QF_UF \n    (declare-const x : int) \n    (declare-const y : int) \n    (declare-const z : bool))\n  \n  assert(z);\n  \n  (check-sat)	\(\{\n  # We use the fact that x > 0 and x + y = z to prove x == z\n  assert(x + y = z + x);\n  \n  # Since z is True, we can deduce x == z\n  assert(x == z);\n  \n  \n  # Use the assumption that x < 0 and x - y = z to prove x != z\n  assert(x > 0 && x - y = z);\n  \n  # Since z is False, we can deduce x != z\n  assert(x != z);\n  \n  \n  \n  (check-sat)	"(declare-const a Int)
(declare-const n Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 n) (<= n 10)))
(assert (distinct a n))
(check-sat)"
A prisoner needs to escape from a cell with multiple locks, each of which has two possible keys: the correct key or the wrong key. The guards enter a room and check one lock at a time in order.	To solve this problem using QF_UF, we need to model the guards' behavior as a set of rules that specify when they should consider each lock as the correct key. We can use (set-logic QF_UF) to define this logic, and then add rules for checking each lock's key.	"(declare-const A Int)
(assert (and (<= 1 A) (<= A 3)))
(declare-const a Int)
(assert (and (<= 1 a) (<= a 3)))
(declare-const and Int)
(assert (and (<= 1 and) (<= and 3)))
(assert (distinct A a and))
(check-sat)"
A woman has two coins that weigh differently. One coin weighs 1 kg and the other weighs 0.9 kg. How much does the lighter one weigh?	Use set-logic QF_UF and assert   (weigh < 1kg)  and (not (weigh = 0.9kg))	"(declare-const A Int)
(declare-const kg Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 kg) (<= kg 10)))
(assert (distinct A kg))
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 0 and x is not odd	To prove this statement, we can use the QF_UF rule to generate a set of solutions for the equation x^2 + 1 = 0. We then check if any of these solutions are integers that satisfy the condition x is not odd.	"(declare-const an Int)
(declare-const is Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct an is))
(check-sat)"
A farmer has two fields, A and B. Field A has 5 apples, and field B has 3 oranges. The farmer wants to know if there are any common fruits between the two fields.	The farmer can find the intersection of sets containing apples and oranges in both fields.	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
A bat and a ball together cost $1.10. The bat costs $1.00 more than the ball. If the ball costs x dollars, how much does the bat cost?	Let b = number of cents in the ball. Then the equation is (100 - b) + b = 110. Solve for b.	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
Satisfying the union of two sets with distinct elements	Use QF_UF and set-builder constraints to model the union of two sets A = {1, 2} and B = {3, 4}. The constraint (set-logic QF_UF) ensures that each element in both sets is present. The constraint (declare-const x : setof int) defines a set of integers containing all elements from both sets. Finally, the constraint (assert all of A | B) asserts that any element in either set is present.	"(assert true)
(check-sat)"
A farmer has two fields, A and B. Field A is 3 units long, while field B is only 2 units long. The farmer wants to know if there are enough spaces on both fields.	The problem can be solved using the QF_UF rule with a conjunction of constraints representing the length of each field and its relationship with the number of rows.	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Satisfying a set of rules on the number of apples	Use QF_UF to generate constraints for the number of apples in each basket and then solve using check-sat.	"(declare-const a Int)
(declare-const of Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct a of))
(check-sat)"
A farmer has two fields: Field A and Field B. If it rains, both fields receive water, but only if it's not too hot.	let (   0:     assert (>= 20 any x) => (x = 'hot')   1:     assert (= 100 any y) => (y = 80)   2:     let (       z: set of string       f0: {x | x = 'hot', x < 20}       f1: {x | x = 'hot', x >= 20, x <= 30}       f2: {x | x = 'hot', x > 30})     assert (in z f0)     & (not in f1 f0)    & (in f2 f1)	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A farmer wants to irrigate all but two rows of his garden, and then water one row. What are the possible values for k?	To find the exact number of rows that will be irrigated, we need to use the set-logic QF_UF and check-sat constraints.	"(declare-const A Int)
(declare-const k Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 k) (<= k 10)))
(assert (distinct A k))
(check-sat)"
"{   'problem': ""Solve the following puzzle: There are three switches, but they are not labelled. Each switch corresponds to one of three light bulbs in a room. Each bulb is either on or off. You can turn the switches on and off as many times as you want, but you can only enter the room one time to observe the bulbs. How can you figure out which switch corresponds to which light bulb?"""	{   (set-logic QF_UF)   (declare-const bulb1 bool   bulb2 bool   bulb3 bool)   (declare-const switches [ bulb1 true    bulb2 false    bulb3 true ]   (assert not (switches[0]            or switches[1]            or switches[2]))   (check-sat)	"(declare-const a Int)
(assert (and (<= 1 a) (<= a 3)))
(declare-const as Int)
(assert (and (<= 1 as) (<= as 3)))
(declare-const in Int)
(assert (and (<= 1 in) (<= in 3)))
(assert (distinct a as in))
(check-sat)"
(set-logic QF_UF (declare-const x int) (declare-const y bool) (assert (>= x 0) (check-sat)	This is a simple problem that can be solved using basic arithmetic and logical constraints. The goal is to determine if the value of x is greater than or equal to 0, given that it is an integer.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
(set-logic QF_UF   (declare-const x y int)   (assert x > 0))	This is a simple logic puzzle where we are asked to prove that if x is greater than 0, then x is positive.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
A farmer has a field that can hold up to 1000 square meters of land. The field is currently empty, and it needs to be fenced in.	The farmer needs to fence in at least 800 square meters of land for this task.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Three Switches	Use set-logic QF_UF and assert/declare/declare-const to model a problem where a person has three switches, labelled A, B and C, and each switch corresponds to one of three light bulbs in a room. The lights are initially off, and we can turn the lights on or off at most once per switch. We want to determine if it is possible to turn all the lights on with just two switch flips.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
(set-logic QF_UF (declare-const x y 1))	(assert y = 1) && (check-sat)	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
The Three Switches	{'type': 'deductive', 'constraints': ['\n  assert (x = 0)\n', '\n  assert (y = 1)\n', '\n  assert (z = 2)\n']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use set-logic QF_UF and assert/unify to prove that there is no valid assignment of colors to switches such that each switch corresponds to either red or green.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the following system of linear equations with integer coefficients and constraints	Use QF_LIA or QF_UF to generate the model, then solve it using a solver like DPLL or CDT.	"(assert true)
(check-sat)"
(set-logic QF_UF (declare-const x 1 #t) (declare-const y 2 #f) (assert (x = true) (y = false)))	to prove that x and not y are both true or both false using only basic arithmetic operations and equality checks	"(declare-const f Int)
(declare-const t Int)
(assert (and (<= 1 f) (<= f 10)))
(assert (and (<= 1 t) (<= t 10)))
(assert (distinct f t))
(check-sat)"
The set of all perfect numbers	This is a classic problem in number theory, and it can be solved using QF_UF with constraints such as (forall x (<= 1000) (odd? x))	"(assert true)
(check-sat)"
Solve the puzzle: 5 cars are parked on the street, and each car has a different color. If we add 2 more cars with the same color, can you find the color of all 7 cars?	Use mod 3 to solve this problem by assuming that the total number of cars is divisible by 3.	"(declare-const If Int)
(declare-const a Int)
(assert (and (<= 1 If) (<= If 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct If a))
(check-sat)"
A farmer has a field with two rows and two columns. Each cell in the field can be either red or green. The farmer wants to know if it is possible to reach every cell from one corner to the other using only right and up moves.	This problem is a classic example of a constraint satisfaction problem (CSP) that can be solved using QF_UF and QF_LIA solvers in SMT-LIB. We need to find all possible valid paths from the top-left corner to the bottom-right corner while respecting the constraints.	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
Satisfy the following proposition: 2 + 2 = true.	This can be proved using the QF_UF rule and simple arithmetic constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use a model with three variables and two constraints to solve this puzzle.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given integers a and b, find all pairs of distinct positive integers c and d such that a + b = c + d	Prove the validity of the following system using QF_UF or QF_LIA with integer constraints: (set-logic QF_UF)   (declare-const a Int)   (declare-const b Int)   (declare-const c Int)   (declare-const d Int)   (assert (a + b = c + d))   (check-sat)	"(declare-const a Int)
(declare-const b Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 b) (<= b 10)))
(assert (distinct a b))
(check-sat)"
Prove that the following statement is true: x = 5 and y != 3	Use the QF_UF rule to combine the assertions of x = 5 and y != 3, then use the QF_LIA rule to prove the conjunction of these two statements. Finally, add a check-sat clause to verify that the system is satisfiable.	"(declare-const is Int)
(declare-const x Int)
(assert (and (<= 1 is) (<= is 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct is x))
(check-sat)"
Solve the following puzzle: A bat and a ball together cost $1.10. The bat costs $1.00 more than the ball. If the ball costs x dollars, how much does the bat cost? y.	$y-x=0.10\quad$y>x$	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
A 5-person committee must be formed from a group of 8 people, and each person can only speak on one topic.	Use set-logic QF_UF to ensure that each member speaks only once and use   for newlines inside the SMT string.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Five Houses Puzzle	Use QF_UF to express that each house is occupied by either a person or an animal.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has N cows to milk. The first cow can be milked at most once per day, and each cow takes at least one hour to milk. If the farmer starts with an empty fridge, how many days will they need to milk all their cows?	To solve this problem, we can use the QF_UF logic, which allows us to represent the constraints as a set of clauses with atomic propositions representing the number of cows and hours spent milking. We can then use the 'check-sat' solver to find an optimal solution.	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
The Three Switches	(set-logic QF_UF) (declare-const x 1) (assert (x = 0)) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has two fields, A and B. Field A contains all the apples from both fields combined. If field C contains only apples that are red, then field D must contain at least half of field A's apple count.	Use QF_UF and QF_LIA to solve this problem. Consider the constraints (set-logic QF_UF) and (declare-const ...). Use assert statements to define field A and field B. Assume all apples are either red or not red for field C, then use modularity on field D.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A farmer has 5 sheep and wants to build a fence around them. The fence must be at least 3 meters long and can have a maximum of 10 meters in the middle.	Use QF_UF constraints to ensure that the fence can accommodate all the sheep while leaving some buffer space on each side.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
A farmer has 'm' chickens and wants to know if they are all happy.	The answer is yes if and only if m = 5 or m = 6	"(declare-const A_friend_if Bool)
(declare-const if_friend_A Bool)
(assert (= A_friend_if if_friend_A))
(assert (= true A_friend_if))
(check-sat)"
The Life of Pi	Use QF_UF and assert constraints on pi, x, and y.	"(declare-const Pi Int)
(declare-const of Int)
(assert (and (<= 1 Pi) (<= Pi 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct Pi of))
(check-sat)"
A farmer has three fields: A, B and C. Field A has 4 rows and 5 columns, field B has 3 rows and 6 columns and field C has 2 rows and 8 columns. The farmer wants to know how many hot peppers are in each field.	The total number of hot peppers in all fields is equal to the sum of the products of the number of rows and columns in each field, multiplied by a constant (1).	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
\(\(\{1:2, 3:4} \) -> (false))	(set-logic QF_UF) (declare-const X int) (assert (X = 1) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
(set-logic QF_UF) (declare-const x 1  # t) (assert (<= 0 (and x 2) (add 3 x))) (check-sat)	"Using the <a href=""https://www.sat.inf.u-bremen.de/"">SAT solver</a> to verify the satisfiability of the given formula. We found that it is unsatisfiable for all values of x."	"(declare-const t Int)
(declare-const x Int)
(assert (and (<= 1 t) (<= t 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct t x))
(check-sat)"
The Three Switches	"(set-logic QF_UF 	(declare-const x 1) 	(declare-const y 2) 	(assert (not (= x 0))) 	(check-sat)"	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	QF_UF and set-logic QF_LIA	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has 5 rows of flowers in her garden, and each row can have at most 3 flowers. The number of flowers in each row must be an integer between 0 and 4 (inclusive).	The number of flowers is a valid integer.	"(declare-const A Int)
(declare-const an Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 an) (<= an 10)))
(assert (distinct A an))
(check-sat)"
Satisfying a simple equation	Use <~{ to enforce an inequality, and <~~ to enforce equality.	"(assert true)
(check-sat)"
Satisfying the Chicken McNugget Theorem	The Chicken McNugget Theorem states that the sum of two relatively prime numbers has a unique representation as a linear combination of those two numbers. Prove this theorem using QF_UF and SMT-LIB.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use a switch statement to determine which color shirt to wear based on the day of the week.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has three fields of wheat: Field A, Field B, and Field C. Each field can hold either 0 or 1 units of wheat. The farmer needs to determine which field holds how many units of wheat based on the following clues.	Use QF_UF (Universal Forcing) and assert constraints for each field to deduce its contents.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A farmer has two fields, A and B. Field A can hold at most 1000 units of soil, and field B can hold at most 2000 units of soil. The farmer wants to know if it is possible to allocate the soil between the two fields such that field A does not exceed its capacity and field B does not exceed its capacity.	use QF_UF to add constraints on the number of units in each field, check-sat to verify the validity of the constraints	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Solve the following logic puzzle: There are three switches, but they are not labelled. Each switch corresponds to one of three light bulbs in a room. Each bulb is either on or off. You can turn the lights on and off as many times as you want, but you can only enter the room one time to observe the bulbs.	Use QF_UF to model the switches and their corresponding light bulbs. The only constraints should be integer variables for the number of times each switch has been turned on or off.	"(declare-const a Int)
(assert (and (<= 1 a) (<= a 3)))
(declare-const as Int)
(assert (and (<= 1 as) (<= as 3)))
(declare-const in Int)
(assert (and (<= 1 in) (<= in 3)))
(assert (distinct a as in))
(check-sat)"
The set of all perfect squares between 0 and 100	Use QF_UF to express that a number is either even or odd, then use the property (forall x (x = 0) -> (not (x^2))) to assert that there are no perfect squares less than 100.	"(assert true)
(check-sat)"
The Five Houses Problem	Use QF_UF and QF_LIA solvers to prove the following statement: There exists an integer x such that x^2 + x + 1 = 5x + 4 or (x == 0 and y == 2) or (x == 3 and y == 1)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
\u03c0\u202f\u2228\u221a\u203b\u2153\u2192\u2115\u20d1\u2164\u217e\u22cc\u2202\u2189\u2164\u223b\u2193\u214f\u2187\u212a\u215c\u2236\u219d\u2210\u2135\u2188\u217c\u2221\u218a\u216f\u220e\u2192\u211c\u2153	\u03b7\u2129\u20ac\u201d\u2060\u2035\u2130\u2211\u2148\u218a\u2164\u217e\u22cc\u2202\u218f\u2153\u219b\u222c\u2207\u2189\u207d\u2066\u2120\u20ac\u201d\u2035\u2130	"(declare-const u2115 Int)
(declare-const u2135 Int)
(assert (and (<= 1 u2115) (<= u2115 10)))
(assert (and (<= 1 u2135) (<= u2135 10)))
(assert (distinct u2115 u2135))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that two people are friends if and only if they have a mutual friend	Use QF_UF to prove the biconditional, and use set-logic to add the necessary constraints	"(declare-const a_friend_if Bool)
(declare-const if_friend_a Bool)
(assert (= a_friend_if if_friend_a))
(assert (= true a_friend_if))
(check-sat)"
(set-logic QF_UF   (declare-const x int)   (assert (not (= x 0)))   (check-sat)	The assertion will only be true if x is not equal to 0.	"(assert true)
(check-sat)"
Social inequality	Use QF_UF to model the relationship between income and education level, where higher income leads to higher education level.  (declare-const X (integer : LessThan 5))  (declare-const Y (integer : GreaterThan 0))  (assert (QF_UF (     X Y              <= 4 ? true : false) )	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given a social network with people of different ages, find all pairs of individuals who are friends.	To solve this problem, we can use QF_UF and check-sat constraints to derive the friendships between people. We can first list all possible pairs of individuals, then constrain each pair using simple integer or boolean constraints (e.g., `age(a, b) <= 18 && age(b, a)`), and finally check for satisfiability.	"(declare-const a_friend_of Bool)
(declare-const of_friend_a Bool)
(assert (= a_friend_of of_friend_a))
(assert (= true a_friend_of))
(check-sat)"
Prove that there exists an integer x such that x + 1 = 3 and x - 2 > 0	Use the QF_UF rule to combine x + 1 = 3 with x - 2 > 0 to get (x+1) - (x-2) = 5 > 0	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The given social constraint is inconsistent and cannot be satisfied by any assignment of integers or booleans.	A valid solution would require the existence of a finite set of integer values that can satisfy all constraints simultaneously.	"(declare-const be_of Bool)
(declare-const be_or Bool)
(declare-const by_of Bool)
(declare-const by_or Bool)
(declare-const is_of Bool)
(declare-const is_or Bool)
(assert (= (+
  (ite be_of 1 0)
  (ite by_of 1 0)
  (ite is_of 1 0)
) 1))
(assert (= (+
  (ite be_or 1 0)
  (ite by_or 1 0)
  (ite is_or 1 0)
) 1))
(assert (<= (+
  (ite be_of 1 0)
  (ite be_or 1 0)
) 1))
(assert (<= (+
  (ite by_of 1 0)
  (ite by_or 1 0)
) 1))
(assert (<= (+
  (ite is_of 1 0)
  (ite is_or 1 0)
) 1))
(check-sat)"
Prove that John and Mary are married	Use QF_LIA and assert the following equations to prove this statement, then check-sat.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Ensure that no two people in a friendship network have more than one connection to each other	"model  	 globeforall x y z:  		headgedd (x, y)  		and  		( x  eq z |  			not ( 			y, z)  	))"	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (= a_friend_in in_friend_a))
(assert (= true a_friend_in))
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 2x and x is less than or equal to 10	{'method': 'modelChecking'}	"(declare-const an Int)
(declare-const is Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct an is))
(check-sat)"
Prove that there exist two distinct integers x and y such that x + y = 5	Using QF_UF with constraints x >= 0, y <= 5, and x + y = 5, derive the existence of a solution.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that it is not possible to construct a directed acyclic graph (DAG) with more than 5 nodes and 10 edges.	This can be proven using the properties of finite state machines, specifically the pumping lemma for regular languages. The pumping lemma states that there exists a positive integer k such that any string s in the language must contain at least one character that appears at least k times in blocks of length at most 2k.	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Prove that there exists an integer x such that x^2 + 4 = 8 and x^2 - 3 < 0.	This problem can be solved using the QF_UF rule, which states that for any formula f(X) of type 'quantifier-free' with one free variable X, we have either f(X) or f(X). We will use this rule to derive a contradiction. First, we show that 3^2 - 4 = 5 and 3^2 + 4 > 8. Then, we can conclude that there exists an integer x such that x^2 < 0.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that 'John' is not equal to 'Alice'	Use QF_UF with set-logic and assert constraints.	"(declare-const is Int)
(declare-const to Int)
(assert (and (<= 1 is) (<= is 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct is to))
(check-sat)"
Prove that there exists an integer $x$ such that x^2 + 3x - 4 = 0	The quadratic equation has at least one real root according to the Fundamental Theorem of Algebra, and we can show this by attempting to solve it manually.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that there exists an integer x such that x > 0 and (x + 1) mod 3 = 2	Using the properties of modular arithmetic, we can derive that if x is positive, then (x + 1) mod 3 must be equal to 2. This implies that there exists a unique integer solution for x.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that John and Mary are married.	(set-logic QF_UF) (declare-const John mary : pair (string , string)) (assert (John mary) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that a person is not married to themselves.	(not (set-of-facts (set-of-constants 'x) (set-of-constants 'y)))	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Prove that for all integers n >= 2, (1 + n) mod 3 = 0.	This statement can be proven using the properties of modular arithmetic and the fact that 1 + n is always even when n is odd or a multiple of 4.	"(assert true)
(check-sat)"
Prove that there are at least two distinct social connections between individuals in a small community.	Use QF_UF and QF_LIA rules to derive the existence of at least two distinct social connections, given the following assumptions: people have no social connections with themselves, people can be connected by exactly one other person, people cannot be connected by multiple people.	"(declare-const a Int)
(declare-const at Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 at) (<= at 10)))
(assert (distinct a at))
(check-sat)"
Verify that the following relation holds: (x, y) <- (x, z) && (y, z)	Use QF_UF and QF_LIA rules to derive the implication.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that it is impossible to have two people who are friends with each other	{'description': 'Use QF_UF and set-logic to model this relationship.', 'smtlib': 'set-logic QF_UF\ndeclare-const Alice:Int\ndeclare-const Bob:Int'}	"(declare-const is_friend_it Bool)
(declare-const it_friend_is Bool)
(assert (= is_friend_it it_friend_is))
(assert (= true is_friend_it))
(check-sat)"
Given the following social network structure: [1, 2; 2, 3; 3, 4], define the minimum number of friendships required to satisfy all constraints.	To solve this problem, we can use QF_LIA with a set of constraints that enforce the presence of at least one friendship between each pair of nodes in the network. We can then check if the resulting model is satisfiable using check-sat.	"(declare-const of_friend_to Bool)
(declare-const to_friend_of Bool)
(assert (= of_friend_to to_friend_of))
(assert (= true of_friend_to))
(check-sat)"
Prove that any two people are connected in a social network	Use QF_UF and QF_LIA rules to reason about graph connectivity	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Verify that a social relationship graph is consistent.	{   (set-logic QF_UF)   (declare-const person1 person2 : FRIENDS)   (assert (forall (x person)         (           (person1 x)                        (person2 x))         (not (eq x x)))   )	"(declare-const a_friend_is Bool)
(declare-const is_friend_a Bool)
(assert (= a_friend_is is_friend_a))
(assert (= true a_friend_is))
(check-sat)"
Prove that two people are friends if and only if they share a common interest.	Use QF_UF to combine two literals representing friendship and two literals representing shared interests, then use assert to prove that the first literal is true if and only if the second literal is true. Finally, check-sat to verify that the system satisfiable.	"(declare-const a_friend_if Bool)
(declare-const if_friend_a Bool)
(assert (= a_friend_if if_friend_a))
(assert (= true a_friend_if))
(check-sat)"
Determine whether a person is married to their spouse	Use QF_LIA and (set-logic QF_UF) with valid constraints to prove that a person is not married to their spouse.	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Prove that there does not exist an integer x such that x^2 + 1 = 0	This statement can be proven using the QF_LIA theory, specifically by assuming x is an integer and then deriving a contradiction.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that if person A is friends with person B and person C, then person A and person C are connected by a friendship chain	Use QF_UF to represent friendships between people and QF_LIA to ensure the structure of the friendship graph is consistent.	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Determine if all people in a social network have at least one friend.	Use QF_UF and assert statements to model relationships between individuals, then use the check-sat solver to verify validity.	"(declare-const a_friend_at Bool)
(declare-const at_friend_a Bool)
(assert (= a_friend_at at_friend_a))
(assert (= true a_friend_at))
(check-sat)"
Prove that there exist two people in a social network such that they are friends and not spouses.	Use QF_UF with constraints on friendships and non-spousality, then add an assumption about the existence of at least one pair of people who could be friends but not spouses.	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (not a_friend_in))
(assert (not in_friend_a))
(check-sat)"
Prove that there does not exist an integer k such that k^2 + 5k - 6 = 0	(assert (integer s) (> 0 ? 1 : 2)) (assert (syms x k real) > 0) (assert (satisfies (e (univariate x) (- 6 x 6 k^2 + 5 k))) > 0) ((set-logic QF_UF) (declare-const s real)) ((check-sat))	"(declare-const an Int)
(declare-const k Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 k) (<= k 10)))
(assert (distinct an k))
(check-sat)"
Determine whether it is possible to construct a social network where all individuals are connected and no two individuals are friends	The graph of friendships can be represented as an undirected graph with weighted edges, where each edge has a weight representing the strength of the friendship. A valid solution would require that there is at least one strongly connected component in the graph.	"(declare-const a_friend_is Bool)
(declare-const is_friend_a Bool)
(assert (= a_friend_is is_friend_a))
(assert (= true a_friend_is))
(check-sat)"
Prove that if Alice is friends with Bob and Bob is friends with Charlie, then Alice is friends with Charlie	Use QF_UF with constraints that express the friendship relationships as valid integer solutions. Ensure the model is satisfiable by checking for consistency.	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (= if_friend_is is_friend_if))
(assert (= true if_friend_is))
(check-sat)"
Prove the following sentence is valid in QF_UF	Use the set-logic QF_UF and assert statements to derive the sentence.	"(declare-const in Int)
(declare-const is Int)
(assert (and (<= 1 in) (<= in 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct in is))
(check-sat)"
Given a person A with age 25 and friend B, prove that if A's friends are all friends of C then A is friends of B.	(declare-const A Person (0: 1) (declare-const B Person (0: 1) (declare-const C Person (0: 1))  (   (            (forall x (Person (x)) (         (set-of y (Set-of-z) z)))        ) )  (   (assert (or (A= B) (All-of-A-Friend-Of-B-C A C))))	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Prove that if person1 is friends with person2 and person3, then person4 is not friends with person5.	{'method': 'existential', 'variables': ['person1', 'person2', 'person3', 'person4', 'person5'], 'constraints': ['(set-logic QF_UF)\n\n', '(declare-const person1 person1)\n', '(declare-const person2 person2)\n', '(declare-const person3 person3)\n', '(assert (person1 <> person2))\n', '(assert (person1 <> person3))\n', '(assert (not (person4 <>) (person5 <)))']}	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (not if_friend_is))
(assert (not is_friend_if))
(check-sat)"
The relationship 'John Doe' and 'Jane Smith' are friends.	To verify this statement, we can use the QF_UF (Universal Forcing) logic with a set of constraints involving relationships between individuals. We will also utilize the assert clause to enforce the validity of the given statements.	"(declare-const X_friend_Y Bool)
(declare-const Y_friend_X Bool)
(assert (= X_friend_Y Y_friend_X))
(assert (= true X_friend_Y))
(check-sat)"
The given social network of friends has exactly 5 people.	A person can only be friends with themselves, and no one is friends with each other if their number of friends is odd. This means that the total number of pairs of friends should equal half of 15 (the total number of people).	
Prove that there exists an integer x such that x + 1 = 2x	Use the QF_UF and QF_LIA rules to derive the desired consequence.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that there are no cycles in the graph G = ({a, b, c}, R), where R is an undirected relation and 'a' and 'b' are related to each other, but not both.	Use QF_UF and set-logic to reason about the satisfiability of this graph. Assume X = {a, b} such that X  G. Prove by contradiction that there exists a path from a to c in G if and only if for all y  X, (y, x)  R.	"(declare-const G Int)
(declare-const R Int)
(assert (and (<= 1 G) (<= G 10)))
(assert (and (<= 1 R) (<= R 10)))
(assert (distinct G R))
(check-sat)"
Pigeonhole Principle	Given n pigeons and m pigeonholes, show that at least one pigeonhole must contain more than one pigeon.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The following social relationship constraint is valid: P(x, y) |= Q(x, z), where P, Q are predicates and x, y, z are atoms.	To prove the validity of this constraint, we need to show that it is satisfiable using a finite model.	"(declare-const P_friend_Q Bool)
(declare-const Q_friend_P Bool)
(assert (= P_friend_Q Q_friend_P))
(assert (= true P_friend_Q))
(check-sat)"
Verify that a social constraint involving two individuals and their relationships holds true	{'method': 'existential quantification'}	
Prove that all employees in the company are working	Using set-logic QF_UF and QF_LIA, derive the following implications: (set-of-people employee1 ... employee5) => (work(employee1, employee2), work(employee3, employee4), work(employee5, employee6))	"(assert true)
(check-sat)"
Prove that John and Mary are married	(set-logic QF_UF) (declare-const John mary : bool) (assert (== John mary)) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that if person1 is friends with person2, and person2 is friends with person3, then person1 is friends with person3.	Use the transitive property of friendship to prove this implication.	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (= if_friend_is is_friend_if))
(assert (= true if_friend_is))
(check-sat)"
Prove that a person is either in their hometown or not.	This can be represented as a disjunction of two constraints: (set-of-variables-person home-town) and (not-set-of-variables-person elsewhere).	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Find all pairs of people in a social network where one person is friends with another.	Use QF_UF to model friendship relationships and check-sat to solve the problem	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (not a_friend_in))
(assert (not in_friend_a))
(check-sat)"
Prove that any person is either a student or an employee of the same company.	{   (set-logic QF_UF)   (declare-const C (Symbol('Company'))   (declare-const S (Symbol('Student'))   (declare-const E (Symbol('Employee'))   (assert (not (or (= C S) (= C E))))   (assert (not (and (= S C) (= E C)))   (assert (not (or (= S E) (= C E)))))   (check-sat) }	"(declare-const a Int)
(declare-const an Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 an) (<= an 10)))
(assert (distinct a an))
(check-sat)"
Prove that a person is either married to their spouse or not married at all	Use QF_UF and assert variables for marriage status, then check-sat	"(declare-const a Int)
(declare-const at Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 at) (<= at 10)))
(assert (distinct a at))
(check-sat)"
Prove that John and Mary have different favorite sports.	Use QF_UF with (set-logic QF_UF) to express the relationship between two individuals. Then, use (assert ...) to assert a specific property about their preferences. Finally, check-sat to prove this property holds true.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that John and Alice are friends.	(john = alice) -> (friend john alicia)	"(declare-const X_friend_Y Bool)
(declare-const Y_friend_X Bool)
(assert (= X_friend_Y Y_friend_X))
(assert (= true X_friend_Y))
(check-sat)"
A university has two social constraints regarding friendships between students.	These constraints can be represented using QF_UF and QF_LIA axioms.	
Prove that a person is either in the US or has a valid US driver's license.	Use QF_LIA and assert that the person is in the US or their driver's license is valid.	"(declare-const US Int)
(declare-const a Int)
(assert (and (<= 1 US) (<= US 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct US a))
(check-sat)"
Prove that every person has at least one friend	Use QF_LIA and QF_UF to model the friendship relationship between people	"(declare-const at_friend_has Bool)
(declare-const has_friend_at Bool)
(assert (= at_friend_has has_friend_at))
(assert (= true at_friend_has))
(check-sat)"
Satisfies QF_UF rule with a valid JSON payload	"{'solver': 'CPVEX', 'input': '{""solution"": ""1"", ""constraints"": [""x + y = 2""]}', 'expected_solution': '[0, 3]'}"	"(assert true)
(check-sat)"
The social network has a relationship between John and Alice, but they are not friends.	{'constraints': ['(set-logic QF_UF)\n', '(declare-const person1 person2)\n', '(assert (not (person1 = person2)))\n', '(check-sat)']}	
\(set-logic QF_UF\) \(declare-const x = 5\) \(assert \((\u'== 4\)\))	This proof uses QF_UF to prove a simple equality and QF_LIA to derive the truth of the assertion.	"(declare-const u Int)
(declare-const x Int)
(assert (and (<= 1 u) (<= u 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct u x))
(check-sat)"
The relationship between person A and person B is that they are friends.	This can be expressed as (set-logic QF_UF)      (declare-const personA personA   declare-const personB personB   assert (personA == personB))   (assert (not (personA != personB)))	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
\(set-of\(\{x| x #= 1\} \) && \(set-of\(\{y| y #!= 2 && !x || y #<= 3\} \))\)	\(declare-const x 1; \(declare-const y 2; \(assert (xor (and (not (eq x 1) (neq x 2)) (not (eq x 1) (lt x 3))) (and (neq x 1) (gt x 3)));\)	"(declare-const of Int)
(declare-const x Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct of x))
(check-sat)"
Prove that there exists an integer x such that 2*x + 3 >= 5 and x^2 <= 4	Use QF_UF to model the system of linear inequalities: 2x + 3 >= 5 --> 2x >= 2 --> x >= 1; x^2 <= 4 --> x <= -2	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that for all integers x and y, if x > y then x + y = 2y	Using QF_UF with the set of integers and the implication rule, derive the following:   (declare-const x Int) (declare-const y Int) (assert (x > y)) (check-sat)	"(declare-const if Int)
(declare-const x Int)
(assert (and (<= 1 if) (<= if 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct if x))
(check-sat)"
{'solver': 'QF_UB', 'reasoning': '(set-logic QF_LIA (declare-const x 0: INTEGER) (assert (>= x 1)) (check-sat))'}	(assert (>= 2 3)) (check-sat)	"(assert true)
(check-sat)"
Prove that if Alice and Bob are friends, then Carol is also friends with both of them.	(set-logic QF_UF)                (declare-const alice friend bob)     (assert (not (friend bob alice)))     (declare-const carol friend alicebob)     (assert (and (friend alicebob carol) (friend alice carol)))	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (= if_friend_is is_friend_if))
(assert (= true if_friend_is))
(check-sat)"
Prove that there are no friends among five people.	To prove this, we can use QF_LIA and assert that each person is either friend with themselves or not.	
A person is either married to their spouse or in a consensual relationship with someone else.	This property can be expressed using QF_UF (Unions of First-Order) and constraints such as <person> marry <other_person>	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
Verify that there are no social connections between all individuals in a network of 10 people with no mutual friends	Use QF_UF to model the relationship as a graph, and then use QF_LIA to check if the graph is acyclic. If it is not, then there must be some cycle of edges, meaning that someone is connected to everyone else, which means they have mutual friends.	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (= a_friend_in in_friend_a))
(assert (= true a_friend_in))
(check-sat)"
(set-logic QF_UF (declare-const x y z (integer :pred <)) (assert (not (= x 5))) (check-sat)	(check-sat)	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that there exist distinct integers x, y such that x + y = 3 and x  y	Using QF_UF and the constraints x + y = 3 and x  y, derive a contradiction if neither x nor y is equal to zero.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that a person who has friends with people they know personally and strangers, but does not have acquaintances outside of their social circle, cannot be a friend to any one specific stranger.	Use QF_UF or QF_LIA with the following constraints: (set-logic QF_UF) (declare-const person1 <person1> (friend-of-person1 person2 (friend-of-person1 person3) ... (not acquaintances person4 person5))) (assert (for-all x (forall y (not friend-of-person1 y x))) (not (in-a-social-circle x)))	"(declare-const a_friend_be Bool)
(declare-const be_friend_a Bool)
(assert (not a_friend_be))
(assert (not be_friend_a))
(check-sat)"
Prove that there exist non-empty sets A and B of people such that A  B = 	"The following set constraints ensure the existence of such sets:  - A (A  X)   	B (B  A);"	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
Social Network Problem	The following friendship relationships hold: (Alice, Bob), (Bob, Charlie), (Charlie, Alice). Find the maximum number of friends each person can have.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given two people A and B, where person A is related to person B by marriage if A's age is greater than B's age.	Use QF_UF or QF_LIA with set-logic to express the relationship between ages of individuals for any positive integers n and m (where n <= m).	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
Prove that if person A has degree 3 and person B has degree 4, then person A's age is greater than or equal to person B's age	This implication can be proved using QF_UF or QF_LIA.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
Prove that there exists an integer x such that x^2 = 5 and x^4 + 2x^2 - 1	Use QF_UF to reason about the existence of a solution and then use QLIA to solve for x.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that two people are acquaintances if they have met at least once	(set-logic QF_UF) (declare-const person1 :: int) (declare-const person2 :: int) (assert (person1 = person2)) (check-sat)	"(declare-const at Int)
(declare-const if Int)
(assert (and (<= 1 at) (<= at 10)))
(assert (and (<= 1 if) (<= if 10)))
(assert (distinct at if))
(check-sat)"
Given the social network of individuals with attributes 'name' and 'relationship_type', find the maximum number of people who are directly related to each other.	This can be solved using QF_UF or QF_LIA, where we express a relationship between two individuals as an equivalence relation. We then use the fact that the size of an equivalence relation is equal to the number of pairs of distinct elements in the set. This allows us to compute the maximum number of people who are directly related to each other.	"(declare-const of_friend_to Bool)
(declare-const to_friend_of Bool)
(assert (= of_friend_to to_friend_of))
(assert (= true of_friend_to))
(check-sat)"
Prove that there exists an integer x such that x + 1 = 2 * x	Use QF_UF and set-logic to prove the statement	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that a person can go to exactly two different cities if they travel between cities in different countries.	Using the QF_UF model with a set of cities and countries, prove that the person's travel history is consistent.	"(declare-const a Int)
(declare-const can Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 can) (<= can 10)))
(assert (distinct a can))
(check-sat)"
Prove that a person is either married or single.	(set-of-values x:Person; (set-of-assertions x:-single | x:-married))	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Use QF_LIA to express the relationship between friends and their relationships with others.	Use QF_UF with a set of 'not' constraints to express the relationship between individuals.	
Find all triples (a, b, c) where a has degree 2 in graph G and b is adjacent to both a and c	Use QF_LIA constraints to enforce the properties of the relationships.	"(declare-const G Int)
(declare-const a Int)
(assert (and (<= 1 G) (<= G 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct G a))
(check-sat)"
Find all pairs of distinct people in a university with exactly one common friend.	Use QF_UF to model this relationship and QLIA to restrict the number of friends each person can have.	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (= a_friend_in in_friend_a))
(assert (= true a_friend_in))
(check-sat)"
The set of all prime numbers less than or equal to 100	{(set-logic QF_UF) {(declare-const P UU)   assert (forall (x UU) ( eg ((xor x P) (xor P x))))	"(declare-const of Int)
(declare-const or Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 or) (<= or 10)))
(assert (distinct of or))
(check-sat)"
The given social relationship is valid.	Use QF_UF and set-logic QF_UF to ensure validity of constraints.	
Prove that every person is related to themselves.	Use QF_UF to assert that each person is connected to at least one other person, and then use QF_LIA to conclude that there are no cycles in the graph.	"(declare-const is Int)
(declare-const to Int)
(assert (and (<= 1 is) (<= is 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct is to))
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 0	Use QF_UF and set-logic to reason about the existence of solutions to this equation.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that if person A is friends with person B, and person B is friends with person C, then person A is friends with person C	Use QF_UF and QF_LIA constraints to derive the desired implication. Use the following assumptions: (A,B) and (B,C), and (C,A).	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Prove that for all integers n >= 5, n^2 + n - 13 > 0	The following statements are true:  - set-logic QF_UF - set-logic QF_LIA - declare-const n_ int - declare-variable x int - assert (x = 5) - assert (x^2 + x - 13 > 0)	"(assert true)
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 4x and 2x > 0	Using QF_UF with the set of variables {x} and the constraints from the problem statement, we can derive the following expression: 2 * (x^2 - 4) = 0. Solving for x, we get x = 16. Therefore, there exists an integer solution to the equation.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The friends of Alice are married, but Bob is not	To ensure this is true, we need to assert that (set-of-people x y) != (set-of-people x z)	"(declare-const is_friend_of Bool)
(declare-const of_friend_is Bool)
(assert (not is_friend_of))
(assert (not of_friend_is))
(check-sat)"
Prove that there exists an integer x such that x^2 + 4x - 3 = 0	To prove this equation has a solution, we can use the fact that it is a quadratic equation with two roots. We can also use the method of completing the square to simplify the equation.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that a person is not a friend of themselves	Use   to separate the reasoning into two parts: first, prove that an individual is friends with another if they have at least one movie in common, and second, prove the converse	"(declare-const a_friend_is Bool)
(declare-const is_friend_a Bool)
(assert (not a_friend_is))
(assert (not is_friend_a))
(check-sat)"
Prove that there exists an integer x such that 2*x + 3 >= 0	To prove this, we can use the QF_UF logic with 2*u + 3 <= -u for u >= 0. This is because for any non-negative integer u, 2*u + 3 will always be greater than or equal to 1, satisfying the condition.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The following social constraint is invalid: \nIt states that Alice and Bob are friends when they do not have a mutual friend, which is a contradiction.	\nTo resolve this conflict, we can add constraints to ensure that if Alice is friends with X, then X must also be friends with Alice. This can be achieved using the following QF_UF clause: (\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n)	"(declare-const a_friend_do Bool)
(declare-const do_friend_a Bool)
(assert (not a_friend_do))
(assert (not do_friend_a))
(check-sat)"
Prove that there does not exist an ordered pair of integers (x, y) such that x = 2 and y = 4	This statement can be proven using the QF_UF rule and the fact that x cannot be both even and odd.	"(declare-const an Int)
(declare-const of Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct an of))
(check-sat)"
Prove that there exists an integer x such that x + 1 = 2*x	"\begin{align*} (\exists x (\forall y (y < x \ 2*y == x+y))) &
ightarrow ((\exists z (z >= 0 \ z != -1)))) \end{align*}"	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Satisfying the social constraint: No two people in the same group.	Use QF_UF or QF_LIA to ensure that each person is in a unique set of groups.	"(declare-const No Int)
(declare-const in Int)
(assert (and (<= 1 No) (<= No 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct No in))
(check-sat)"
Prove that there exists an integer x such that 2x + 1 > 0	To prove this, we can use the QF_LIA solver with the following constraints: (set-logic QF_UF) (declare-const x Int) (assert (>= 0 (1 + 2 * x)))	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
A university has two classes: History and English.	The class that starts later must be the one with more students	"(declare-const A Int)
(assert (and (<= 1 A) (<= A 3)))
(check-sat)"
Prove that if Alice and Bob both have a pet cat, then they are friends.	\begin{qf uf} \setof(x:person) (x ~ x.pet.cat) & (x ~ y.pet.cat) \declare-relation(p,q:friend)(p.y ~ q.y) \check-sat	"(declare-const a_friend_if Bool)
(declare-const if_friend_a Bool)
(assert (= a_friend_if if_friend_a))
(assert (= true a_friend_if))
(check-sat)"
PREDicates and Atomic Variables: Prove that there exists an integer x such that x^2 = 0	The solution to this problem can be proven using QF_UF, given the constraints (set-logic QF_UF) and (declare-const x :: int). The key insight is to recognize that if there does not exist an integer x such that x^2 = 0, then we must have a contradiction. This would mean that either x or x+1 cannot be zero, which implies that x is not an integer, leading to a contradiction.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	Use QF_UF and QF_LIA axioms to prove that a valid schedule can be constructed from a given set of jobs with different durations.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the linear programming relaxation of the knapsack problem	Using QF_UF with an interval representation to solve this linear program	"(assert true)
(check-sat)"
Scheduling Problem	Integer linear programming to optimize task allocation on a machine with multiple processing units.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	# Use QF_UF and QF_LIA rules with simple integer constraints to model the scheduling problem. The SMT-LIB program should include the following constraints: # A must be executed by processor C1 P_A <= P_C1 * 2; # Assign tasks to processors based on their capabilities # B must be executed by processor C2 P_B <= P_C2 * 3; # Assign tasks to processors based on their capabilities # Check if the assignment satisfies all constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfies the linear programming relaxation of the flow network of scheduling problem with three nodes and four edges, where each edge has two capacities.	This problem can be solved using the flow network solver of SMT-LIB.	"(assert true)
(check-sat)"
Scheduling Problem	Construct a scheduling problem with two tasks that cannot be scheduled together.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling: max-work-hours	assert (set-logic QF_UF) and (declare-const hours 1: integer) and (declare-const total_hours 0: integer) and (assert (=, total_hours, sumhours(hours))) and (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA with simple integer and boolean constraints to model a scheduling algorithm that assigns jobs to machines based on their processing time and machine capacity.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF with integer variables	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF to solve this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
\(\setoflucore uf) \+ (\declareconst i32 x 10)	\(\checksat (\assert true) \| (\checksat false))	"(declare-const i32 Int)
(declare-const uf Int)
(assert (and (<= 1 i32) (<= i32 10)))
(assert (and (<= 1 uf) (<= uf 10)))
(assert (distinct i32 uf))
(check-sat)"
Scheduling Problem	Use QF_UF to model scheduling as a maximization problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
{'type': 'scheduling', 'domain': 'transportation'}	{'type': 'explanation', 'domain': 'scheduling'}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Check if this scheduling problem is solvable in practice.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a scheduling problem	{'approach': 'brute-force', 'search': 'depth-first'}	"(assert true)
(check-sat)"
\(declare-const x 0: Int\); (set-logic QF_UF)\n(declare-const y 1: Boolean; (assert \(x = true; \))\n(check-sat)	Using the properties of equality and union to derive new constraints	"(declare-const n Int)
(declare-const x Int)
(assert (and (<= 1 n) (<= n 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct n x))
(check-sat)"
Scheduling Problem	Use QF_LIA and set-logic QF_UF to generate constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling problem to minimize make times and meet deadlines	Use QF_UF and QF_LIA rules to analyze constraints on machine times and resource utilization.	"(assert true)
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to enforce valid scheduling rules	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF with linear constraints to model a scheduling problem where tasks are assigned to time slots and their start times must be within a certain range.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to model the scheduling of tasks on a shared resource.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA SMT-LIB rules to derive a valid scheduling plan.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to generate valid constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Minimize Latency	Use QF_LIA and set-logic QF_UF to ensure validity and correctness.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find an assignment that satisfies all constraints	Using QF_UF and QF_LIA, derive valid integer constraints to satisfy the scheduling problem.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_LIA to reason about scheduling constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Maximize the number of customers served while minimizing idle time	Use QF_UF and QF_LIA rules to model the scheduling problem, including constraints on customer arrival and departure times, as well as idle time.	"(assert true)
(check-sat)"
Scheduling Problem: Find an optimal assignment of jobs to machines in a factory	Use QF_UF and QF_LIA rules to solve this scheduling problem, ensuring that all constraints are satisfied exactly.	"(declare-const a_of Bool)
(declare-const a_to Bool)
(declare-const an_of Bool)
(declare-const an_to Bool)
(declare-const in_of Bool)
(declare-const in_to Bool)
(assert (= (+
  (ite a_of 1 0)
  (ite an_of 1 0)
  (ite in_of 1 0)
) 1))
(assert (= (+
  (ite a_to 1 0)
  (ite an_to 1 0)
  (ite in_to 1 0)
) 1))
(assert (<= (+
  (ite a_of 1 0)
  (ite a_to 1 0)
) 1))
(assert (<= (+
  (ite an_of 1 0)
  (ite an_to 1 0)
) 1))
(assert (<= (+
  (ite in_of 1 0)
  (ite in_to 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to solve the scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
(set-logic QF_UF  (declare-const x int)  (declare-const y int)  (assert (>= x 0)    (<= y 10) )	This is a problem that will be solved using SMT-LIB.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Scheduling Problem	Formally specify scheduling constraints using QF_UF and QF_LIA.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the parity of three signals in a 3D system	Use QF_UF with equality constraints and set-logic QF_LIA to enforce non-increasing order.	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Satisfy the following scheduling constraint: Minimize make_time(1, 2) + make_time(3, 4)	Use QF_UF and QF_LIA constraints to ensure that make_time(1, 2) <= make_time(3, 4).	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to prove the satisfiability of the scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA clauses to model the scheduling of tasks on a single processor.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a scheduling conflict on multiple servers	Using QF_UF and QF_LIA to ensure tight coupling between tasks and servers, while respecting resource constraints.	"(declare-const a Int)
(declare-const on Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 on) (<= on 10)))
(assert (distinct a on))
(check-sat)"
Scheduling Problem: Resource Allocation	Use QF_UF and QF_LIA constraints to model resource allocation in a scheduling problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF to define sets of variables and use QF_LIA to check consistency.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Maximize Productivity with Limited Time	This problem can be solved using QF_UF and QF_LIA constraints to ensure that the production of products does not exceed the available time.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	{'constraints': ['(set-logic QF_UF)', '(declare-const X 1)', '(declare-const Y 2)', '(assert (<= X 10))'], 'clauses': ['(check-sat)']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling problem with no conflicts	Use QF_LIA to model this scheduling problem without conflicts.	"(assert true)
(check-sat)"
Scheduling Problem	This problem uses QF_UF and QF_LIA formulas to model a real-time system.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and check-sat to prove the validity of the program, which asserts that there exists an integer solution to the scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	{'constraint_type': 'integer_lower_bound', 'variables': ['x', 'y'], 'constraints': ['(set-logic QF_UF)', '(declare-const x int)', '(declare-const y int)', '(assert (>= x 0))', '(assert (<= y 10))']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Integer Constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the following linear programming relaxation of the 8-hour workday problem with additional constraints	Using QF_UF and QF_LIA, derive the solution to a system of linear equations representing the 8-hour workday problem, where employees are only allowed to work up to 40 hours per week.	"(assert true)
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to prove validity	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Maximize Customer Satisfaction	Use QF_UF or QF_LIA to generate a valid model and check its satisfiability.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Formulate a valid schedule that satisfies all constraints and meets the deadline.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	{'type': 'clausal', 'constraints': ['(set-logic QF_UF)', '(declare-const x Int)', '(declare-const y Bool)', '(assert (not (= x 0)))']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to model this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Find all valid solutions to the following system of linear equations with two variables.	Use QF_LIA and integer constraints to solve this system.	"(declare-const of Int)
(declare-const to Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct of to))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to ensure valid constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling: maximize {x, y} where x is the number of customers served in the first hour and y is the number of customers served in the last hour	The goal is to maximize the total number of customers served within a fixed time frame. This can be achieved by prioritizing customers based on their arrival times.	"(declare-const in Int)
(declare-const is Int)
(assert (and (<= 1 in) (<= in 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct in is))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA constraints to model a scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	To solve the scheduling problem, we need to find an assignment of tasks to machines that satisfies all constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find the optimal assignment of tasks to machines	Use QF_UF and QF_LIA constraints to enforce valid scheduling rules, and check for satisfiability using QBF or DPLL-SAT.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA to represent the scheduling problem as a logic formula	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA solvers to reason about valid schedules.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following scheduling constraint using QF_UF and basic arithmetic constraints.	Use the following set of rules to derive the solution: (set-logic QF_UF) (declare-const X < 10) (assert X > 0) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA constraints to ensure fairness in resource allocation.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given a set of jobs with deadlines and resource requirements, determine the optimal assignment of jobs to machines without violating any deadlines or resource constraints.	Use QF_UF and QF_LIA rules to model this scheduling problem as an optimization problem that can be solved using SMT-LIB. Include assertions for machine availability and job deadlines.	"(declare-const a_to Bool)
(declare-const of_to Bool)
(declare-const or_to Bool)
(assert (= (+
  (ite a_to 1 0)
  (ite of_to 1 0)
  (ite or_to 1 0)
) 1))
(assert (<= (+
  (ite a_to 1 0)
) 1))
(assert (<= (+
  (ite of_to 1 0)
) 1))
(assert (<= (+
  (ite or_to 1 0)
) 1))
(check-sat)"
Scheduling Problem: Minimize Makespan	Given a set of tasks with start times and durations, find the order that minimizes the total makespan.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying an integer linear equation	(= (int x) ( (1 + 2)  = 3))	"(assert true)
(check-sat)"
scheduling_problem	derive_satisfiability_from_just_the_constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	(set-logic QF_UF)  define-variables   x: integer   y: boolean,   z: real  (assert (not (= x 0))) (assert (not (= y true))) (assert (= z 1.5))	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find the minimum number of machines required to schedule tasks with maximum utilization	This problem can be solved using First-Order Logic (FOL) constraints in SMT-LIB. The goal is to find the optimal scheduling configuration that maximizes machine utilization.	"(declare-const of Int)
(assert (and (<= 1 of) (<= of 3)))
(declare-const to Int)
(assert (and (<= 1 to) (<= to 3)))
(assert (distinct of to))
(check-sat)"
Scheduling Problem	{'type': 'Propositional Reasoning', 'reason': 'Using QF_UF with integer constraints and checking satisfiability'}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	Use QF_UF with set of variables and universal quantification to model a scheduling problem where tasks have start and end times.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Generate an exact solution for the following linear programming relaxation of the 5-hour delivery problem	Use QF_UF and QF_LIA constraints to model integer variables representing hours worked by drivers, and use assert statements to enforce non-negativity.	"(declare-const an Int)
(declare-const of Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct an of))
(check-sat)"
\(set-logic QF_UF \n\n(declare-const X true \n  \n  (assert Y = 1) \n  (assert Z < 5))\n	This is a valid SMT-LIB program that includes the necessary logic for model checking and satisfiability.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find optimal assignment of tasks to machines	Use QF_UF and QF_LIA solvers with simple constraints, e.g., (set-logic QF_UF)   (declare-const machine <1..4>   (declare-const task <1..5>))   (assert (>= 0 (size of task)))	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to prove that it is NP-complete.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA to enforce valid scheduling constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA to model the scheduling problem	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find the optimal assignment of tasks to machines	Use QF_UF and QF_LIA constraints to reason about machine resource allocation.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to enforce precedence constraints on tasks	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF to model the scheduling of tasks with deadlines and resource constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA constraints to model this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Determine if it is possible to assign all tasks to employees within a given time frame.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to model scheduling problems.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF with valid constraints to solve this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a scheduling constraint	Use QF_UF and QF_LIA constraints to model the problem	"(assert true)
(check-sat)"
Modeling scheduling conflicts in a production line	\n\n\n(\n  \n    \n    (\n      \n      \n      \n      \n      \n      \n      \n    ),\n\n  \n\n  (\n    \n    (\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    )\n\n  \n)	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Scheduling Problem	Using QF_UF and QF_LIA rules to reason about scheduling constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	This problem requires the use of QF_UF and QF_LIA rules to reason about scheduling constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Using QF_UF and set-logic to model scheduling problems with multiple tasks and resource constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	Use QF_UF rules to model the scheduling of tasks with dependencies.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following integer linear program: P = { x, y | x + y <= 5, x >= 0, y >= 0 }	Use QF_UF and QF_LIA constraints to ensure satisfiability, then check for valid solutions.	"(declare-const P Int)
(declare-const x Int)
(assert (and (<= 1 P) (<= P 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct P x))
(check-sat)"
Scheduling Problem: Given two tasks t1 and t2, assign task t1 to machine M1 and task t2 to machine M2 if both machines are not busy	Propositional Reasoner	"(declare-const M1_t1 Bool)
(declare-const M1_t2 Bool)
(declare-const M2_t1 Bool)
(declare-const M2_t2 Bool)
(declare-const if_t1 Bool)
(declare-const if_t2 Bool)
(assert (= (+
  (ite M1_t1 1 0)
  (ite M2_t1 1 0)
  (ite if_t1 1 0)
) 1))
(assert (= (+
  (ite M1_t2 1 0)
  (ite M2_t2 1 0)
  (ite if_t2 1 0)
) 1))
(assert (<= (+
  (ite M1_t1 1 0)
  (ite M1_t2 1 0)
) 1))
(assert (<= (+
  (ite M2_t1 1 0)
  (ite M2_t2 1 0)
) 1))
(assert (<= (+
  (ite if_t1 1 0)
  (ite if_t2 1 0)
) 1))
(check-sat)"
scheduling:make-schedule	show that it is impossible to schedule two tasks with different start times and one task can be delayed by any amount of time without violating the constraints.	"(declare-const X Int)
(assert (and (<= 1 X) (<= X 3)))
(declare-const Y Int)
(assert (and (<= 1 Y) (<= Y 3)))
(declare-const Z Int)
(assert (and (<= 1 Z) (<= Z 3)))
(assert (distinct X Y Z))
(check-sat)"
{'solver': 'smt2', 'input': '\\{(\\x0 \\y -5) + (\\z + 10) <= 15; \\x1 = (\\x3 + 2) * (\\x4 - 3); \\z = 12; \\v = true; \\w = false;\\n\\(\\x0 < 0 \\n\\n(\\y - 5) * (\\z + 10) <= 15 \\n\\n(\\x1 = (\\x3 + 2) * (\\x4 - 3))\\n\\n(check-sat)'}	{'solver': 'smt2', 'input': '\\{(\\x0 \\y -5) + (\\z + 10) <= 15; \\x1 = (\\x3 + 2) * (\\x4 - 3); \\z = 12; \\v = true; \\w = false;\\n\\(\\x0 < 0 \\n\\n(\\y - 5) * (\\z + 10) <= 15 \\n\\n(\\x1 = (\\x3 + 2) * (\\x4 - 3))\\n\\n(check-sat)'}	"(declare-const n Int)
(declare-const v Int)
(assert (and (<= 1 n) (<= n 10)))
(assert (and (<= 1 v) (<= v 10)))
(assert (distinct n v))
(check-sat)"
Satisfying the constraint that all tasks in a scheduling problem have at least one feasible solution	Use QF_UF and QF_LIA axioms to ensure feasibility, then use modus ponens and contradiction elimination to prove satisfiability.	"(declare-const a Int)
(declare-const at Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 at) (<= at 10)))
(assert (distinct a at))
(check-sat)"
Scheduling Problem: Find the optimal assignment of tasks to machines in a factory	Use QF_UF or QF_LIA constraints and simple integer or boolean constraints to model the problem.	"(declare-const a_to Bool)
(declare-const in_to Bool)
(declare-const of_to Bool)
(assert (= (+
  (ite a_to 1 0)
  (ite in_to 1 0)
  (ite of_to 1 0)
) 1))
(assert (<= (+
  (ite a_to 1 0)
) 1))
(assert (<= (+
  (ite in_to 1 0)
) 1))
(assert (<= (+
  (ite of_to 1 0)
) 1))
(check-sat)"
Satisfy the following system of linear equations with two variables x and y	Use the QF_UF rule to introduce new variables, then use QF_LIA to eliminate them, and finally assert the truth of the resulting equation.	"(declare-const of Int)
(declare-const x Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct of x))
(check-sat)"
Satisfy the constraints of a finite automaton	Use QF_UF and QF_LIA rules to express the constraints of the automaton	"(declare-const a Int)
(declare-const of Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct a of))
(check-sat)"
Satisfy the following linear equations using QF_UF and QF_LIA rules	Use simple integer constraints to represent the relationships between variables.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following constraint using QF_UF and QF_LIA	Use simple integer constraints and   newlines to separate logical statements	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Using QF_UF and QF_LIA rules to derive a valid scheduling plan from a set of constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Resource Allocation Problem	Use QF_UF to model the allocation of resources.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation: Assigning Resources to Tasks	{'variables': ['x', 'y'], 'constraints': ['(set-logic QF_UF)', '(declare-const x Integer)', '(declare-const y Boolean)', '(assert x >= 0)'], 'solver': 'SMT-LIB'}	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA axioms to model this problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Prove that there exists an integer x such that x = 1 and (x + 2) mod 3 = 0	Using the properties of modular arithmetic, we can show that this equation is true for all values of x.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Resource Allocation	Use QF_UF or QF_LIA with simple integer and boolean constraints to solve a resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to ensure valid integer solutions.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
{'name': 'Resource Allocation', 'description': 'A resource allocation problem in a cloud computing environment'}	Using QF_UF and set-logic, we can model this problem as follows:  set-logic QF_UF; assert (declare-const x:integer >= 0); assert (declare-const y:integer > 0); check-sat;	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation: Minimize Number of Server Assignments	(set-logic QF_UF) (declare-const x : integer) (assert (x > 0)) (check-sat)	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF to enforce unit-of-formula equality	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: 3 resources available, 4 requests to allocate	Use QF_UF and QF_LIA constraints to ensure integer solutions are found	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF logic to model this resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA solvers to find an optimal assignment of resources to tasks.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model a resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to define a set of constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	To allocate resources to tasks, we need to minimize waste and maximize efficiency.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use of QF_UF or QF_LIA constraints to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA formulas to model this resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
(set-logic QF_UF (declare-const x int : 1) (assert (equivalent? (add 2 x) (add 5 x)))	Using the properties of arithmetic operations and addition, we can deduce that if (add 2 x) = (add 5 x), then (add 3 x) must be true.	"(assert true)
(check-sat)"
Resource allocation problem	Satisfiability Reasoning and Computation System	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to processes	Using QF_UF and QF_LIA, derive that there exists a valid assignment of resources to each process such that the total resource usage is non-negative.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to ensure fairness in resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: 5 machines, 3 software licenses	Using QF_UF with constraints on machine availability and license usage.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA to model resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to reason about resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to processes	Use QF_UF and QF_LIA constraints to model resource allocation, considering bounds on resources and process demands.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Using QF_UF with set-logic and declare-const constraints to model the allocation of resources between two processes.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation	Using QF_UF with linear constraints to optimize resource usage.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Allocate resources to tasks with minimum latency	{'variables': [{'name': 'latency', 'type': 'int'}], 'assumptions': ['(set-logic QF_UF)', '(declare-const task1-latency 10)', '(declare-const task2-latency 5)'], 'conclusions': ['(assert (leq task1-latency task2-latency 5))']}	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA logical frameworks to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
{'name': 'Resource Allocation', 'description': 'A problem of resource allocation in a computer system', 'satisfiability': False}	{'rule1': '(set-logic QF_UF)', 'rule2': '(declare-const x integer)', 'rule3': '(declare-const y boolean)'}	"(declare-const A_of Bool)
(declare-const a_of Bool)
(declare-const in_of Bool)
(assert (= (+
  (ite A_of 1 0)
  (ite a_of 1 0)
  (ite in_of 1 0)
) 1))
(assert (<= (+
  (ite A_of 1 0)
) 1))
(assert (<= (+
  (ite a_of 1 0)
) 1))
(assert (<= (+
  (ite in_of 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Using QF_UF and set-logic to model resource allocation problem	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
(set-logic QF_UF (declare-const x y Z)	This is a valid program, and it will always find a solution.	"(declare-const Z Int)
(declare-const x Int)
(assert (and (<= 1 Z) (<= Z 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct Z x))
(check-sat)"
Resource allocation: Assigning resources to tasks	Use QF_UF and QF_LIA rules to reason about resource availability	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation	Use QF_UF or QF_LIA to specify the resource constraints and then assert them using set-logic.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to model resource allocation problems, ensuring that resources are allocated in an optimal manner.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF to find valid assignments that satisfy all constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Using QF_UF with set of variables and assertions to solve a resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
\(set-logic QF_UF\) \(declare-const x_0 bool\) \(assert (x_0 = true)\)	\(check-sat\)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to model resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA constraints to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA solvers to find an optimal assignment of resources.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA axioms to reason about resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA quantifiers to model the problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to tasks	Use QF_UF and QF_LIA rules to constrain resource allocation.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation: Minimize the number of machines used in the data center	Use QF_UF and QF_LIA to model this problem, and ensure that it includes  - (set-logic QF_UF) or QF_LIA. Use simple integer constraints for machine utilization.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation: Assigning resources to tasks	Using QF_UF and QF_LIA constraints to ensure fairness in resource allocation, while also ensuring that the system is satisfiable.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Prove that it is possible to allocate resources such that all devices are used and no device is idle	(set-logic QF_UF) # Define the universe of discourse as integers from 0 to N-1 (where N is the number of devices)  (set-logic QF_UF)(declare-const N: int)  (assert (>= N 2))  (check-sat)	"(declare-const is_to Bool)
(declare-const it_to Bool)
(declare-const no_to Bool)
(assert (= (+
  (ite is_to 1 0)
  (ite it_to 1 0)
  (ite no_to 1 0)
) 1))
(assert (<= (+
  (ite is_to 1 0)
) 1))
(assert (<= (+
  (ite it_to 1 0)
) 1))
(assert (<= (+
  (ite no_to 1 0)
) 1))
(check-sat)"
Resource Allocation: Assigning Resources to Jobs	Use QF_UF and QF_LIA constraints, and ensure that all constraints are linear and integer/boolean.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Integer Variables with Bounds	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to servers in a cloud-based data center	Use QF_UF and QF_LIA constraints to model the resource allocation decision.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and set-logic to model resource allocation with multiple constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA logic to reason about resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Using QF_UF and QF_LIA rules, derive a valid solution that maximizes resource utilization.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Minimize the number of printers used	Using QF_UF and QF_LIA constraints, prove that it is not possible to allocate enough printers to satisfy all user requests without exceeding the available capacity.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	To ensure efficient resource allocation, we use the QF_UF and QF_LIA rules.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA theory to reason about resource constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use the QF_UF and QF_LIA logics to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
{'smtplib': 'int(x) <= x + 1'}	Satisfiability with constraints (set-logic QF_UF; assert x > 0; check-sat)	"(assert true)
(check-sat)"
Resource allocation problem	This problem involves allocating resources to tasks with different priorities and constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	To allocate resources efficiently, we need to minimize waste and maximize utilization of available resources.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA to represent resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA rules to model resource allocation problems	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	{'type': 'model-checking', 'description': 'Verify that a resource allocation model satisfies QF_UF and QF_LIA constraints.'}	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use set-logic QF_UF and declare-const to specify resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA rules to formulate a valid resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA solvers, and assert that the program produces exactly one solution.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Maximize production of 5 units while minimizing waste	Using QF_LIA and set-logic QF_UF, the following constraints can be derived.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
{'input': '\\(set-logic QF_UF\\) \\n \\n (declare-const x Int\\n \\n assert (x = 0)\n \\n check-sat)'}	This SMT-LIB program checks if a number is zero	"(declare-const n Int)
(declare-const x Int)
(assert (and (<= 1 n) (<= n 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct n x))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA to model this problem and ensure validity.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: assigning 10 units of CPU to process 1 and 5 units to process 2	Use QF_UF and QF_LIA constraints to model the resource allocation problem. Ensure that the total number of units allocated is exactly 15.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation: 3 cars and 4 passengers	Use QF_UF and set-logic to ensure that each passenger has at least one seat	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation optimization	Use QF_UF and QF_LIA constraints to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation	Use QF_UF and assert/declare/check-sat to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	(set-logic QF_UF) (declare-const x (int)) (assert (not (= 2, 0))) (check-sat)	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA to specify the resource allocation model.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Ensure that the minimum number of units required to satisfy all resource constraints is met	Use QF_UF and QF_LIA to reason about the satisfiability of the program, and check for validity using SMT solver.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF with assert statements to model this problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA rules to ensure feasibility.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: 5 agents, each with capacity 2 and deadline 10	Use QF_UF and QF_LIA rules to prove existence of a solution that satisfies all constraints	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	 - {set-logic QF_UF         assert (2 > 0)}	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to solve this optimization problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA solvers with simple integer constraints to model this problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Ensure that the maximum number of employees is allocated to each department	Use QF_UF or QF_LIA quantifier, and simple integer constraints (e.g., <=) to represent the relationship between departments and employees.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A woman has two coins that total 30 cents. One coin is not a nickel, and one coin is not a quarter. What type of coin are they?	To solve this problem, we can use QF_UF (Universal First-Order Formula) to represent the given constraints. We need to find two integers x and y such that x + y = 30, x is not equal to 5 (nickel), and y is not equal to 10 (quarter).	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
A farmer has a rectangular field with integer coordinates in pixels, and she wants to know if it's possible to place a row of n x m flowers on this field such that no two flowers are adjacent.	This problem can be solved using QF_UF (Unfolding Formulas) or QF_LIA (Linear Arithmetic Inequality).	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
Solve for x: 2*x + 5 = 11	Use QF_LIA and set-logic to model this equation as an equality of integer constraints.	"(assert true)
(check-sat)"
A farmer has a field with 3 rows and 4 columns. Each cell can hold either an integer from 1 to 10, inclusive.	{   (set-logic QF_UF)   (declare-const row1 int   row2 int   row3 int),   (declare-const col1 int   col2 int   col3 int),   (assert (>= row1 1)            (<= row1 10))   (assert (>= row2 1)            (<= row2 10))   (assert (>= col1 1)            (<= col1 4))   (assert (>= col2 1)            (<= col2 3))   (assert (>= col3 1)            (<= col3 4))   (check-sat)}	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
3+2=5	Using QF_LIA, we can assert that the sum of two integers less than or equal to 10 is greater than 1 and less than or equal to 15.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Solve for x: 2*x + 5 = 11	Use QF_LIA with constraints: x >= 0, 2x <= 6	"(assert true)
(check-sat)"
(set-logic QF_UF (declare-const x 1) (assert (>= x 0)) (check-sat)	This is a simple satisfiability problem, where we need to find an assignment of values to the variable x such that all constraints are satisfied.	"(assert true)
(check-sat)"
Solve the following logic puzzle: A bat and a ball together cost $1.10. The bat costs $1.00 more than the ball. If you have 5 times as many bats as balls, how much will you pay?	Let B represent the number of balls and B+ represent the number of bats. From the first equation, we get: B + (B+1) = 10. This simplifies to 2B + 1 = 10, or B = 4.5. Since you can't pay for a fraction of a bat, this means that the only possible solution is to have 5 balls and 4 bats.	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
The Five Switches	Use QF_LIA and set-logic QF_UF to prove that there is exactly one way to program a computer to switch between five lights on, one at a time, while the lights are off.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that there exists an integer x such that x^2 + x - 5 = 0	Use QF_UF and set-logic to prove the existence of a solution, and use check-sat to find it.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The Five Houses	Using set-logic QF_UF and quantifiers, prove that there exists a house on each row such that at least one of its doors is open.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF and QF_LIA to prove that there exists a number between 1 and 3 that has exactly one switch on.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	(set-logic QF_UF) (declare-const x true) (declare-const y false) (declare-const z true)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Five Houses Problem	To solve this problem, we need to use the QF_UF and QF_LIA SMT-LIB rules.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A man, a plan, a canal, Panama!	(set-logic QF_UF   (declare-const X 0 5)   (declare-const Y 5 10))(assert (>= X 1) (<= Y 4))   (check-sat)	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Three Switches	Use QF_UF and assert statements to prove that there is a unique solution to this puzzle.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Five Houses Problem	To solve this puzzle, we need to find a valid assignment of integers from 1 to 5 to the five houses such that no two adjacent houses have more than one occupant.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF to represent three switches, and assert that they are either all on or none of them is on.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has 'a' apples and 'b' bananas in his orchard. The number of apples is greater than twice the number of bananas, and both fruits must be non-negative.	The constraints are: (set-logic QF_UF) (declare-const a int > 0) (declare-const b int > 0) (assert (a > 2 * b) (check-sat)	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
A farmer has three fields: A, B, and C. Field A can hold values 0 through 9. Field B can hold values -1 through 1. Field C can only hold the number 5.	The farmer needs to ensure that field C holds a value of either 0 or 4. If field A holds any other value, then field C must be 0. Otherwise, if field A is 5 or greater, then field B must be -1.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
(set-logic QF_UF   (declare-const x 9)   (declare-const y 10)   assert (>= x 0)   assert (<= y 100)   check-sat)	Satisfiability isomorphism using UFL constraints and linear integer programming.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Satisfy the following set of constraints on the variable x.	Use the quantifier 'for all' to generalize over all natural numbers n.	"(declare-const of Int)
(declare-const on Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 on) (<= on 10)))
(assert (distinct of on))
(check-sat)"
A farmer has 5 sheep and 3 goats. How many animals does she have?	(set-logic QF_UF  (declare-const A int  (A = 5)  (G int  (G = 3)))  (assert < A + G > 0))	"(assert true)
(check-sat)"
The Set of Twin Primes	- Prove that there do not exist two prime numbers p and q such that pq = 2.	"(assert true)
(check-sat)"
A 5-person committee needs to decide on a project leader.	Use QF_UF and assert constraints like (equal (= 1 2)) or (not (equal (= 3 4))).	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
Solve for x: 2x + 5 = 11	Use QF_UF and set-logic (maximize) to find an optimal solution.	"(assert true)
(check-sat)"
The Five Houses Problem	To solve this problem, we need to assign numbers to each of the five houses such that each house is assigned a number between 1 and 5 (inclusive), and no two adjacent houses have the same number.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use the rules provided by the problem to construct a valid solution.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Five Houses Puzzle	To solve this puzzle, we need to find a valid assignment of integers from 1 to 5 to the five houses such that each house is either occupied by an integer or not.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer wants to optimize his irrigation system to minimize water waste.	To solve this problem, we can use QF_UF and QF_LIA SMT-LIB rules to check if it's possible to irrigate all fields with the given amount of water.	"(declare-const A Int)
(declare-const to Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct A to))
(check-sat)"
Solve the following puzzle:  3 x + y = 6, 2x - y = 4.	(set-logic QF_UF) (declare-const x Int) (declare-const y Int) (assert (>= x 0) (assert (>= y 0)) (verify-sat)	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
A person is standing next to a box with an unknown weight. The box has a label that says 'Heavy' if its weight is greater than 10 kg and 'Light' otherwise. The person is holding the box, but they don't know which side it's on. What can be said about the box?	Using QF_UF, we can assert that the box is either Heavy or Light.	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
There are three switches: hot, cold and off.  You can turn on any two switches at once using one of the following operations:  1. Turn on switch A and then off switch B.  2. Turn on switch C and then off switch D.  3. Turn on switch B and then off switch D.  4. Turn on switch A and then turn on switch C.  5. Turn on switch C and then turn on switch D.	This is a classic puzzle that can be solved by applying the rules of logic, using simple Boolean constraints (AND/OR) to represent the conditions for each step.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A man, a plan, a canal, Panama!	(set-logic QF_UF   (declare-const X 0 5)   assert (<= X 0)   check-sat)	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Five Houses Puzzle	To solve this puzzle, we need to use QF_UF constraints to represent the relationships between the houses and their occupants.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF to create a function symbol and apply it to three variables in a predicate.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following statement	Use the QF_UF and QF_LIA rules to generate a model that satisfies this statement.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a linear equation with two variables	Use QF_UF to ensure equality and QF_LIA to allow variable combination.	"(assert true)
(check-sat)"
Find integers x such that x^2 + 1 = x+3	This equation can be solved using QF_UF with the following constraints: (set-logic QF_UF) and (declare-const x integer)	"(assert true)
(check-sat)"
Prove that there exists an integer x such that x^2 + 4x - 7 = 0 and x is even	To prove this, we can use the QF_UF rules to find a model for the equation x^2 + 4x - 7 = 0. We can then analyze the models to determine which ones satisfy the condition that x is even.	"(declare-const an Int)
(declare-const is Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct an is))
(check-sat)"
(set-logic QF_UF (declare-const x 1 x < 5) (declare-const y 2 y = x + 3) assert (>= y 4)	To prove that the assertion is true, we can use a model with x >= 0 and y > 0.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
(set-logic QF_UF) (declare-const x 1) (assert (not (= x 0))) (check-sat)	To prove that x is not equal to 0, we can use the property of equality that if a = b then a = b.	"(assert true)
(check-sat)"
(set-logic QF_UF  define-const X 0  assert (<= X 5)  check-sat	This puzzle requires the solver to find a value for X such that it is less than or equal to 5.	"(assert true)
(check-sat)"
A farmer has a field that is 100 meters long and 50 meters wide. The field must be fenced in by a fence that is at least 2 meters high on all sides.	The farmer can use the following constraints to solve this problem:  - (declare-const field-width 50 :integer) - (declare-const field-length 100 :integer) - (assert (>= (add (multiply field-width 2) (add field-length 2)) (add field-width 2)))	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The set-builder logic asserts that there exists an integer x such that x^2 + 4x - 3 = 0.	\n\nThe given equation can be solved using the quadratic formula: x = (-b  sqrt(b^2 - 4ac)) / 2a. In this case, a=1, b=4, and c=-3. \nThe solution to the equation is x = (-(4)  sqrt((4)^2 - 4*1*(-3))) / (2*1), which simplifies to x = (-4  sqrt(16 + 12)) / 2, or x = (-4  sqrt(28)) / 2. Since sqrt(28) is not a perfect square, there are two solutions: x = (-4 + sqrt(28)) / 2 and x = (-4 - sqrt(28)) / 2. \nThe set-builder logic asserts that exactly one of these two solutions exists.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The Five Houses Problem	Use set-logic QF_UF and declare variables for each house number.  (declare-const house1-number 1) (declare-const house2-number 2) (declare-const house3-number 3) (declare-const house4-number 4) (declare-const house5-number 5)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Find an infinite set {x: [0, 1]}.	This problem can be solved using QF_UF.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that there exists an integer x such that x^2 + 4 = 13	Use QF_UF and set-logic to derive the desired formula.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
(set-logic QF_UF  (declare-const x 1)  (declare-const y 2)	This problem is a simple example of using set-logic QF_UF to reason about the satisfiability of a given formula.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
A farmer wants to ensure that all cows are wearing collars of a certain color.	The farmer has ordered 100 cows, each with one collar. The collar can be either red or blue. Use QF_UF and QF_LIA constraints to prove that there is an assignment of colors to the collars such that all 100 cows are wearing their assigned colors.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Flipped Coins	Use QF_UF with a set of variables and constraints to prove that it's impossible to flip all coins such that one side always shows the opposite number.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Prove that there exists an integer x such that exactly three switches are open.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF to prove that exactly one of three boolean variables can be false at any given time.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Prove that it is impossible to assign colors to three switches such that each switch corresponds to one of three colors and the corresponding color switch is red.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
\(\{\n  x: \n    # Introduce a variable and constraint\n    assert(x > 0);\n  y: \n    # Introduce another variable and constraint\n    assert(y < x);\n  z: \n    # Use SMT-LIB to prove the variables are equal\n  (set-logic QF_UF \n    (declare-const x : int) \n    (declare-const y : int) \n    (declare-const z : bool))\n  \n  assert(z);\n  \n  (check-sat)	\(\{\n  # We use the fact that x > 0 and x + y = z to prove x == z\n  assert(x + y = z + x);\n  \n  # Since z is True, we can deduce x == z\n  assert(x == z);\n  \n  \n  # Use the assumption that x < 0 and x - y = z to prove x != z\n  assert(x > 0 && x - y = z);\n  \n  # Since z is False, we can deduce x != z\n  assert(x != z);\n  \n  \n  \n  (check-sat)	"(declare-const a Int)
(declare-const n Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 n) (<= n 10)))
(assert (distinct a n))
(check-sat)"
A prisoner needs to escape from a cell with multiple locks, each of which has two possible keys: the correct key or the wrong key. The guards enter a room and check one lock at a time in order.	To solve this problem using QF_UF, we need to model the guards' behavior as a set of rules that specify when they should consider each lock as the correct key. We can use (set-logic QF_UF) to define this logic, and then add rules for checking each lock's key.	"(declare-const A Int)
(assert (and (<= 1 A) (<= A 3)))
(declare-const a Int)
(assert (and (<= 1 a) (<= a 3)))
(declare-const and Int)
(assert (and (<= 1 and) (<= and 3)))
(assert (distinct A a and))
(check-sat)"
A woman has two coins that weigh differently. One coin weighs 1 kg and the other weighs 0.9 kg. How much does the lighter one weigh?	Use set-logic QF_UF and assert   (weigh < 1kg)  and (not (weigh = 0.9kg))	"(declare-const A Int)
(declare-const kg Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 kg) (<= kg 10)))
(assert (distinct A kg))
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 0 and x is not odd	To prove this statement, we can use the QF_UF rule to generate a set of solutions for the equation x^2 + 1 = 0. We then check if any of these solutions are integers that satisfy the condition x is not odd.	"(declare-const an Int)
(declare-const is Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct an is))
(check-sat)"
A farmer has two fields, A and B. Field A has 5 apples, and field B has 3 oranges. The farmer wants to know if there are any common fruits between the two fields.	The farmer can find the intersection of sets containing apples and oranges in both fields.	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
A bat and a ball together cost $1.10. The bat costs $1.00 more than the ball. If the ball costs x dollars, how much does the bat cost?	Let b = number of cents in the ball. Then the equation is (100 - b) + b = 110. Solve for b.	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
Satisfying the union of two sets with distinct elements	Use QF_UF and set-builder constraints to model the union of two sets A = {1, 2} and B = {3, 4}. The constraint (set-logic QF_UF) ensures that each element in both sets is present. The constraint (declare-const x : setof int) defines a set of integers containing all elements from both sets. Finally, the constraint (assert all of A | B) asserts that any element in either set is present.	"(assert true)
(check-sat)"
A farmer has two fields, A and B. Field A is 3 units long, while field B is only 2 units long. The farmer wants to know if there are enough spaces on both fields.	The problem can be solved using the QF_UF rule with a conjunction of constraints representing the length of each field and its relationship with the number of rows.	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Satisfying a set of rules on the number of apples	Use QF_UF to generate constraints for the number of apples in each basket and then solve using check-sat.	"(declare-const a Int)
(declare-const of Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct a of))
(check-sat)"
A farmer has two fields: Field A and Field B. If it rains, both fields receive water, but only if it's not too hot.	let (   0:     assert (>= 20 any x) => (x = 'hot')   1:     assert (= 100 any y) => (y = 80)   2:     let (       z: set of string       f0: {x | x = 'hot', x < 20}       f1: {x | x = 'hot', x >= 20, x <= 30}       f2: {x | x = 'hot', x > 30})     assert (in z f0)     & (not in f1 f0)    & (in f2 f1)	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A farmer wants to irrigate all but two rows of his garden, and then water one row. What are the possible values for k?	To find the exact number of rows that will be irrigated, we need to use the set-logic QF_UF and check-sat constraints.	"(declare-const A Int)
(declare-const k Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 k) (<= k 10)))
(assert (distinct A k))
(check-sat)"
"{   'problem': ""Solve the following puzzle: There are three switches, but they are not labelled. Each switch corresponds to one of three light bulbs in a room. Each bulb is either on or off. You can turn the switches on and off as many times as you want, but you can only enter the room one time to observe the bulbs. How can you figure out which switch corresponds to which light bulb?"""	{   (set-logic QF_UF)   (declare-const bulb1 bool   bulb2 bool   bulb3 bool)   (declare-const switches [ bulb1 true    bulb2 false    bulb3 true ]   (assert not (switches[0]            or switches[1]            or switches[2]))   (check-sat)	"(declare-const a Int)
(assert (and (<= 1 a) (<= a 3)))
(declare-const as Int)
(assert (and (<= 1 as) (<= as 3)))
(declare-const in Int)
(assert (and (<= 1 in) (<= in 3)))
(assert (distinct a as in))
(check-sat)"
(set-logic QF_UF (declare-const x int) (declare-const y bool) (assert (>= x 0) (check-sat)	This is a simple problem that can be solved using basic arithmetic and logical constraints. The goal is to determine if the value of x is greater than or equal to 0, given that it is an integer.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
(set-logic QF_UF   (declare-const x y int)   (assert x > 0))	This is a simple logic puzzle where we are asked to prove that if x is greater than 0, then x is positive.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
A farmer has a field that can hold up to 1000 square meters of land. The field is currently empty, and it needs to be fenced in.	The farmer needs to fence in at least 800 square meters of land for this task.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Three Switches	Use set-logic QF_UF and assert/declare/declare-const to model a problem where a person has three switches, labelled A, B and C, and each switch corresponds to one of three light bulbs in a room. The lights are initially off, and we can turn the lights on or off at most once per switch. We want to determine if it is possible to turn all the lights on with just two switch flips.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
(set-logic QF_UF (declare-const x y 1))	(assert y = 1) && (check-sat)	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
The Three Switches	{'type': 'deductive', 'constraints': ['\n  assert (x = 0)\n', '\n  assert (y = 1)\n', '\n  assert (z = 2)\n']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use set-logic QF_UF and assert/unify to prove that there is no valid assignment of colors to switches such that each switch corresponds to either red or green.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the following system of linear equations with integer coefficients and constraints	Use QF_LIA or QF_UF to generate the model, then solve it using a solver like DPLL or CDT.	"(assert true)
(check-sat)"
(set-logic QF_UF (declare-const x 1 #t) (declare-const y 2 #f) (assert (x = true) (y = false)))	to prove that x and not y are both true or both false using only basic arithmetic operations and equality checks	"(declare-const f Int)
(declare-const t Int)
(assert (and (<= 1 f) (<= f 10)))
(assert (and (<= 1 t) (<= t 10)))
(assert (distinct f t))
(check-sat)"
The set of all perfect numbers	This is a classic problem in number theory, and it can be solved using QF_UF with constraints such as (forall x (<= 1000) (odd? x))	"(assert true)
(check-sat)"
Solve the puzzle: 5 cars are parked on the street, and each car has a different color. If we add 2 more cars with the same color, can you find the color of all 7 cars?	Use mod 3 to solve this problem by assuming that the total number of cars is divisible by 3.	"(declare-const If Int)
(declare-const a Int)
(assert (and (<= 1 If) (<= If 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct If a))
(check-sat)"
A farmer has a field with two rows and two columns. Each cell in the field can be either red or green. The farmer wants to know if it is possible to reach every cell from one corner to the other using only right and up moves.	This problem is a classic example of a constraint satisfaction problem (CSP) that can be solved using QF_UF and QF_LIA solvers in SMT-LIB. We need to find all possible valid paths from the top-left corner to the bottom-right corner while respecting the constraints.	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
Satisfy the following proposition: 2 + 2 = true.	This can be proved using the QF_UF rule and simple arithmetic constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use a model with three variables and two constraints to solve this puzzle.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given integers a and b, find all pairs of distinct positive integers c and d such that a + b = c + d	Prove the validity of the following system using QF_UF or QF_LIA with integer constraints: (set-logic QF_UF)   (declare-const a Int)   (declare-const b Int)   (declare-const c Int)   (declare-const d Int)   (assert (a + b = c + d))   (check-sat)	"(declare-const a Int)
(declare-const b Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 b) (<= b 10)))
(assert (distinct a b))
(check-sat)"
Prove that the following statement is true: x = 5 and y != 3	Use the QF_UF rule to combine the assertions of x = 5 and y != 3, then use the QF_LIA rule to prove the conjunction of these two statements. Finally, add a check-sat clause to verify that the system is satisfiable.	"(declare-const is Int)
(declare-const x Int)
(assert (and (<= 1 is) (<= is 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct is x))
(check-sat)"
Solve the following puzzle: A bat and a ball together cost $1.10. The bat costs $1.00 more than the ball. If the ball costs x dollars, how much does the bat cost? y.	$y-x=0.10\quad$y>x$	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
A 5-person committee must be formed from a group of 8 people, and each person can only speak on one topic.	Use set-logic QF_UF to ensure that each member speaks only once and use   for newlines inside the SMT string.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Five Houses Puzzle	Use QF_UF to express that each house is occupied by either a person or an animal.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has N cows to milk. The first cow can be milked at most once per day, and each cow takes at least one hour to milk. If the farmer starts with an empty fridge, how many days will they need to milk all their cows?	To solve this problem, we can use the QF_UF logic, which allows us to represent the constraints as a set of clauses with atomic propositions representing the number of cows and hours spent milking. We can then use the 'check-sat' solver to find an optimal solution.	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
The Three Switches	(set-logic QF_UF) (declare-const x 1) (assert (x = 0)) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has two fields, A and B. Field A contains all the apples from both fields combined. If field C contains only apples that are red, then field D must contain at least half of field A's apple count.	Use QF_UF and QF_LIA to solve this problem. Consider the constraints (set-logic QF_UF) and (declare-const ...). Use assert statements to define field A and field B. Assume all apples are either red or not red for field C, then use modularity on field D.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A farmer has 5 sheep and wants to build a fence around them. The fence must be at least 3 meters long and can have a maximum of 10 meters in the middle.	Use QF_UF constraints to ensure that the fence can accommodate all the sheep while leaving some buffer space on each side.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
A farmer has 'm' chickens and wants to know if they are all happy.	The answer is yes if and only if m = 5 or m = 6	"(declare-const A_friend_if Bool)
(declare-const if_friend_A Bool)
(assert (= A_friend_if if_friend_A))
(assert (= true A_friend_if))
(check-sat)"
The Life of Pi	Use QF_UF and assert constraints on pi, x, and y.	"(declare-const Pi Int)
(declare-const of Int)
(assert (and (<= 1 Pi) (<= Pi 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct Pi of))
(check-sat)"
A farmer has three fields: A, B and C. Field A has 4 rows and 5 columns, field B has 3 rows and 6 columns and field C has 2 rows and 8 columns. The farmer wants to know how many hot peppers are in each field.	The total number of hot peppers in all fields is equal to the sum of the products of the number of rows and columns in each field, multiplied by a constant (1).	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
\(\(\{1:2, 3:4} \) -> (false))	(set-logic QF_UF) (declare-const X int) (assert (X = 1) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
(set-logic QF_UF) (declare-const x 1  # t) (assert (<= 0 (and x 2) (add 3 x))) (check-sat)	"Using the <a href=""https://www.sat.inf.u-bremen.de/"">SAT solver</a> to verify the satisfiability of the given formula. We found that it is unsatisfiable for all values of x."	"(declare-const t Int)
(declare-const x Int)
(assert (and (<= 1 t) (<= t 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct t x))
(check-sat)"
The Three Switches	"(set-logic QF_UF 	(declare-const x 1) 	(declare-const y 2) 	(assert (not (= x 0))) 	(check-sat)"	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	QF_UF and set-logic QF_LIA	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has 5 rows of flowers in her garden, and each row can have at most 3 flowers. The number of flowers in each row must be an integer between 0 and 4 (inclusive).	The number of flowers is a valid integer.	"(declare-const A Int)
(declare-const an Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 an) (<= an 10)))
(assert (distinct A an))
(check-sat)"
Satisfying a simple equation	Use <~{ to enforce an inequality, and <~~ to enforce equality.	"(assert true)
(check-sat)"
Satisfying the Chicken McNugget Theorem	The Chicken McNugget Theorem states that the sum of two relatively prime numbers has a unique representation as a linear combination of those two numbers. Prove this theorem using QF_UF and SMT-LIB.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use a switch statement to determine which color shirt to wear based on the day of the week.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has three fields of wheat: Field A, Field B, and Field C. Each field can hold either 0 or 1 units of wheat. The farmer needs to determine which field holds how many units of wheat based on the following clues.	Use QF_UF (Universal Forcing) and assert constraints for each field to deduce its contents.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A farmer has two fields, A and B. Field A can hold at most 1000 units of soil, and field B can hold at most 2000 units of soil. The farmer wants to know if it is possible to allocate the soil between the two fields such that field A does not exceed its capacity and field B does not exceed its capacity.	use QF_UF to add constraints on the number of units in each field, check-sat to verify the validity of the constraints	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Solve the following logic puzzle: There are three switches, but they are not labelled. Each switch corresponds to one of three light bulbs in a room. Each bulb is either on or off. You can turn the lights on and off as many times as you want, but you can only enter the room one time to observe the bulbs.	Use QF_UF to model the switches and their corresponding light bulbs. The only constraints should be integer variables for the number of times each switch has been turned on or off.	"(declare-const a Int)
(assert (and (<= 1 a) (<= a 3)))
(declare-const as Int)
(assert (and (<= 1 as) (<= as 3)))
(declare-const in Int)
(assert (and (<= 1 in) (<= in 3)))
(assert (distinct a as in))
(check-sat)"
The set of all perfect squares between 0 and 100	Use QF_UF to express that a number is either even or odd, then use the property (forall x (x = 0) -> (not (x^2))) to assert that there are no perfect squares less than 100.	"(assert true)
(check-sat)"
The Five Houses Problem	Use QF_UF and QF_LIA solvers to prove the following statement: There exists an integer x such that x^2 + x + 1 = 5x + 4 or (x == 0 and y == 2) or (x == 3 and y == 1)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
\u03c0\u202f\u2228\u221a\u203b\u2153\u2192\u2115\u20d1\u2164\u217e\u22cc\u2202\u2189\u2164\u223b\u2193\u214f\u2187\u212a\u215c\u2236\u219d\u2210\u2135\u2188\u217c\u2221\u218a\u216f\u220e\u2192\u211c\u2153	\u03b7\u2129\u20ac\u201d\u2060\u2035\u2130\u2211\u2148\u218a\u2164\u217e\u22cc\u2202\u218f\u2153\u219b\u222c\u2207\u2189\u207d\u2066\u2120\u20ac\u201d\u2035\u2130	"(declare-const u2115 Int)
(declare-const u2135 Int)
(assert (and (<= 1 u2115) (<= u2115 10)))
(assert (and (<= 1 u2135) (<= u2135 10)))
(assert (distinct u2115 u2135))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that two people are friends if and only if they have a mutual friend	Use QF_UF to prove the biconditional, and use set-logic to add the necessary constraints	"(declare-const a_friend_if Bool)
(declare-const if_friend_a Bool)
(assert (= a_friend_if if_friend_a))
(assert (= true a_friend_if))
(check-sat)"
(set-logic QF_UF   (declare-const x int)   (assert (not (= x 0)))   (check-sat)	The assertion will only be true if x is not equal to 0.	"(assert true)
(check-sat)"
Social inequality	Use QF_UF to model the relationship between income and education level, where higher income leads to higher education level.  (declare-const X (integer : LessThan 5))  (declare-const Y (integer : GreaterThan 0))  (assert (QF_UF (     X Y              <= 4 ? true : false) )	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given a social network with people of different ages, find all pairs of individuals who are friends.	To solve this problem, we can use QF_UF and check-sat constraints to derive the friendships between people. We can first list all possible pairs of individuals, then constrain each pair using simple integer or boolean constraints (e.g., `age(a, b) <= 18 && age(b, a)`), and finally check for satisfiability.	"(declare-const a_friend_of Bool)
(declare-const of_friend_a Bool)
(assert (= a_friend_of of_friend_a))
(assert (= true a_friend_of))
(check-sat)"
Prove that there exists an integer x such that x + 1 = 3 and x - 2 > 0	Use the QF_UF rule to combine x + 1 = 3 with x - 2 > 0 to get (x+1) - (x-2) = 5 > 0	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The given social constraint is inconsistent and cannot be satisfied by any assignment of integers or booleans.	A valid solution would require the existence of a finite set of integer values that can satisfy all constraints simultaneously.	"(declare-const be_of Bool)
(declare-const be_or Bool)
(declare-const by_of Bool)
(declare-const by_or Bool)
(declare-const is_of Bool)
(declare-const is_or Bool)
(assert (= (+
  (ite be_of 1 0)
  (ite by_of 1 0)
  (ite is_of 1 0)
) 1))
(assert (= (+
  (ite be_or 1 0)
  (ite by_or 1 0)
  (ite is_or 1 0)
) 1))
(assert (<= (+
  (ite be_of 1 0)
  (ite be_or 1 0)
) 1))
(assert (<= (+
  (ite by_of 1 0)
  (ite by_or 1 0)
) 1))
(assert (<= (+
  (ite is_of 1 0)
  (ite is_or 1 0)
) 1))
(check-sat)"
Prove that John and Mary are married	Use QF_LIA and assert the following equations to prove this statement, then check-sat.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Ensure that no two people in a friendship network have more than one connection to each other	"model  	 globeforall x y z:  		headgedd (x, y)  		and  		( x  eq z |  			not ( 			y, z)  	))"	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (= a_friend_in in_friend_a))
(assert (= true a_friend_in))
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 2x and x is less than or equal to 10	{'method': 'modelChecking'}	"(declare-const an Int)
(declare-const is Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct an is))
(check-sat)"
Prove that there exist two distinct integers x and y such that x + y = 5	Using QF_UF with constraints x >= 0, y <= 5, and x + y = 5, derive the existence of a solution.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that it is not possible to construct a directed acyclic graph (DAG) with more than 5 nodes and 10 edges.	This can be proven using the properties of finite state machines, specifically the pumping lemma for regular languages. The pumping lemma states that there exists a positive integer k such that any string s in the language must contain at least one character that appears at least k times in blocks of length at most 2k.	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Prove that there exists an integer x such that x^2 + 4 = 8 and x^2 - 3 < 0.	This problem can be solved using the QF_UF rule, which states that for any formula f(X) of type 'quantifier-free' with one free variable X, we have either f(X) or f(X). We will use this rule to derive a contradiction. First, we show that 3^2 - 4 = 5 and 3^2 + 4 > 8. Then, we can conclude that there exists an integer x such that x^2 < 0.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that 'John' is not equal to 'Alice'	Use QF_UF with set-logic and assert constraints.	"(declare-const is Int)
(declare-const to Int)
(assert (and (<= 1 is) (<= is 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct is to))
(check-sat)"
Prove that there exists an integer $x$ such that x^2 + 3x - 4 = 0	The quadratic equation has at least one real root according to the Fundamental Theorem of Algebra, and we can show this by attempting to solve it manually.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that there exists an integer x such that x > 0 and (x + 1) mod 3 = 2	Using the properties of modular arithmetic, we can derive that if x is positive, then (x + 1) mod 3 must be equal to 2. This implies that there exists a unique integer solution for x.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that John and Mary are married.	(set-logic QF_UF) (declare-const John mary : pair (string , string)) (assert (John mary) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that a person is not married to themselves.	(not (set-of-facts (set-of-constants 'x) (set-of-constants 'y)))	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Prove that for all integers n >= 2, (1 + n) mod 3 = 0.	This statement can be proven using the properties of modular arithmetic and the fact that 1 + n is always even when n is odd or a multiple of 4.	"(assert true)
(check-sat)"
Prove that there are at least two distinct social connections between individuals in a small community.	Use QF_UF and QF_LIA rules to derive the existence of at least two distinct social connections, given the following assumptions: people have no social connections with themselves, people can be connected by exactly one other person, people cannot be connected by multiple people.	"(declare-const a Int)
(declare-const at Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 at) (<= at 10)))
(assert (distinct a at))
(check-sat)"
Verify that the following relation holds: (x, y) <- (x, z) && (y, z)	Use QF_UF and QF_LIA rules to derive the implication.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that it is impossible to have two people who are friends with each other	{'description': 'Use QF_UF and set-logic to model this relationship.', 'smtlib': 'set-logic QF_UF\ndeclare-const Alice:Int\ndeclare-const Bob:Int'}	"(declare-const is_friend_it Bool)
(declare-const it_friend_is Bool)
(assert (= is_friend_it it_friend_is))
(assert (= true is_friend_it))
(check-sat)"
Given the following social network structure: [1, 2; 2, 3; 3, 4], define the minimum number of friendships required to satisfy all constraints.	To solve this problem, we can use QF_LIA with a set of constraints that enforce the presence of at least one friendship between each pair of nodes in the network. We can then check if the resulting model is satisfiable using check-sat.	"(declare-const of_friend_to Bool)
(declare-const to_friend_of Bool)
(assert (= of_friend_to to_friend_of))
(assert (= true of_friend_to))
(check-sat)"
Prove that any two people are connected in a social network	Use QF_UF and QF_LIA rules to reason about graph connectivity	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Verify that a social relationship graph is consistent.	{   (set-logic QF_UF)   (declare-const person1 person2 : FRIENDS)   (assert (forall (x person)         (           (person1 x)                        (person2 x))         (not (eq x x)))   )	"(declare-const a_friend_is Bool)
(declare-const is_friend_a Bool)
(assert (= a_friend_is is_friend_a))
(assert (= true a_friend_is))
(check-sat)"
Prove that two people are friends if and only if they share a common interest.	Use QF_UF to combine two literals representing friendship and two literals representing shared interests, then use assert to prove that the first literal is true if and only if the second literal is true. Finally, check-sat to verify that the system satisfiable.	"(declare-const a_friend_if Bool)
(declare-const if_friend_a Bool)
(assert (= a_friend_if if_friend_a))
(assert (= true a_friend_if))
(check-sat)"
Determine whether a person is married to their spouse	Use QF_LIA and (set-logic QF_UF) with valid constraints to prove that a person is not married to their spouse.	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Prove that there does not exist an integer x such that x^2 + 1 = 0	This statement can be proven using the QF_LIA theory, specifically by assuming x is an integer and then deriving a contradiction.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that if person A is friends with person B and person C, then person A and person C are connected by a friendship chain	Use QF_UF to represent friendships between people and QF_LIA to ensure the structure of the friendship graph is consistent.	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Determine if all people in a social network have at least one friend.	Use QF_UF and assert statements to model relationships between individuals, then use the check-sat solver to verify validity.	"(declare-const a_friend_at Bool)
(declare-const at_friend_a Bool)
(assert (= a_friend_at at_friend_a))
(assert (= true a_friend_at))
(check-sat)"
Prove that there exist two people in a social network such that they are friends and not spouses.	Use QF_UF with constraints on friendships and non-spousality, then add an assumption about the existence of at least one pair of people who could be friends but not spouses.	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (not a_friend_in))
(assert (not in_friend_a))
(check-sat)"
Prove that there does not exist an integer k such that k^2 + 5k - 6 = 0	(assert (integer s) (> 0 ? 1 : 2)) (assert (syms x k real) > 0) (assert (satisfies (e (univariate x) (- 6 x 6 k^2 + 5 k))) > 0) ((set-logic QF_UF) (declare-const s real)) ((check-sat))	"(declare-const an Int)
(declare-const k Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 k) (<= k 10)))
(assert (distinct an k))
(check-sat)"
Determine whether it is possible to construct a social network where all individuals are connected and no two individuals are friends	The graph of friendships can be represented as an undirected graph with weighted edges, where each edge has a weight representing the strength of the friendship. A valid solution would require that there is at least one strongly connected component in the graph.	"(declare-const a_friend_is Bool)
(declare-const is_friend_a Bool)
(assert (= a_friend_is is_friend_a))
(assert (= true a_friend_is))
(check-sat)"
Prove that if Alice is friends with Bob and Bob is friends with Charlie, then Alice is friends with Charlie	Use QF_UF with constraints that express the friendship relationships as valid integer solutions. Ensure the model is satisfiable by checking for consistency.	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (= if_friend_is is_friend_if))
(assert (= true if_friend_is))
(check-sat)"
Prove the following sentence is valid in QF_UF	Use the set-logic QF_UF and assert statements to derive the sentence.	"(declare-const in Int)
(declare-const is Int)
(assert (and (<= 1 in) (<= in 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct in is))
(check-sat)"
Given a person A with age 25 and friend B, prove that if A's friends are all friends of C then A is friends of B.	(declare-const A Person (0: 1) (declare-const B Person (0: 1) (declare-const C Person (0: 1))  (   (            (forall x (Person (x)) (         (set-of y (Set-of-z) z)))        ) )  (   (assert (or (A= B) (All-of-A-Friend-Of-B-C A C))))	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Prove that if person1 is friends with person2 and person3, then person4 is not friends with person5.	{'method': 'existential', 'variables': ['person1', 'person2', 'person3', 'person4', 'person5'], 'constraints': ['(set-logic QF_UF)\n\n', '(declare-const person1 person1)\n', '(declare-const person2 person2)\n', '(declare-const person3 person3)\n', '(assert (person1 <> person2))\n', '(assert (person1 <> person3))\n', '(assert (not (person4 <>) (person5 <)))']}	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (not if_friend_is))
(assert (not is_friend_if))
(check-sat)"
The relationship 'John Doe' and 'Jane Smith' are friends.	To verify this statement, we can use the QF_UF (Universal Forcing) logic with a set of constraints involving relationships between individuals. We will also utilize the assert clause to enforce the validity of the given statements.	"(declare-const X_friend_Y Bool)
(declare-const Y_friend_X Bool)
(assert (= X_friend_Y Y_friend_X))
(assert (= true X_friend_Y))
(check-sat)"
The given social network of friends has exactly 5 people.	A person can only be friends with themselves, and no one is friends with each other if their number of friends is odd. This means that the total number of pairs of friends should equal half of 15 (the total number of people).	
Prove that there exists an integer x such that x + 1 = 2x	Use the QF_UF and QF_LIA rules to derive the desired consequence.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that there are no cycles in the graph G = ({a, b, c}, R), where R is an undirected relation and 'a' and 'b' are related to each other, but not both.	Use QF_UF and set-logic to reason about the satisfiability of this graph. Assume X = {a, b} such that X  G. Prove by contradiction that there exists a path from a to c in G if and only if for all y  X, (y, x)  R.	"(declare-const G Int)
(declare-const R Int)
(assert (and (<= 1 G) (<= G 10)))
(assert (and (<= 1 R) (<= R 10)))
(assert (distinct G R))
(check-sat)"
Pigeonhole Principle	Given n pigeons and m pigeonholes, show that at least one pigeonhole must contain more than one pigeon.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The following social relationship constraint is valid: P(x, y) |= Q(x, z), where P, Q are predicates and x, y, z are atoms.	To prove the validity of this constraint, we need to show that it is satisfiable using a finite model.	"(declare-const P_friend_Q Bool)
(declare-const Q_friend_P Bool)
(assert (= P_friend_Q Q_friend_P))
(assert (= true P_friend_Q))
(check-sat)"
Verify that a social constraint involving two individuals and their relationships holds true	{'method': 'existential quantification'}	
Prove that all employees in the company are working	Using set-logic QF_UF and QF_LIA, derive the following implications: (set-of-people employee1 ... employee5) => (work(employee1, employee2), work(employee3, employee4), work(employee5, employee6))	"(assert true)
(check-sat)"
Prove that John and Mary are married	(set-logic QF_UF) (declare-const John mary : bool) (assert (== John mary)) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that if person1 is friends with person2, and person2 is friends with person3, then person1 is friends with person3.	Use the transitive property of friendship to prove this implication.	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (= if_friend_is is_friend_if))
(assert (= true if_friend_is))
(check-sat)"
Prove that a person is either in their hometown or not.	This can be represented as a disjunction of two constraints: (set-of-variables-person home-town) and (not-set-of-variables-person elsewhere).	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Find all pairs of people in a social network where one person is friends with another.	Use QF_UF to model friendship relationships and check-sat to solve the problem	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (not a_friend_in))
(assert (not in_friend_a))
(check-sat)"
Prove that any person is either a student or an employee of the same company.	{   (set-logic QF_UF)   (declare-const C (Symbol('Company'))   (declare-const S (Symbol('Student'))   (declare-const E (Symbol('Employee'))   (assert (not (or (= C S) (= C E))))   (assert (not (and (= S C) (= E C)))   (assert (not (or (= S E) (= C E)))))   (check-sat) }	"(declare-const a Int)
(declare-const an Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 an) (<= an 10)))
(assert (distinct a an))
(check-sat)"
Prove that a person is either married to their spouse or not married at all	Use QF_UF and assert variables for marriage status, then check-sat	"(declare-const a Int)
(declare-const at Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 at) (<= at 10)))
(assert (distinct a at))
(check-sat)"
Prove that John and Mary have different favorite sports.	Use QF_UF with (set-logic QF_UF) to express the relationship between two individuals. Then, use (assert ...) to assert a specific property about their preferences. Finally, check-sat to prove this property holds true.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that John and Alice are friends.	(john = alice) -> (friend john alicia)	"(declare-const X_friend_Y Bool)
(declare-const Y_friend_X Bool)
(assert (= X_friend_Y Y_friend_X))
(assert (= true X_friend_Y))
(check-sat)"
A university has two social constraints regarding friendships between students.	These constraints can be represented using QF_UF and QF_LIA axioms.	
Prove that a person is either in the US or has a valid US driver's license.	Use QF_LIA and assert that the person is in the US or their driver's license is valid.	"(declare-const US Int)
(declare-const a Int)
(assert (and (<= 1 US) (<= US 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct US a))
(check-sat)"
Prove that every person has at least one friend	Use QF_LIA and QF_UF to model the friendship relationship between people	"(declare-const at_friend_has Bool)
(declare-const has_friend_at Bool)
(assert (= at_friend_has has_friend_at))
(assert (= true at_friend_has))
(check-sat)"
Satisfies QF_UF rule with a valid JSON payload	"{'solver': 'CPVEX', 'input': '{""solution"": ""1"", ""constraints"": [""x + y = 2""]}', 'expected_solution': '[0, 3]'}"	"(assert true)
(check-sat)"
The social network has a relationship between John and Alice, but they are not friends.	{'constraints': ['(set-logic QF_UF)\n', '(declare-const person1 person2)\n', '(assert (not (person1 = person2)))\n', '(check-sat)']}	
\(set-logic QF_UF\) \(declare-const x = 5\) \(assert \((\u'== 4\)\))	This proof uses QF_UF to prove a simple equality and QF_LIA to derive the truth of the assertion.	"(declare-const u Int)
(declare-const x Int)
(assert (and (<= 1 u) (<= u 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct u x))
(check-sat)"
The relationship between person A and person B is that they are friends.	This can be expressed as (set-logic QF_UF)      (declare-const personA personA   declare-const personB personB   assert (personA == personB))   (assert (not (personA != personB)))	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
\(set-of\(\{x| x #= 1\} \) && \(set-of\(\{y| y #!= 2 && !x || y #<= 3\} \))\)	\(declare-const x 1; \(declare-const y 2; \(assert (xor (and (not (eq x 1) (neq x 2)) (not (eq x 1) (lt x 3))) (and (neq x 1) (gt x 3)));\)	"(declare-const of Int)
(declare-const x Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct of x))
(check-sat)"
Prove that there exists an integer x such that 2*x + 3 >= 5 and x^2 <= 4	Use QF_UF to model the system of linear inequalities: 2x + 3 >= 5 --> 2x >= 2 --> x >= 1; x^2 <= 4 --> x <= -2	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that for all integers x and y, if x > y then x + y = 2y	Using QF_UF with the set of integers and the implication rule, derive the following:   (declare-const x Int) (declare-const y Int) (assert (x > y)) (check-sat)	"(declare-const if Int)
(declare-const x Int)
(assert (and (<= 1 if) (<= if 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct if x))
(check-sat)"
{'solver': 'QF_UB', 'reasoning': '(set-logic QF_LIA (declare-const x 0: INTEGER) (assert (>= x 1)) (check-sat))'}	(assert (>= 2 3)) (check-sat)	"(assert true)
(check-sat)"
Prove that if Alice and Bob are friends, then Carol is also friends with both of them.	(set-logic QF_UF)                (declare-const alice friend bob)     (assert (not (friend bob alice)))     (declare-const carol friend alicebob)     (assert (and (friend alicebob carol) (friend alice carol)))	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (= if_friend_is is_friend_if))
(assert (= true if_friend_is))
(check-sat)"
Prove that there are no friends among five people.	To prove this, we can use QF_LIA and assert that each person is either friend with themselves or not.	
A person is either married to their spouse or in a consensual relationship with someone else.	This property can be expressed using QF_UF (Unions of First-Order) and constraints such as <person> marry <other_person>	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
Verify that there are no social connections between all individuals in a network of 10 people with no mutual friends	Use QF_UF to model the relationship as a graph, and then use QF_LIA to check if the graph is acyclic. If it is not, then there must be some cycle of edges, meaning that someone is connected to everyone else, which means they have mutual friends.	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (= a_friend_in in_friend_a))
(assert (= true a_friend_in))
(check-sat)"
(set-logic QF_UF (declare-const x y z (integer :pred <)) (assert (not (= x 5))) (check-sat)	(check-sat)	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that there exist distinct integers x, y such that x + y = 3 and x  y	Using QF_UF and the constraints x + y = 3 and x  y, derive a contradiction if neither x nor y is equal to zero.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that a person who has friends with people they know personally and strangers, but does not have acquaintances outside of their social circle, cannot be a friend to any one specific stranger.	Use QF_UF or QF_LIA with the following constraints: (set-logic QF_UF) (declare-const person1 <person1> (friend-of-person1 person2 (friend-of-person1 person3) ... (not acquaintances person4 person5))) (assert (for-all x (forall y (not friend-of-person1 y x))) (not (in-a-social-circle x)))	"(declare-const a_friend_be Bool)
(declare-const be_friend_a Bool)
(assert (not a_friend_be))
(assert (not be_friend_a))
(check-sat)"
Prove that there exist non-empty sets A and B of people such that A  B = 	"The following set constraints ensure the existence of such sets:  - A (A  X)   	B (B  A);"	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
Social Network Problem	The following friendship relationships hold: (Alice, Bob), (Bob, Charlie), (Charlie, Alice). Find the maximum number of friends each person can have.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given two people A and B, where person A is related to person B by marriage if A's age is greater than B's age.	Use QF_UF or QF_LIA with set-logic to express the relationship between ages of individuals for any positive integers n and m (where n <= m).	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
Prove that if person A has degree 3 and person B has degree 4, then person A's age is greater than or equal to person B's age	This implication can be proved using QF_UF or QF_LIA.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
Prove that there exists an integer x such that x^2 = 5 and x^4 + 2x^2 - 1	Use QF_UF to reason about the existence of a solution and then use QLIA to solve for x.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that two people are acquaintances if they have met at least once	(set-logic QF_UF) (declare-const person1 :: int) (declare-const person2 :: int) (assert (person1 = person2)) (check-sat)	"(declare-const at Int)
(declare-const if Int)
(assert (and (<= 1 at) (<= at 10)))
(assert (and (<= 1 if) (<= if 10)))
(assert (distinct at if))
(check-sat)"
Given the social network of individuals with attributes 'name' and 'relationship_type', find the maximum number of people who are directly related to each other.	This can be solved using QF_UF or QF_LIA, where we express a relationship between two individuals as an equivalence relation. We then use the fact that the size of an equivalence relation is equal to the number of pairs of distinct elements in the set. This allows us to compute the maximum number of people who are directly related to each other.	"(declare-const of_friend_to Bool)
(declare-const to_friend_of Bool)
(assert (= of_friend_to to_friend_of))
(assert (= true of_friend_to))
(check-sat)"
Prove that there exists an integer x such that x + 1 = 2 * x	Use QF_UF and set-logic to prove the statement	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that a person can go to exactly two different cities if they travel between cities in different countries.	Using the QF_UF model with a set of cities and countries, prove that the person's travel history is consistent.	"(declare-const a Int)
(declare-const can Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 can) (<= can 10)))
(assert (distinct a can))
(check-sat)"
Prove that a person is either married or single.	(set-of-values x:Person; (set-of-assertions x:-single | x:-married))	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Use QF_LIA to express the relationship between friends and their relationships with others.	Use QF_UF with a set of 'not' constraints to express the relationship between individuals.	
Find all triples (a, b, c) where a has degree 2 in graph G and b is adjacent to both a and c	Use QF_LIA constraints to enforce the properties of the relationships.	"(declare-const G Int)
(declare-const a Int)
(assert (and (<= 1 G) (<= G 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct G a))
(check-sat)"
Find all pairs of distinct people in a university with exactly one common friend.	Use QF_UF to model this relationship and QLIA to restrict the number of friends each person can have.	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (= a_friend_in in_friend_a))
(assert (= true a_friend_in))
(check-sat)"
The set of all prime numbers less than or equal to 100	{(set-logic QF_UF) {(declare-const P UU)   assert (forall (x UU) ( eg ((xor x P) (xor P x))))	"(declare-const of Int)
(declare-const or Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 or) (<= or 10)))
(assert (distinct of or))
(check-sat)"
The given social relationship is valid.	Use QF_UF and set-logic QF_UF to ensure validity of constraints.	
Prove that every person is related to themselves.	Use QF_UF to assert that each person is connected to at least one other person, and then use QF_LIA to conclude that there are no cycles in the graph.	"(declare-const is Int)
(declare-const to Int)
(assert (and (<= 1 is) (<= is 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct is to))
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 0	Use QF_UF and set-logic to reason about the existence of solutions to this equation.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that if person A is friends with person B, and person B is friends with person C, then person A is friends with person C	Use QF_UF and QF_LIA constraints to derive the desired implication. Use the following assumptions: (A,B) and (B,C), and (C,A).	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Prove that for all integers n >= 5, n^2 + n - 13 > 0	The following statements are true:  - set-logic QF_UF - set-logic QF_LIA - declare-const n_ int - declare-variable x int - assert (x = 5) - assert (x^2 + x - 13 > 0)	"(assert true)
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 4x and 2x > 0	Using QF_UF with the set of variables {x} and the constraints from the problem statement, we can derive the following expression: 2 * (x^2 - 4) = 0. Solving for x, we get x = 16. Therefore, there exists an integer solution to the equation.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The friends of Alice are married, but Bob is not	To ensure this is true, we need to assert that (set-of-people x y) != (set-of-people x z)	"(declare-const is_friend_of Bool)
(declare-const of_friend_is Bool)
(assert (not is_friend_of))
(assert (not of_friend_is))
(check-sat)"
Prove that there exists an integer x such that x^2 + 4x - 3 = 0	To prove this equation has a solution, we can use the fact that it is a quadratic equation with two roots. We can also use the method of completing the square to simplify the equation.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that a person is not a friend of themselves	Use   to separate the reasoning into two parts: first, prove that an individual is friends with another if they have at least one movie in common, and second, prove the converse	"(declare-const a_friend_is Bool)
(declare-const is_friend_a Bool)
(assert (not a_friend_is))
(assert (not is_friend_a))
(check-sat)"
Prove that there exists an integer x such that 2*x + 3 >= 0	To prove this, we can use the QF_UF logic with 2*u + 3 <= -u for u >= 0. This is because for any non-negative integer u, 2*u + 3 will always be greater than or equal to 1, satisfying the condition.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The following social constraint is invalid: \nIt states that Alice and Bob are friends when they do not have a mutual friend, which is a contradiction.	\nTo resolve this conflict, we can add constraints to ensure that if Alice is friends with X, then X must also be friends with Alice. This can be achieved using the following QF_UF clause: (\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n)	"(declare-const a_friend_do Bool)
(declare-const do_friend_a Bool)
(assert (not a_friend_do))
(assert (not do_friend_a))
(check-sat)"
Prove that there does not exist an ordered pair of integers (x, y) such that x = 2 and y = 4	This statement can be proven using the QF_UF rule and the fact that x cannot be both even and odd.	"(declare-const an Int)
(declare-const of Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct an of))
(check-sat)"
Prove that there exists an integer x such that x + 1 = 2*x	"\begin{align*} (\exists x (\forall y (y < x \ 2*y == x+y))) &
ightarrow ((\exists z (z >= 0 \ z != -1)))) \end{align*}"	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Satisfying the social constraint: No two people in the same group.	Use QF_UF or QF_LIA to ensure that each person is in a unique set of groups.	"(declare-const No Int)
(declare-const in Int)
(assert (and (<= 1 No) (<= No 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct No in))
(check-sat)"
Prove that there exists an integer x such that 2x + 1 > 0	To prove this, we can use the QF_LIA solver with the following constraints: (set-logic QF_UF) (declare-const x Int) (assert (>= 0 (1 + 2 * x)))	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
A university has two classes: History and English.	The class that starts later must be the one with more students	"(declare-const A Int)
(assert (and (<= 1 A) (<= A 3)))
(check-sat)"
Prove that if Alice and Bob both have a pet cat, then they are friends.	\begin{qf uf} \setof(x:person) (x ~ x.pet.cat) & (x ~ y.pet.cat) \declare-relation(p,q:friend)(p.y ~ q.y) \check-sat	"(declare-const a_friend_if Bool)
(declare-const if_friend_a Bool)
(assert (= a_friend_if if_friend_a))
(assert (= true a_friend_if))
(check-sat)"
PREDicates and Atomic Variables: Prove that there exists an integer x such that x^2 = 0	The solution to this problem can be proven using QF_UF, given the constraints (set-logic QF_UF) and (declare-const x :: int). The key insight is to recognize that if there does not exist an integer x such that x^2 = 0, then we must have a contradiction. This would mean that either x or x+1 cannot be zero, which implies that x is not an integer, leading to a contradiction.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	Use QF_UF and QF_LIA axioms to prove that a valid schedule can be constructed from a given set of jobs with different durations.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the linear programming relaxation of the knapsack problem	Using QF_UF with an interval representation to solve this linear program	"(assert true)
(check-sat)"
Scheduling Problem	Integer linear programming to optimize task allocation on a machine with multiple processing units.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	# Use QF_UF and QF_LIA rules with simple integer constraints to model the scheduling problem. The SMT-LIB program should include the following constraints: # A must be executed by processor C1 P_A <= P_C1 * 2; # Assign tasks to processors based on their capabilities # B must be executed by processor C2 P_B <= P_C2 * 3; # Assign tasks to processors based on their capabilities # Check if the assignment satisfies all constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfies the linear programming relaxation of the flow network of scheduling problem with three nodes and four edges, where each edge has two capacities.	This problem can be solved using the flow network solver of SMT-LIB.	"(assert true)
(check-sat)"
Scheduling Problem	Construct a scheduling problem with two tasks that cannot be scheduled together.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling: max-work-hours	assert (set-logic QF_UF) and (declare-const hours 1: integer) and (declare-const total_hours 0: integer) and (assert (=, total_hours, sumhours(hours))) and (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA with simple integer and boolean constraints to model a scheduling algorithm that assigns jobs to machines based on their processing time and machine capacity.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF with integer variables	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF to solve this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
\(\setoflucore uf) \+ (\declareconst i32 x 10)	\(\checksat (\assert true) \| (\checksat false))	"(declare-const i32 Int)
(declare-const uf Int)
(assert (and (<= 1 i32) (<= i32 10)))
(assert (and (<= 1 uf) (<= uf 10)))
(assert (distinct i32 uf))
(check-sat)"
Scheduling Problem	Use QF_UF to model scheduling as a maximization problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
{'type': 'scheduling', 'domain': 'transportation'}	{'type': 'explanation', 'domain': 'scheduling'}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Check if this scheduling problem is solvable in practice.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a scheduling problem	{'approach': 'brute-force', 'search': 'depth-first'}	"(assert true)
(check-sat)"
\(declare-const x 0: Int\); (set-logic QF_UF)\n(declare-const y 1: Boolean; (assert \(x = true; \))\n(check-sat)	Using the properties of equality and union to derive new constraints	"(declare-const n Int)
(declare-const x Int)
(assert (and (<= 1 n) (<= n 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct n x))
(check-sat)"
Scheduling Problem	Use QF_LIA and set-logic QF_UF to generate constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling problem to minimize make times and meet deadlines	Use QF_UF and QF_LIA rules to analyze constraints on machine times and resource utilization.	"(assert true)
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to enforce valid scheduling rules	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF with linear constraints to model a scheduling problem where tasks are assigned to time slots and their start times must be within a certain range.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to model the scheduling of tasks on a shared resource.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA SMT-LIB rules to derive a valid scheduling plan.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to generate valid constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Minimize Latency	Use QF_LIA and set-logic QF_UF to ensure validity and correctness.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find an assignment that satisfies all constraints	Using QF_UF and QF_LIA, derive valid integer constraints to satisfy the scheduling problem.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_LIA to reason about scheduling constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Maximize the number of customers served while minimizing idle time	Use QF_UF and QF_LIA rules to model the scheduling problem, including constraints on customer arrival and departure times, as well as idle time.	"(assert true)
(check-sat)"
Scheduling Problem: Find an optimal assignment of jobs to machines in a factory	Use QF_UF and QF_LIA rules to solve this scheduling problem, ensuring that all constraints are satisfied exactly.	"(declare-const a_of Bool)
(declare-const a_to Bool)
(declare-const an_of Bool)
(declare-const an_to Bool)
(declare-const in_of Bool)
(declare-const in_to Bool)
(assert (= (+
  (ite a_of 1 0)
  (ite an_of 1 0)
  (ite in_of 1 0)
) 1))
(assert (= (+
  (ite a_to 1 0)
  (ite an_to 1 0)
  (ite in_to 1 0)
) 1))
(assert (<= (+
  (ite a_of 1 0)
  (ite a_to 1 0)
) 1))
(assert (<= (+
  (ite an_of 1 0)
  (ite an_to 1 0)
) 1))
(assert (<= (+
  (ite in_of 1 0)
  (ite in_to 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to solve the scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
(set-logic QF_UF  (declare-const x int)  (declare-const y int)  (assert (>= x 0)    (<= y 10) )	This is a problem that will be solved using SMT-LIB.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Scheduling Problem	Formally specify scheduling constraints using QF_UF and QF_LIA.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the parity of three signals in a 3D system	Use QF_UF with equality constraints and set-logic QF_LIA to enforce non-increasing order.	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Satisfy the following scheduling constraint: Minimize make_time(1, 2) + make_time(3, 4)	Use QF_UF and QF_LIA constraints to ensure that make_time(1, 2) <= make_time(3, 4).	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to prove the satisfiability of the scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA clauses to model the scheduling of tasks on a single processor.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a scheduling conflict on multiple servers	Using QF_UF and QF_LIA to ensure tight coupling between tasks and servers, while respecting resource constraints.	"(declare-const a Int)
(declare-const on Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 on) (<= on 10)))
(assert (distinct a on))
(check-sat)"
Scheduling Problem: Resource Allocation	Use QF_UF and QF_LIA constraints to model resource allocation in a scheduling problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF to define sets of variables and use QF_LIA to check consistency.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Maximize Productivity with Limited Time	This problem can be solved using QF_UF and QF_LIA constraints to ensure that the production of products does not exceed the available time.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	{'constraints': ['(set-logic QF_UF)', '(declare-const X 1)', '(declare-const Y 2)', '(assert (<= X 10))'], 'clauses': ['(check-sat)']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling problem with no conflicts	Use QF_LIA to model this scheduling problem without conflicts.	"(assert true)
(check-sat)"
Scheduling Problem	This problem uses QF_UF and QF_LIA formulas to model a real-time system.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and check-sat to prove the validity of the program, which asserts that there exists an integer solution to the scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	{'constraint_type': 'integer_lower_bound', 'variables': ['x', 'y'], 'constraints': ['(set-logic QF_UF)', '(declare-const x int)', '(declare-const y int)', '(assert (>= x 0))', '(assert (<= y 10))']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Integer Constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the following linear programming relaxation of the 8-hour workday problem with additional constraints	Using QF_UF and QF_LIA, derive the solution to a system of linear equations representing the 8-hour workday problem, where employees are only allowed to work up to 40 hours per week.	"(assert true)
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to prove validity	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Maximize Customer Satisfaction	Use QF_UF or QF_LIA to generate a valid model and check its satisfiability.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Formulate a valid schedule that satisfies all constraints and meets the deadline.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	{'type': 'clausal', 'constraints': ['(set-logic QF_UF)', '(declare-const x Int)', '(declare-const y Bool)', '(assert (not (= x 0)))']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to model this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Find all valid solutions to the following system of linear equations with two variables.	Use QF_LIA and integer constraints to solve this system.	"(declare-const of Int)
(declare-const to Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct of to))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to ensure valid constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling: maximize {x, y} where x is the number of customers served in the first hour and y is the number of customers served in the last hour	The goal is to maximize the total number of customers served within a fixed time frame. This can be achieved by prioritizing customers based on their arrival times.	"(declare-const in Int)
(declare-const is Int)
(assert (and (<= 1 in) (<= in 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct in is))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA constraints to model a scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	To solve the scheduling problem, we need to find an assignment of tasks to machines that satisfies all constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find the optimal assignment of tasks to machines	Use QF_UF and QF_LIA constraints to enforce valid scheduling rules, and check for satisfiability using QBF or DPLL-SAT.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA to represent the scheduling problem as a logic formula	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA solvers to reason about valid schedules.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following scheduling constraint using QF_UF and basic arithmetic constraints.	Use the following set of rules to derive the solution: (set-logic QF_UF) (declare-const X < 10) (assert X > 0) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA constraints to ensure fairness in resource allocation.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given a set of jobs with deadlines and resource requirements, determine the optimal assignment of jobs to machines without violating any deadlines or resource constraints.	Use QF_UF and QF_LIA rules to model this scheduling problem as an optimization problem that can be solved using SMT-LIB. Include assertions for machine availability and job deadlines.	"(declare-const a_to Bool)
(declare-const of_to Bool)
(declare-const or_to Bool)
(assert (= (+
  (ite a_to 1 0)
  (ite of_to 1 0)
  (ite or_to 1 0)
) 1))
(assert (<= (+
  (ite a_to 1 0)
) 1))
(assert (<= (+
  (ite of_to 1 0)
) 1))
(assert (<= (+
  (ite or_to 1 0)
) 1))
(check-sat)"
Scheduling Problem: Minimize Makespan	Given a set of tasks with start times and durations, find the order that minimizes the total makespan.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying an integer linear equation	(= (int x) ( (1 + 2)  = 3))	"(assert true)
(check-sat)"
scheduling_problem	derive_satisfiability_from_just_the_constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	(set-logic QF_UF)  define-variables   x: integer   y: boolean,   z: real  (assert (not (= x 0))) (assert (not (= y true))) (assert (= z 1.5))	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find the minimum number of machines required to schedule tasks with maximum utilization	This problem can be solved using First-Order Logic (FOL) constraints in SMT-LIB. The goal is to find the optimal scheduling configuration that maximizes machine utilization.	"(declare-const of Int)
(assert (and (<= 1 of) (<= of 3)))
(declare-const to Int)
(assert (and (<= 1 to) (<= to 3)))
(assert (distinct of to))
(check-sat)"
Scheduling Problem	{'type': 'Propositional Reasoning', 'reason': 'Using QF_UF with integer constraints and checking satisfiability'}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	Use QF_UF with set of variables and universal quantification to model a scheduling problem where tasks have start and end times.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Generate an exact solution for the following linear programming relaxation of the 5-hour delivery problem	Use QF_UF and QF_LIA constraints to model integer variables representing hours worked by drivers, and use assert statements to enforce non-negativity.	"(declare-const an Int)
(declare-const of Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct an of))
(check-sat)"
\(set-logic QF_UF \n\n(declare-const X true \n  \n  (assert Y = 1) \n  (assert Z < 5))\n	This is a valid SMT-LIB program that includes the necessary logic for model checking and satisfiability.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find optimal assignment of tasks to machines	Use QF_UF and QF_LIA solvers with simple constraints, e.g., (set-logic QF_UF)   (declare-const machine <1..4>   (declare-const task <1..5>))   (assert (>= 0 (size of task)))	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to prove that it is NP-complete.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA to enforce valid scheduling constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA to model the scheduling problem	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find the optimal assignment of tasks to machines	Use QF_UF and QF_LIA constraints to reason about machine resource allocation.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to enforce precedence constraints on tasks	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF to model the scheduling of tasks with deadlines and resource constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA constraints to model this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Determine if it is possible to assign all tasks to employees within a given time frame.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to model scheduling problems.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF with valid constraints to solve this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a scheduling constraint	Use QF_UF and QF_LIA constraints to model the problem	"(assert true)
(check-sat)"
Modeling scheduling conflicts in a production line	\n\n\n(\n  \n    \n    (\n      \n      \n      \n      \n      \n      \n      \n    ),\n\n  \n\n  (\n    \n    (\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    )\n\n  \n)	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Scheduling Problem	Using QF_UF and QF_LIA rules to reason about scheduling constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	This problem requires the use of QF_UF and QF_LIA rules to reason about scheduling constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Using QF_UF and set-logic to model scheduling problems with multiple tasks and resource constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	Use QF_UF rules to model the scheduling of tasks with dependencies.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following integer linear program: P = { x, y | x + y <= 5, x >= 0, y >= 0 }	Use QF_UF and QF_LIA constraints to ensure satisfiability, then check for valid solutions.	"(declare-const P Int)
(declare-const x Int)
(assert (and (<= 1 P) (<= P 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct P x))
(check-sat)"
Scheduling Problem: Given two tasks t1 and t2, assign task t1 to machine M1 and task t2 to machine M2 if both machines are not busy	Propositional Reasoner	"(declare-const M1_t1 Bool)
(declare-const M1_t2 Bool)
(declare-const M2_t1 Bool)
(declare-const M2_t2 Bool)
(declare-const if_t1 Bool)
(declare-const if_t2 Bool)
(assert (= (+
  (ite M1_t1 1 0)
  (ite M2_t1 1 0)
  (ite if_t1 1 0)
) 1))
(assert (= (+
  (ite M1_t2 1 0)
  (ite M2_t2 1 0)
  (ite if_t2 1 0)
) 1))
(assert (<= (+
  (ite M1_t1 1 0)
  (ite M1_t2 1 0)
) 1))
(assert (<= (+
  (ite M2_t1 1 0)
  (ite M2_t2 1 0)
) 1))
(assert (<= (+
  (ite if_t1 1 0)
  (ite if_t2 1 0)
) 1))
(check-sat)"
scheduling:make-schedule	show that it is impossible to schedule two tasks with different start times and one task can be delayed by any amount of time without violating the constraints.	"(declare-const X Int)
(assert (and (<= 1 X) (<= X 3)))
(declare-const Y Int)
(assert (and (<= 1 Y) (<= Y 3)))
(declare-const Z Int)
(assert (and (<= 1 Z) (<= Z 3)))
(assert (distinct X Y Z))
(check-sat)"
{'solver': 'smt2', 'input': '\\{(\\x0 \\y -5) + (\\z + 10) <= 15; \\x1 = (\\x3 + 2) * (\\x4 - 3); \\z = 12; \\v = true; \\w = false;\\n\\(\\x0 < 0 \\n\\n(\\y - 5) * (\\z + 10) <= 15 \\n\\n(\\x1 = (\\x3 + 2) * (\\x4 - 3))\\n\\n(check-sat)'}	{'solver': 'smt2', 'input': '\\{(\\x0 \\y -5) + (\\z + 10) <= 15; \\x1 = (\\x3 + 2) * (\\x4 - 3); \\z = 12; \\v = true; \\w = false;\\n\\(\\x0 < 0 \\n\\n(\\y - 5) * (\\z + 10) <= 15 \\n\\n(\\x1 = (\\x3 + 2) * (\\x4 - 3))\\n\\n(check-sat)'}	"(declare-const n Int)
(declare-const v Int)
(assert (and (<= 1 n) (<= n 10)))
(assert (and (<= 1 v) (<= v 10)))
(assert (distinct n v))
(check-sat)"
Satisfying the constraint that all tasks in a scheduling problem have at least one feasible solution	Use QF_UF and QF_LIA axioms to ensure feasibility, then use modus ponens and contradiction elimination to prove satisfiability.	"(declare-const a Int)
(declare-const at Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 at) (<= at 10)))
(assert (distinct a at))
(check-sat)"
Scheduling Problem: Find the optimal assignment of tasks to machines in a factory	Use QF_UF or QF_LIA constraints and simple integer or boolean constraints to model the problem.	"(declare-const a_to Bool)
(declare-const in_to Bool)
(declare-const of_to Bool)
(assert (= (+
  (ite a_to 1 0)
  (ite in_to 1 0)
  (ite of_to 1 0)
) 1))
(assert (<= (+
  (ite a_to 1 0)
) 1))
(assert (<= (+
  (ite in_to 1 0)
) 1))
(assert (<= (+
  (ite of_to 1 0)
) 1))
(check-sat)"
Satisfy the following system of linear equations with two variables x and y	Use the QF_UF rule to introduce new variables, then use QF_LIA to eliminate them, and finally assert the truth of the resulting equation.	"(declare-const of Int)
(declare-const x Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct of x))
(check-sat)"
Satisfy the constraints of a finite automaton	Use QF_UF and QF_LIA rules to express the constraints of the automaton	"(declare-const a Int)
(declare-const of Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct a of))
(check-sat)"
Satisfy the following linear equations using QF_UF and QF_LIA rules	Use simple integer constraints to represent the relationships between variables.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following constraint using QF_UF and QF_LIA	Use simple integer constraints and   newlines to separate logical statements	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Using QF_UF and QF_LIA rules to derive a valid scheduling plan from a set of constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Resource Allocation Problem	Use QF_UF to model the allocation of resources.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation: Assigning Resources to Tasks	{'variables': ['x', 'y'], 'constraints': ['(set-logic QF_UF)', '(declare-const x Integer)', '(declare-const y Boolean)', '(assert x >= 0)'], 'solver': 'SMT-LIB'}	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA axioms to model this problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Prove that there exists an integer x such that x = 1 and (x + 2) mod 3 = 0	Using the properties of modular arithmetic, we can show that this equation is true for all values of x.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Resource Allocation	Use QF_UF or QF_LIA with simple integer and boolean constraints to solve a resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to ensure valid integer solutions.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
{'name': 'Resource Allocation', 'description': 'A resource allocation problem in a cloud computing environment'}	Using QF_UF and set-logic, we can model this problem as follows:  set-logic QF_UF; assert (declare-const x:integer >= 0); assert (declare-const y:integer > 0); check-sat;	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation: Minimize Number of Server Assignments	(set-logic QF_UF) (declare-const x : integer) (assert (x > 0)) (check-sat)	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF to enforce unit-of-formula equality	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: 3 resources available, 4 requests to allocate	Use QF_UF and QF_LIA constraints to ensure integer solutions are found	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF logic to model this resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA solvers to find an optimal assignment of resources to tasks.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model a resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to define a set of constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	To allocate resources to tasks, we need to minimize waste and maximize efficiency.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use of QF_UF or QF_LIA constraints to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA formulas to model this resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
(set-logic QF_UF (declare-const x int : 1) (assert (equivalent? (add 2 x) (add 5 x)))	Using the properties of arithmetic operations and addition, we can deduce that if (add 2 x) = (add 5 x), then (add 3 x) must be true.	"(assert true)
(check-sat)"
Resource allocation problem	Satisfiability Reasoning and Computation System	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to processes	Using QF_UF and QF_LIA, derive that there exists a valid assignment of resources to each process such that the total resource usage is non-negative.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to ensure fairness in resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: 5 machines, 3 software licenses	Using QF_UF with constraints on machine availability and license usage.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA to model resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to reason about resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to processes	Use QF_UF and QF_LIA constraints to model resource allocation, considering bounds on resources and process demands.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Using QF_UF with set-logic and declare-const constraints to model the allocation of resources between two processes.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation	Using QF_UF with linear constraints to optimize resource usage.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Allocate resources to tasks with minimum latency	{'variables': [{'name': 'latency', 'type': 'int'}], 'assumptions': ['(set-logic QF_UF)', '(declare-const task1-latency 10)', '(declare-const task2-latency 5)'], 'conclusions': ['(assert (leq task1-latency task2-latency 5))']}	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA logical frameworks to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
{'name': 'Resource Allocation', 'description': 'A problem of resource allocation in a computer system', 'satisfiability': False}	{'rule1': '(set-logic QF_UF)', 'rule2': '(declare-const x integer)', 'rule3': '(declare-const y boolean)'}	"(declare-const A_of Bool)
(declare-const a_of Bool)
(declare-const in_of Bool)
(assert (= (+
  (ite A_of 1 0)
  (ite a_of 1 0)
  (ite in_of 1 0)
) 1))
(assert (<= (+
  (ite A_of 1 0)
) 1))
(assert (<= (+
  (ite a_of 1 0)
) 1))
(assert (<= (+
  (ite in_of 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Using QF_UF and set-logic to model resource allocation problem	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
(set-logic QF_UF (declare-const x y Z)	This is a valid program, and it will always find a solution.	"(declare-const Z Int)
(declare-const x Int)
(assert (and (<= 1 Z) (<= Z 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct Z x))
(check-sat)"
Resource allocation: Assigning resources to tasks	Use QF_UF and QF_LIA rules to reason about resource availability	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation	Use QF_UF or QF_LIA to specify the resource constraints and then assert them using set-logic.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to model resource allocation problems, ensuring that resources are allocated in an optimal manner.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF to find valid assignments that satisfy all constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Using QF_UF with set of variables and assertions to solve a resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
\(set-logic QF_UF\) \(declare-const x_0 bool\) \(assert (x_0 = true)\)	\(check-sat\)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to model resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA constraints to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA solvers to find an optimal assignment of resources.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA axioms to reason about resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA quantifiers to model the problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to tasks	Use QF_UF and QF_LIA rules to constrain resource allocation.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation: Minimize the number of machines used in the data center	Use QF_UF and QF_LIA to model this problem, and ensure that it includes  - (set-logic QF_UF) or QF_LIA. Use simple integer constraints for machine utilization.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation: Assigning resources to tasks	Using QF_UF and QF_LIA constraints to ensure fairness in resource allocation, while also ensuring that the system is satisfiable.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Prove that it is possible to allocate resources such that all devices are used and no device is idle	(set-logic QF_UF) # Define the universe of discourse as integers from 0 to N-1 (where N is the number of devices)  (set-logic QF_UF)(declare-const N: int)  (assert (>= N 2))  (check-sat)	"(declare-const is_to Bool)
(declare-const it_to Bool)
(declare-const no_to Bool)
(assert (= (+
  (ite is_to 1 0)
  (ite it_to 1 0)
  (ite no_to 1 0)
) 1))
(assert (<= (+
  (ite is_to 1 0)
) 1))
(assert (<= (+
  (ite it_to 1 0)
) 1))
(assert (<= (+
  (ite no_to 1 0)
) 1))
(check-sat)"
Resource Allocation: Assigning Resources to Jobs	Use QF_UF and QF_LIA constraints, and ensure that all constraints are linear and integer/boolean.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Integer Variables with Bounds	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to servers in a cloud-based data center	Use QF_UF and QF_LIA constraints to model the resource allocation decision.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and set-logic to model resource allocation with multiple constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA logic to reason about resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Using QF_UF and QF_LIA rules, derive a valid solution that maximizes resource utilization.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Minimize the number of printers used	Using QF_UF and QF_LIA constraints, prove that it is not possible to allocate enough printers to satisfy all user requests without exceeding the available capacity.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	To ensure efficient resource allocation, we use the QF_UF and QF_LIA rules.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA theory to reason about resource constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use the QF_UF and QF_LIA logics to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
{'smtplib': 'int(x) <= x + 1'}	Satisfiability with constraints (set-logic QF_UF; assert x > 0; check-sat)	"(assert true)
(check-sat)"
Resource allocation problem	This problem involves allocating resources to tasks with different priorities and constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	To allocate resources efficiently, we need to minimize waste and maximize utilization of available resources.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA to represent resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA rules to model resource allocation problems	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	{'type': 'model-checking', 'description': 'Verify that a resource allocation model satisfies QF_UF and QF_LIA constraints.'}	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use set-logic QF_UF and declare-const to specify resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA rules to formulate a valid resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA solvers, and assert that the program produces exactly one solution.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Maximize production of 5 units while minimizing waste	Using QF_LIA and set-logic QF_UF, the following constraints can be derived.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
{'input': '\\(set-logic QF_UF\\) \\n \\n (declare-const x Int\\n \\n assert (x = 0)\n \\n check-sat)'}	This SMT-LIB program checks if a number is zero	"(declare-const n Int)
(declare-const x Int)
(assert (and (<= 1 n) (<= n 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct n x))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA to model this problem and ensure validity.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: assigning 10 units of CPU to process 1 and 5 units to process 2	Use QF_UF and QF_LIA constraints to model the resource allocation problem. Ensure that the total number of units allocated is exactly 15.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation: 3 cars and 4 passengers	Use QF_UF and set-logic to ensure that each passenger has at least one seat	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation optimization	Use QF_UF and QF_LIA constraints to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation	Use QF_UF and assert/declare/check-sat to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	(set-logic QF_UF) (declare-const x (int)) (assert (not (= 2, 0))) (check-sat)	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA to specify the resource allocation model.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Ensure that the minimum number of units required to satisfy all resource constraints is met	Use QF_UF and QF_LIA to reason about the satisfiability of the program, and check for validity using SMT solver.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF with assert statements to model this problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA rules to ensure feasibility.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: 5 agents, each with capacity 2 and deadline 10	Use QF_UF and QF_LIA rules to prove existence of a solution that satisfies all constraints	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	 - {set-logic QF_UF         assert (2 > 0)}	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to solve this optimization problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA solvers with simple integer constraints to model this problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Ensure that the maximum number of employees is allocated to each department	Use QF_UF or QF_LIA quantifier, and simple integer constraints (e.g., <=) to represent the relationship between departments and employees.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A woman has two coins that total 30 cents. One coin is not a nickel, and one coin is not a quarter. What type of coin are they?	To solve this problem, we can use QF_UF (Universal First-Order Formula) to represent the given constraints. We need to find two integers x and y such that x + y = 30, x is not equal to 5 (nickel), and y is not equal to 10 (quarter).	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
A farmer has a rectangular field with integer coordinates in pixels, and she wants to know if it's possible to place a row of n x m flowers on this field such that no two flowers are adjacent.	This problem can be solved using QF_UF (Unfolding Formulas) or QF_LIA (Linear Arithmetic Inequality).	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
Solve for x: 2*x + 5 = 11	Use QF_LIA and set-logic to model this equation as an equality of integer constraints.	"(assert true)
(check-sat)"
A farmer has a field with 3 rows and 4 columns. Each cell can hold either an integer from 1 to 10, inclusive.	{   (set-logic QF_UF)   (declare-const row1 int   row2 int   row3 int),   (declare-const col1 int   col2 int   col3 int),   (assert (>= row1 1)            (<= row1 10))   (assert (>= row2 1)            (<= row2 10))   (assert (>= col1 1)            (<= col1 4))   (assert (>= col2 1)            (<= col2 3))   (assert (>= col3 1)            (<= col3 4))   (check-sat)}	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
3+2=5	Using QF_LIA, we can assert that the sum of two integers less than or equal to 10 is greater than 1 and less than or equal to 15.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Solve for x: 2*x + 5 = 11	Use QF_LIA with constraints: x >= 0, 2x <= 6	"(assert true)
(check-sat)"
(set-logic QF_UF (declare-const x 1) (assert (>= x 0)) (check-sat)	This is a simple satisfiability problem, where we need to find an assignment of values to the variable x such that all constraints are satisfied.	"(assert true)
(check-sat)"
Solve the following logic puzzle: A bat and a ball together cost $1.10. The bat costs $1.00 more than the ball. If you have 5 times as many bats as balls, how much will you pay?	Let B represent the number of balls and B+ represent the number of bats. From the first equation, we get: B + (B+1) = 10. This simplifies to 2B + 1 = 10, or B = 4.5. Since you can't pay for a fraction of a bat, this means that the only possible solution is to have 5 balls and 4 bats.	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
The Five Switches	Use QF_LIA and set-logic QF_UF to prove that there is exactly one way to program a computer to switch between five lights on, one at a time, while the lights are off.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that there exists an integer x such that x^2 + x - 5 = 0	Use QF_UF and set-logic to prove the existence of a solution, and use check-sat to find it.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The Five Houses	Using set-logic QF_UF and quantifiers, prove that there exists a house on each row such that at least one of its doors is open.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF and QF_LIA to prove that there exists a number between 1 and 3 that has exactly one switch on.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	(set-logic QF_UF) (declare-const x true) (declare-const y false) (declare-const z true)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Five Houses Problem	To solve this problem, we need to use the QF_UF and QF_LIA SMT-LIB rules.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A man, a plan, a canal, Panama!	(set-logic QF_UF   (declare-const X 0 5)   (declare-const Y 5 10))(assert (>= X 1) (<= Y 4))   (check-sat)	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Three Switches	Use QF_UF and assert statements to prove that there is a unique solution to this puzzle.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Five Houses Problem	To solve this puzzle, we need to find a valid assignment of integers from 1 to 5 to the five houses such that no two adjacent houses have more than one occupant.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF to represent three switches, and assert that they are either all on or none of them is on.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has 'a' apples and 'b' bananas in his orchard. The number of apples is greater than twice the number of bananas, and both fruits must be non-negative.	The constraints are: (set-logic QF_UF) (declare-const a int > 0) (declare-const b int > 0) (assert (a > 2 * b) (check-sat)	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
A farmer has three fields: A, B, and C. Field A can hold values 0 through 9. Field B can hold values -1 through 1. Field C can only hold the number 5.	The farmer needs to ensure that field C holds a value of either 0 or 4. If field A holds any other value, then field C must be 0. Otherwise, if field A is 5 or greater, then field B must be -1.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
(set-logic QF_UF   (declare-const x 9)   (declare-const y 10)   assert (>= x 0)   assert (<= y 100)   check-sat)	Satisfiability isomorphism using UFL constraints and linear integer programming.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Satisfy the following set of constraints on the variable x.	Use the quantifier 'for all' to generalize over all natural numbers n.	"(declare-const of Int)
(declare-const on Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 on) (<= on 10)))
(assert (distinct of on))
(check-sat)"
A farmer has 5 sheep and 3 goats. How many animals does she have?	(set-logic QF_UF  (declare-const A int  (A = 5)  (G int  (G = 3)))  (assert < A + G > 0))	"(assert true)
(check-sat)"
The Set of Twin Primes	- Prove that there do not exist two prime numbers p and q such that pq = 2.	"(assert true)
(check-sat)"
A 5-person committee needs to decide on a project leader.	Use QF_UF and assert constraints like (equal (= 1 2)) or (not (equal (= 3 4))).	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
Solve for x: 2x + 5 = 11	Use QF_UF and set-logic (maximize) to find an optimal solution.	"(assert true)
(check-sat)"
The Five Houses Problem	To solve this problem, we need to assign numbers to each of the five houses such that each house is assigned a number between 1 and 5 (inclusive), and no two adjacent houses have the same number.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use the rules provided by the problem to construct a valid solution.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Five Houses Puzzle	To solve this puzzle, we need to find a valid assignment of integers from 1 to 5 to the five houses such that each house is either occupied by an integer or not.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer wants to optimize his irrigation system to minimize water waste.	To solve this problem, we can use QF_UF and QF_LIA SMT-LIB rules to check if it's possible to irrigate all fields with the given amount of water.	"(declare-const A Int)
(declare-const to Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct A to))
(check-sat)"
Solve the following puzzle:  3 x + y = 6, 2x - y = 4.	(set-logic QF_UF) (declare-const x Int) (declare-const y Int) (assert (>= x 0) (assert (>= y 0)) (verify-sat)	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
A person is standing next to a box with an unknown weight. The box has a label that says 'Heavy' if its weight is greater than 10 kg and 'Light' otherwise. The person is holding the box, but they don't know which side it's on. What can be said about the box?	Using QF_UF, we can assert that the box is either Heavy or Light.	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
There are three switches: hot, cold and off.  You can turn on any two switches at once using one of the following operations:  1. Turn on switch A and then off switch B.  2. Turn on switch C and then off switch D.  3. Turn on switch B and then off switch D.  4. Turn on switch A and then turn on switch C.  5. Turn on switch C and then turn on switch D.	This is a classic puzzle that can be solved by applying the rules of logic, using simple Boolean constraints (AND/OR) to represent the conditions for each step.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A man, a plan, a canal, Panama!	(set-logic QF_UF   (declare-const X 0 5)   assert (<= X 0)   check-sat)	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Five Houses Puzzle	To solve this puzzle, we need to use QF_UF constraints to represent the relationships between the houses and their occupants.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF to create a function symbol and apply it to three variables in a predicate.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following statement	Use the QF_UF and QF_LIA rules to generate a model that satisfies this statement.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a linear equation with two variables	Use QF_UF to ensure equality and QF_LIA to allow variable combination.	"(assert true)
(check-sat)"
Find integers x such that x^2 + 1 = x+3	This equation can be solved using QF_UF with the following constraints: (set-logic QF_UF) and (declare-const x integer)	"(assert true)
(check-sat)"
Prove that there exists an integer x such that x^2 + 4x - 7 = 0 and x is even	To prove this, we can use the QF_UF rules to find a model for the equation x^2 + 4x - 7 = 0. We can then analyze the models to determine which ones satisfy the condition that x is even.	"(declare-const an Int)
(declare-const is Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct an is))
(check-sat)"
(set-logic QF_UF (declare-const x 1 x < 5) (declare-const y 2 y = x + 3) assert (>= y 4)	To prove that the assertion is true, we can use a model with x >= 0 and y > 0.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
(set-logic QF_UF) (declare-const x 1) (assert (not (= x 0))) (check-sat)	To prove that x is not equal to 0, we can use the property of equality that if a = b then a = b.	"(assert true)
(check-sat)"
(set-logic QF_UF  define-const X 0  assert (<= X 5)  check-sat	This puzzle requires the solver to find a value for X such that it is less than or equal to 5.	"(assert true)
(check-sat)"
A farmer has a field that is 100 meters long and 50 meters wide. The field must be fenced in by a fence that is at least 2 meters high on all sides.	The farmer can use the following constraints to solve this problem:  - (declare-const field-width 50 :integer) - (declare-const field-length 100 :integer) - (assert (>= (add (multiply field-width 2) (add field-length 2)) (add field-width 2)))	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The set-builder logic asserts that there exists an integer x such that x^2 + 4x - 3 = 0.	\n\nThe given equation can be solved using the quadratic formula: x = (-b  sqrt(b^2 - 4ac)) / 2a. In this case, a=1, b=4, and c=-3. \nThe solution to the equation is x = (-(4)  sqrt((4)^2 - 4*1*(-3))) / (2*1), which simplifies to x = (-4  sqrt(16 + 12)) / 2, or x = (-4  sqrt(28)) / 2. Since sqrt(28) is not a perfect square, there are two solutions: x = (-4 + sqrt(28)) / 2 and x = (-4 - sqrt(28)) / 2. \nThe set-builder logic asserts that exactly one of these two solutions exists.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The Five Houses Problem	Use set-logic QF_UF and declare variables for each house number.  (declare-const house1-number 1) (declare-const house2-number 2) (declare-const house3-number 3) (declare-const house4-number 4) (declare-const house5-number 5)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Find an infinite set {x: [0, 1]}.	This problem can be solved using QF_UF.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that there exists an integer x such that x^2 + 4 = 13	Use QF_UF and set-logic to derive the desired formula.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
(set-logic QF_UF  (declare-const x 1)  (declare-const y 2)	This problem is a simple example of using set-logic QF_UF to reason about the satisfiability of a given formula.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
A farmer wants to ensure that all cows are wearing collars of a certain color.	The farmer has ordered 100 cows, each with one collar. The collar can be either red or blue. Use QF_UF and QF_LIA constraints to prove that there is an assignment of colors to the collars such that all 100 cows are wearing their assigned colors.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Flipped Coins	Use QF_UF with a set of variables and constraints to prove that it's impossible to flip all coins such that one side always shows the opposite number.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Prove that there exists an integer x such that exactly three switches are open.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF to prove that exactly one of three boolean variables can be false at any given time.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Prove that it is impossible to assign colors to three switches such that each switch corresponds to one of three colors and the corresponding color switch is red.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
\(\{\n  x: \n    # Introduce a variable and constraint\n    assert(x > 0);\n  y: \n    # Introduce another variable and constraint\n    assert(y < x);\n  z: \n    # Use SMT-LIB to prove the variables are equal\n  (set-logic QF_UF \n    (declare-const x : int) \n    (declare-const y : int) \n    (declare-const z : bool))\n  \n  assert(z);\n  \n  (check-sat)	\(\{\n  # We use the fact that x > 0 and x + y = z to prove x == z\n  assert(x + y = z + x);\n  \n  # Since z is True, we can deduce x == z\n  assert(x == z);\n  \n  \n  # Use the assumption that x < 0 and x - y = z to prove x != z\n  assert(x > 0 && x - y = z);\n  \n  # Since z is False, we can deduce x != z\n  assert(x != z);\n  \n  \n  \n  (check-sat)	"(declare-const a Int)
(declare-const n Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 n) (<= n 10)))
(assert (distinct a n))
(check-sat)"
A prisoner needs to escape from a cell with multiple locks, each of which has two possible keys: the correct key or the wrong key. The guards enter a room and check one lock at a time in order.	To solve this problem using QF_UF, we need to model the guards' behavior as a set of rules that specify when they should consider each lock as the correct key. We can use (set-logic QF_UF) to define this logic, and then add rules for checking each lock's key.	"(declare-const A Int)
(assert (and (<= 1 A) (<= A 3)))
(declare-const a Int)
(assert (and (<= 1 a) (<= a 3)))
(declare-const and Int)
(assert (and (<= 1 and) (<= and 3)))
(assert (distinct A a and))
(check-sat)"
A woman has two coins that weigh differently. One coin weighs 1 kg and the other weighs 0.9 kg. How much does the lighter one weigh?	Use set-logic QF_UF and assert   (weigh < 1kg)  and (not (weigh = 0.9kg))	"(declare-const A Int)
(declare-const kg Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 kg) (<= kg 10)))
(assert (distinct A kg))
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 0 and x is not odd	To prove this statement, we can use the QF_UF rule to generate a set of solutions for the equation x^2 + 1 = 0. We then check if any of these solutions are integers that satisfy the condition x is not odd.	"(declare-const an Int)
(declare-const is Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct an is))
(check-sat)"
A farmer has two fields, A and B. Field A has 5 apples, and field B has 3 oranges. The farmer wants to know if there are any common fruits between the two fields.	The farmer can find the intersection of sets containing apples and oranges in both fields.	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
A bat and a ball together cost $1.10. The bat costs $1.00 more than the ball. If the ball costs x dollars, how much does the bat cost?	Let b = number of cents in the ball. Then the equation is (100 - b) + b = 110. Solve for b.	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
Satisfying the union of two sets with distinct elements	Use QF_UF and set-builder constraints to model the union of two sets A = {1, 2} and B = {3, 4}. The constraint (set-logic QF_UF) ensures that each element in both sets is present. The constraint (declare-const x : setof int) defines a set of integers containing all elements from both sets. Finally, the constraint (assert all of A | B) asserts that any element in either set is present.	"(assert true)
(check-sat)"
A farmer has two fields, A and B. Field A is 3 units long, while field B is only 2 units long. The farmer wants to know if there are enough spaces on both fields.	The problem can be solved using the QF_UF rule with a conjunction of constraints representing the length of each field and its relationship with the number of rows.	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Satisfying a set of rules on the number of apples	Use QF_UF to generate constraints for the number of apples in each basket and then solve using check-sat.	"(declare-const a Int)
(declare-const of Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct a of))
(check-sat)"
A farmer has two fields: Field A and Field B. If it rains, both fields receive water, but only if it's not too hot.	let (   0:     assert (>= 20 any x) => (x = 'hot')   1:     assert (= 100 any y) => (y = 80)   2:     let (       z: set of string       f0: {x | x = 'hot', x < 20}       f1: {x | x = 'hot', x >= 20, x <= 30}       f2: {x | x = 'hot', x > 30})     assert (in z f0)     & (not in f1 f0)    & (in f2 f1)	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A farmer wants to irrigate all but two rows of his garden, and then water one row. What are the possible values for k?	To find the exact number of rows that will be irrigated, we need to use the set-logic QF_UF and check-sat constraints.	"(declare-const A Int)
(declare-const k Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 k) (<= k 10)))
(assert (distinct A k))
(check-sat)"
"{   'problem': ""Solve the following puzzle: There are three switches, but they are not labelled. Each switch corresponds to one of three light bulbs in a room. Each bulb is either on or off. You can turn the switches on and off as many times as you want, but you can only enter the room one time to observe the bulbs. How can you figure out which switch corresponds to which light bulb?"""	{   (set-logic QF_UF)   (declare-const bulb1 bool   bulb2 bool   bulb3 bool)   (declare-const switches [ bulb1 true    bulb2 false    bulb3 true ]   (assert not (switches[0]            or switches[1]            or switches[2]))   (check-sat)	"(declare-const a Int)
(assert (and (<= 1 a) (<= a 3)))
(declare-const as Int)
(assert (and (<= 1 as) (<= as 3)))
(declare-const in Int)
(assert (and (<= 1 in) (<= in 3)))
(assert (distinct a as in))
(check-sat)"
(set-logic QF_UF (declare-const x int) (declare-const y bool) (assert (>= x 0) (check-sat)	This is a simple problem that can be solved using basic arithmetic and logical constraints. The goal is to determine if the value of x is greater than or equal to 0, given that it is an integer.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
(set-logic QF_UF   (declare-const x y int)   (assert x > 0))	This is a simple logic puzzle where we are asked to prove that if x is greater than 0, then x is positive.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
A farmer has a field that can hold up to 1000 square meters of land. The field is currently empty, and it needs to be fenced in.	The farmer needs to fence in at least 800 square meters of land for this task.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Three Switches	Use set-logic QF_UF and assert/declare/declare-const to model a problem where a person has three switches, labelled A, B and C, and each switch corresponds to one of three light bulbs in a room. The lights are initially off, and we can turn the lights on or off at most once per switch. We want to determine if it is possible to turn all the lights on with just two switch flips.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
(set-logic QF_UF (declare-const x y 1))	(assert y = 1) && (check-sat)	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
The Three Switches	{'type': 'deductive', 'constraints': ['\n  assert (x = 0)\n', '\n  assert (y = 1)\n', '\n  assert (z = 2)\n']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use set-logic QF_UF and assert/unify to prove that there is no valid assignment of colors to switches such that each switch corresponds to either red or green.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the following system of linear equations with integer coefficients and constraints	Use QF_LIA or QF_UF to generate the model, then solve it using a solver like DPLL or CDT.	"(assert true)
(check-sat)"
(set-logic QF_UF (declare-const x 1 #t) (declare-const y 2 #f) (assert (x = true) (y = false)))	to prove that x and not y are both true or both false using only basic arithmetic operations and equality checks	"(declare-const f Int)
(declare-const t Int)
(assert (and (<= 1 f) (<= f 10)))
(assert (and (<= 1 t) (<= t 10)))
(assert (distinct f t))
(check-sat)"
The set of all perfect numbers	This is a classic problem in number theory, and it can be solved using QF_UF with constraints such as (forall x (<= 1000) (odd? x))	"(assert true)
(check-sat)"
Solve the puzzle: 5 cars are parked on the street, and each car has a different color. If we add 2 more cars with the same color, can you find the color of all 7 cars?	Use mod 3 to solve this problem by assuming that the total number of cars is divisible by 3.	"(declare-const If Int)
(declare-const a Int)
(assert (and (<= 1 If) (<= If 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct If a))
(check-sat)"
A farmer has a field with two rows and two columns. Each cell in the field can be either red or green. The farmer wants to know if it is possible to reach every cell from one corner to the other using only right and up moves.	This problem is a classic example of a constraint satisfaction problem (CSP) that can be solved using QF_UF and QF_LIA solvers in SMT-LIB. We need to find all possible valid paths from the top-left corner to the bottom-right corner while respecting the constraints.	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
Satisfy the following proposition: 2 + 2 = true.	This can be proved using the QF_UF rule and simple arithmetic constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use a model with three variables and two constraints to solve this puzzle.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given integers a and b, find all pairs of distinct positive integers c and d such that a + b = c + d	Prove the validity of the following system using QF_UF or QF_LIA with integer constraints: (set-logic QF_UF)   (declare-const a Int)   (declare-const b Int)   (declare-const c Int)   (declare-const d Int)   (assert (a + b = c + d))   (check-sat)	"(declare-const a Int)
(declare-const b Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 b) (<= b 10)))
(assert (distinct a b))
(check-sat)"
Prove that the following statement is true: x = 5 and y != 3	Use the QF_UF rule to combine the assertions of x = 5 and y != 3, then use the QF_LIA rule to prove the conjunction of these two statements. Finally, add a check-sat clause to verify that the system is satisfiable.	"(declare-const is Int)
(declare-const x Int)
(assert (and (<= 1 is) (<= is 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct is x))
(check-sat)"
Solve the following puzzle: A bat and a ball together cost $1.10. The bat costs $1.00 more than the ball. If the ball costs x dollars, how much does the bat cost? y.	$y-x=0.10\quad$y>x$	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
A 5-person committee must be formed from a group of 8 people, and each person can only speak on one topic.	Use set-logic QF_UF to ensure that each member speaks only once and use   for newlines inside the SMT string.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Five Houses Puzzle	Use QF_UF to express that each house is occupied by either a person or an animal.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has N cows to milk. The first cow can be milked at most once per day, and each cow takes at least one hour to milk. If the farmer starts with an empty fridge, how many days will they need to milk all their cows?	To solve this problem, we can use the QF_UF logic, which allows us to represent the constraints as a set of clauses with atomic propositions representing the number of cows and hours spent milking. We can then use the 'check-sat' solver to find an optimal solution.	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
The Three Switches	(set-logic QF_UF) (declare-const x 1) (assert (x = 0)) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has two fields, A and B. Field A contains all the apples from both fields combined. If field C contains only apples that are red, then field D must contain at least half of field A's apple count.	Use QF_UF and QF_LIA to solve this problem. Consider the constraints (set-logic QF_UF) and (declare-const ...). Use assert statements to define field A and field B. Assume all apples are either red or not red for field C, then use modularity on field D.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A farmer has 5 sheep and wants to build a fence around them. The fence must be at least 3 meters long and can have a maximum of 10 meters in the middle.	Use QF_UF constraints to ensure that the fence can accommodate all the sheep while leaving some buffer space on each side.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
A farmer has 'm' chickens and wants to know if they are all happy.	The answer is yes if and only if m = 5 or m = 6	"(declare-const A_friend_if Bool)
(declare-const if_friend_A Bool)
(assert (= A_friend_if if_friend_A))
(assert (= true A_friend_if))
(check-sat)"
The Life of Pi	Use QF_UF and assert constraints on pi, x, and y.	"(declare-const Pi Int)
(declare-const of Int)
(assert (and (<= 1 Pi) (<= Pi 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct Pi of))
(check-sat)"
A farmer has three fields: A, B and C. Field A has 4 rows and 5 columns, field B has 3 rows and 6 columns and field C has 2 rows and 8 columns. The farmer wants to know how many hot peppers are in each field.	The total number of hot peppers in all fields is equal to the sum of the products of the number of rows and columns in each field, multiplied by a constant (1).	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
\(\(\{1:2, 3:4} \) -> (false))	(set-logic QF_UF) (declare-const X int) (assert (X = 1) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
(set-logic QF_UF) (declare-const x 1  # t) (assert (<= 0 (and x 2) (add 3 x))) (check-sat)	"Using the <a href=""https://www.sat.inf.u-bremen.de/"">SAT solver</a> to verify the satisfiability of the given formula. We found that it is unsatisfiable for all values of x."	"(declare-const t Int)
(declare-const x Int)
(assert (and (<= 1 t) (<= t 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct t x))
(check-sat)"
The Three Switches	"(set-logic QF_UF 	(declare-const x 1) 	(declare-const y 2) 	(assert (not (= x 0))) 	(check-sat)"	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	QF_UF and set-logic QF_LIA	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has 5 rows of flowers in her garden, and each row can have at most 3 flowers. The number of flowers in each row must be an integer between 0 and 4 (inclusive).	The number of flowers is a valid integer.	"(declare-const A Int)
(declare-const an Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 an) (<= an 10)))
(assert (distinct A an))
(check-sat)"
Satisfying a simple equation	Use <~{ to enforce an inequality, and <~~ to enforce equality.	"(assert true)
(check-sat)"
Satisfying the Chicken McNugget Theorem	The Chicken McNugget Theorem states that the sum of two relatively prime numbers has a unique representation as a linear combination of those two numbers. Prove this theorem using QF_UF and SMT-LIB.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use a switch statement to determine which color shirt to wear based on the day of the week.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has three fields of wheat: Field A, Field B, and Field C. Each field can hold either 0 or 1 units of wheat. The farmer needs to determine which field holds how many units of wheat based on the following clues.	Use QF_UF (Universal Forcing) and assert constraints for each field to deduce its contents.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A farmer has two fields, A and B. Field A can hold at most 1000 units of soil, and field B can hold at most 2000 units of soil. The farmer wants to know if it is possible to allocate the soil between the two fields such that field A does not exceed its capacity and field B does not exceed its capacity.	use QF_UF to add constraints on the number of units in each field, check-sat to verify the validity of the constraints	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Solve the following logic puzzle: There are three switches, but they are not labelled. Each switch corresponds to one of three light bulbs in a room. Each bulb is either on or off. You can turn the lights on and off as many times as you want, but you can only enter the room one time to observe the bulbs.	Use QF_UF to model the switches and their corresponding light bulbs. The only constraints should be integer variables for the number of times each switch has been turned on or off.	"(declare-const a Int)
(assert (and (<= 1 a) (<= a 3)))
(declare-const as Int)
(assert (and (<= 1 as) (<= as 3)))
(declare-const in Int)
(assert (and (<= 1 in) (<= in 3)))
(assert (distinct a as in))
(check-sat)"
The set of all perfect squares between 0 and 100	Use QF_UF to express that a number is either even or odd, then use the property (forall x (x = 0) -> (not (x^2))) to assert that there are no perfect squares less than 100.	"(assert true)
(check-sat)"
The Five Houses Problem	Use QF_UF and QF_LIA solvers to prove the following statement: There exists an integer x such that x^2 + x + 1 = 5x + 4 or (x == 0 and y == 2) or (x == 3 and y == 1)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
\u03c0\u202f\u2228\u221a\u203b\u2153\u2192\u2115\u20d1\u2164\u217e\u22cc\u2202\u2189\u2164\u223b\u2193\u214f\u2187\u212a\u215c\u2236\u219d\u2210\u2135\u2188\u217c\u2221\u218a\u216f\u220e\u2192\u211c\u2153	\u03b7\u2129\u20ac\u201d\u2060\u2035\u2130\u2211\u2148\u218a\u2164\u217e\u22cc\u2202\u218f\u2153\u219b\u222c\u2207\u2189\u207d\u2066\u2120\u20ac\u201d\u2035\u2130	"(declare-const u2115 Int)
(declare-const u2135 Int)
(assert (and (<= 1 u2115) (<= u2115 10)))
(assert (and (<= 1 u2135) (<= u2135 10)))
(assert (distinct u2115 u2135))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that two people are friends if and only if they have a mutual friend	Use QF_UF to prove the biconditional, and use set-logic to add the necessary constraints	"(declare-const a_friend_if Bool)
(declare-const if_friend_a Bool)
(assert (= a_friend_if if_friend_a))
(assert (= true a_friend_if))
(check-sat)"
(set-logic QF_UF   (declare-const x int)   (assert (not (= x 0)))   (check-sat)	The assertion will only be true if x is not equal to 0.	"(assert true)
(check-sat)"
Social inequality	Use QF_UF to model the relationship between income and education level, where higher income leads to higher education level.  (declare-const X (integer : LessThan 5))  (declare-const Y (integer : GreaterThan 0))  (assert (QF_UF (     X Y              <= 4 ? true : false) )	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given a social network with people of different ages, find all pairs of individuals who are friends.	To solve this problem, we can use QF_UF and check-sat constraints to derive the friendships between people. We can first list all possible pairs of individuals, then constrain each pair using simple integer or boolean constraints (e.g., `age(a, b) <= 18 && age(b, a)`), and finally check for satisfiability.	"(declare-const a_friend_of Bool)
(declare-const of_friend_a Bool)
(assert (= a_friend_of of_friend_a))
(assert (= true a_friend_of))
(check-sat)"
Prove that there exists an integer x such that x + 1 = 3 and x - 2 > 0	Use the QF_UF rule to combine x + 1 = 3 with x - 2 > 0 to get (x+1) - (x-2) = 5 > 0	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The given social constraint is inconsistent and cannot be satisfied by any assignment of integers or booleans.	A valid solution would require the existence of a finite set of integer values that can satisfy all constraints simultaneously.	"(declare-const be_of Bool)
(declare-const be_or Bool)
(declare-const by_of Bool)
(declare-const by_or Bool)
(declare-const is_of Bool)
(declare-const is_or Bool)
(assert (= (+
  (ite be_of 1 0)
  (ite by_of 1 0)
  (ite is_of 1 0)
) 1))
(assert (= (+
  (ite be_or 1 0)
  (ite by_or 1 0)
  (ite is_or 1 0)
) 1))
(assert (<= (+
  (ite be_of 1 0)
  (ite be_or 1 0)
) 1))
(assert (<= (+
  (ite by_of 1 0)
  (ite by_or 1 0)
) 1))
(assert (<= (+
  (ite is_of 1 0)
  (ite is_or 1 0)
) 1))
(check-sat)"
Prove that John and Mary are married	Use QF_LIA and assert the following equations to prove this statement, then check-sat.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Ensure that no two people in a friendship network have more than one connection to each other	"model  	 globeforall x y z:  		headgedd (x, y)  		and  		( x  eq z |  			not ( 			y, z)  	))"	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (= a_friend_in in_friend_a))
(assert (= true a_friend_in))
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 2x and x is less than or equal to 10	{'method': 'modelChecking'}	"(declare-const an Int)
(declare-const is Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct an is))
(check-sat)"
Prove that there exist two distinct integers x and y such that x + y = 5	Using QF_UF with constraints x >= 0, y <= 5, and x + y = 5, derive the existence of a solution.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that it is not possible to construct a directed acyclic graph (DAG) with more than 5 nodes and 10 edges.	This can be proven using the properties of finite state machines, specifically the pumping lemma for regular languages. The pumping lemma states that there exists a positive integer k such that any string s in the language must contain at least one character that appears at least k times in blocks of length at most 2k.	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Prove that there exists an integer x such that x^2 + 4 = 8 and x^2 - 3 < 0.	This problem can be solved using the QF_UF rule, which states that for any formula f(X) of type 'quantifier-free' with one free variable X, we have either f(X) or f(X). We will use this rule to derive a contradiction. First, we show that 3^2 - 4 = 5 and 3^2 + 4 > 8. Then, we can conclude that there exists an integer x such that x^2 < 0.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that 'John' is not equal to 'Alice'	Use QF_UF with set-logic and assert constraints.	"(declare-const is Int)
(declare-const to Int)
(assert (and (<= 1 is) (<= is 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct is to))
(check-sat)"
Prove that there exists an integer $x$ such that x^2 + 3x - 4 = 0	The quadratic equation has at least one real root according to the Fundamental Theorem of Algebra, and we can show this by attempting to solve it manually.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that there exists an integer x such that x > 0 and (x + 1) mod 3 = 2	Using the properties of modular arithmetic, we can derive that if x is positive, then (x + 1) mod 3 must be equal to 2. This implies that there exists a unique integer solution for x.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that John and Mary are married.	(set-logic QF_UF) (declare-const John mary : pair (string , string)) (assert (John mary) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that a person is not married to themselves.	(not (set-of-facts (set-of-constants 'x) (set-of-constants 'y)))	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Prove that for all integers n >= 2, (1 + n) mod 3 = 0.	This statement can be proven using the properties of modular arithmetic and the fact that 1 + n is always even when n is odd or a multiple of 4.	"(assert true)
(check-sat)"
Prove that there are at least two distinct social connections between individuals in a small community.	Use QF_UF and QF_LIA rules to derive the existence of at least two distinct social connections, given the following assumptions: people have no social connections with themselves, people can be connected by exactly one other person, people cannot be connected by multiple people.	"(declare-const a Int)
(declare-const at Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 at) (<= at 10)))
(assert (distinct a at))
(check-sat)"
Verify that the following relation holds: (x, y) <- (x, z) && (y, z)	Use QF_UF and QF_LIA rules to derive the implication.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that it is impossible to have two people who are friends with each other	{'description': 'Use QF_UF and set-logic to model this relationship.', 'smtlib': 'set-logic QF_UF\ndeclare-const Alice:Int\ndeclare-const Bob:Int'}	"(declare-const is_friend_it Bool)
(declare-const it_friend_is Bool)
(assert (= is_friend_it it_friend_is))
(assert (= true is_friend_it))
(check-sat)"
Given the following social network structure: [1, 2; 2, 3; 3, 4], define the minimum number of friendships required to satisfy all constraints.	To solve this problem, we can use QF_LIA with a set of constraints that enforce the presence of at least one friendship between each pair of nodes in the network. We can then check if the resulting model is satisfiable using check-sat.	"(declare-const of_friend_to Bool)
(declare-const to_friend_of Bool)
(assert (= of_friend_to to_friend_of))
(assert (= true of_friend_to))
(check-sat)"
Prove that any two people are connected in a social network	Use QF_UF and QF_LIA rules to reason about graph connectivity	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Verify that a social relationship graph is consistent.	{   (set-logic QF_UF)   (declare-const person1 person2 : FRIENDS)   (assert (forall (x person)         (           (person1 x)                        (person2 x))         (not (eq x x)))   )	"(declare-const a_friend_is Bool)
(declare-const is_friend_a Bool)
(assert (= a_friend_is is_friend_a))
(assert (= true a_friend_is))
(check-sat)"
Prove that two people are friends if and only if they share a common interest.	Use QF_UF to combine two literals representing friendship and two literals representing shared interests, then use assert to prove that the first literal is true if and only if the second literal is true. Finally, check-sat to verify that the system satisfiable.	"(declare-const a_friend_if Bool)
(declare-const if_friend_a Bool)
(assert (= a_friend_if if_friend_a))
(assert (= true a_friend_if))
(check-sat)"
Determine whether a person is married to their spouse	Use QF_LIA and (set-logic QF_UF) with valid constraints to prove that a person is not married to their spouse.	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Prove that there does not exist an integer x such that x^2 + 1 = 0	This statement can be proven using the QF_LIA theory, specifically by assuming x is an integer and then deriving a contradiction.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that if person A is friends with person B and person C, then person A and person C are connected by a friendship chain	Use QF_UF to represent friendships between people and QF_LIA to ensure the structure of the friendship graph is consistent.	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Determine if all people in a social network have at least one friend.	Use QF_UF and assert statements to model relationships between individuals, then use the check-sat solver to verify validity.	"(declare-const a_friend_at Bool)
(declare-const at_friend_a Bool)
(assert (= a_friend_at at_friend_a))
(assert (= true a_friend_at))
(check-sat)"
Prove that there exist two people in a social network such that they are friends and not spouses.	Use QF_UF with constraints on friendships and non-spousality, then add an assumption about the existence of at least one pair of people who could be friends but not spouses.	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (not a_friend_in))
(assert (not in_friend_a))
(check-sat)"
Prove that there does not exist an integer k such that k^2 + 5k - 6 = 0	(assert (integer s) (> 0 ? 1 : 2)) (assert (syms x k real) > 0) (assert (satisfies (e (univariate x) (- 6 x 6 k^2 + 5 k))) > 0) ((set-logic QF_UF) (declare-const s real)) ((check-sat))	"(declare-const an Int)
(declare-const k Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 k) (<= k 10)))
(assert (distinct an k))
(check-sat)"
Determine whether it is possible to construct a social network where all individuals are connected and no two individuals are friends	The graph of friendships can be represented as an undirected graph with weighted edges, where each edge has a weight representing the strength of the friendship. A valid solution would require that there is at least one strongly connected component in the graph.	"(declare-const a_friend_is Bool)
(declare-const is_friend_a Bool)
(assert (= a_friend_is is_friend_a))
(assert (= true a_friend_is))
(check-sat)"
Prove that if Alice is friends with Bob and Bob is friends with Charlie, then Alice is friends with Charlie	Use QF_UF with constraints that express the friendship relationships as valid integer solutions. Ensure the model is satisfiable by checking for consistency.	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (= if_friend_is is_friend_if))
(assert (= true if_friend_is))
(check-sat)"
Prove the following sentence is valid in QF_UF	Use the set-logic QF_UF and assert statements to derive the sentence.	"(declare-const in Int)
(declare-const is Int)
(assert (and (<= 1 in) (<= in 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct in is))
(check-sat)"
Given a person A with age 25 and friend B, prove that if A's friends are all friends of C then A is friends of B.	(declare-const A Person (0: 1) (declare-const B Person (0: 1) (declare-const C Person (0: 1))  (   (            (forall x (Person (x)) (         (set-of y (Set-of-z) z)))        ) )  (   (assert (or (A= B) (All-of-A-Friend-Of-B-C A C))))	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Prove that if person1 is friends with person2 and person3, then person4 is not friends with person5.	{'method': 'existential', 'variables': ['person1', 'person2', 'person3', 'person4', 'person5'], 'constraints': ['(set-logic QF_UF)\n\n', '(declare-const person1 person1)\n', '(declare-const person2 person2)\n', '(declare-const person3 person3)\n', '(assert (person1 <> person2))\n', '(assert (person1 <> person3))\n', '(assert (not (person4 <>) (person5 <)))']}	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (not if_friend_is))
(assert (not is_friend_if))
(check-sat)"
The relationship 'John Doe' and 'Jane Smith' are friends.	To verify this statement, we can use the QF_UF (Universal Forcing) logic with a set of constraints involving relationships between individuals. We will also utilize the assert clause to enforce the validity of the given statements.	"(declare-const X_friend_Y Bool)
(declare-const Y_friend_X Bool)
(assert (= X_friend_Y Y_friend_X))
(assert (= true X_friend_Y))
(check-sat)"
The given social network of friends has exactly 5 people.	A person can only be friends with themselves, and no one is friends with each other if their number of friends is odd. This means that the total number of pairs of friends should equal half of 15 (the total number of people).	
Prove that there exists an integer x such that x + 1 = 2x	Use the QF_UF and QF_LIA rules to derive the desired consequence.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that there are no cycles in the graph G = ({a, b, c}, R), where R is an undirected relation and 'a' and 'b' are related to each other, but not both.	Use QF_UF and set-logic to reason about the satisfiability of this graph. Assume X = {a, b} such that X  G. Prove by contradiction that there exists a path from a to c in G if and only if for all y  X, (y, x)  R.	"(declare-const G Int)
(declare-const R Int)
(assert (and (<= 1 G) (<= G 10)))
(assert (and (<= 1 R) (<= R 10)))
(assert (distinct G R))
(check-sat)"
Pigeonhole Principle	Given n pigeons and m pigeonholes, show that at least one pigeonhole must contain more than one pigeon.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The following social relationship constraint is valid: P(x, y) |= Q(x, z), where P, Q are predicates and x, y, z are atoms.	To prove the validity of this constraint, we need to show that it is satisfiable using a finite model.	"(declare-const P_friend_Q Bool)
(declare-const Q_friend_P Bool)
(assert (= P_friend_Q Q_friend_P))
(assert (= true P_friend_Q))
(check-sat)"
Verify that a social constraint involving two individuals and their relationships holds true	{'method': 'existential quantification'}	
Prove that all employees in the company are working	Using set-logic QF_UF and QF_LIA, derive the following implications: (set-of-people employee1 ... employee5) => (work(employee1, employee2), work(employee3, employee4), work(employee5, employee6))	"(assert true)
(check-sat)"
Prove that John and Mary are married	(set-logic QF_UF) (declare-const John mary : bool) (assert (== John mary)) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that if person1 is friends with person2, and person2 is friends with person3, then person1 is friends with person3.	Use the transitive property of friendship to prove this implication.	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (= if_friend_is is_friend_if))
(assert (= true if_friend_is))
(check-sat)"
Prove that a person is either in their hometown or not.	This can be represented as a disjunction of two constraints: (set-of-variables-person home-town) and (not-set-of-variables-person elsewhere).	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Find all pairs of people in a social network where one person is friends with another.	Use QF_UF to model friendship relationships and check-sat to solve the problem	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (not a_friend_in))
(assert (not in_friend_a))
(check-sat)"
Prove that any person is either a student or an employee of the same company.	{   (set-logic QF_UF)   (declare-const C (Symbol('Company'))   (declare-const S (Symbol('Student'))   (declare-const E (Symbol('Employee'))   (assert (not (or (= C S) (= C E))))   (assert (not (and (= S C) (= E C)))   (assert (not (or (= S E) (= C E)))))   (check-sat) }	"(declare-const a Int)
(declare-const an Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 an) (<= an 10)))
(assert (distinct a an))
(check-sat)"
Prove that a person is either married to their spouse or not married at all	Use QF_UF and assert variables for marriage status, then check-sat	"(declare-const a Int)
(declare-const at Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 at) (<= at 10)))
(assert (distinct a at))
(check-sat)"
Prove that John and Mary have different favorite sports.	Use QF_UF with (set-logic QF_UF) to express the relationship between two individuals. Then, use (assert ...) to assert a specific property about their preferences. Finally, check-sat to prove this property holds true.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that John and Alice are friends.	(john = alice) -> (friend john alicia)	"(declare-const X_friend_Y Bool)
(declare-const Y_friend_X Bool)
(assert (= X_friend_Y Y_friend_X))
(assert (= true X_friend_Y))
(check-sat)"
A university has two social constraints regarding friendships between students.	These constraints can be represented using QF_UF and QF_LIA axioms.	
Prove that a person is either in the US or has a valid US driver's license.	Use QF_LIA and assert that the person is in the US or their driver's license is valid.	"(declare-const US Int)
(declare-const a Int)
(assert (and (<= 1 US) (<= US 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct US a))
(check-sat)"
Prove that every person has at least one friend	Use QF_LIA and QF_UF to model the friendship relationship between people	"(declare-const at_friend_has Bool)
(declare-const has_friend_at Bool)
(assert (= at_friend_has has_friend_at))
(assert (= true at_friend_has))
(check-sat)"
Satisfies QF_UF rule with a valid JSON payload	"{'solver': 'CPVEX', 'input': '{""solution"": ""1"", ""constraints"": [""x + y = 2""]}', 'expected_solution': '[0, 3]'}"	"(assert true)
(check-sat)"
The social network has a relationship between John and Alice, but they are not friends.	{'constraints': ['(set-logic QF_UF)\n', '(declare-const person1 person2)\n', '(assert (not (person1 = person2)))\n', '(check-sat)']}	
\(set-logic QF_UF\) \(declare-const x = 5\) \(assert \((\u'== 4\)\))	This proof uses QF_UF to prove a simple equality and QF_LIA to derive the truth of the assertion.	"(declare-const u Int)
(declare-const x Int)
(assert (and (<= 1 u) (<= u 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct u x))
(check-sat)"
The relationship between person A and person B is that they are friends.	This can be expressed as (set-logic QF_UF)      (declare-const personA personA   declare-const personB personB   assert (personA == personB))   (assert (not (personA != personB)))	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
\(set-of\(\{x| x #= 1\} \) && \(set-of\(\{y| y #!= 2 && !x || y #<= 3\} \))\)	\(declare-const x 1; \(declare-const y 2; \(assert (xor (and (not (eq x 1) (neq x 2)) (not (eq x 1) (lt x 3))) (and (neq x 1) (gt x 3)));\)	"(declare-const of Int)
(declare-const x Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct of x))
(check-sat)"
Prove that there exists an integer x such that 2*x + 3 >= 5 and x^2 <= 4	Use QF_UF to model the system of linear inequalities: 2x + 3 >= 5 --> 2x >= 2 --> x >= 1; x^2 <= 4 --> x <= -2	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that for all integers x and y, if x > y then x + y = 2y	Using QF_UF with the set of integers and the implication rule, derive the following:   (declare-const x Int) (declare-const y Int) (assert (x > y)) (check-sat)	"(declare-const if Int)
(declare-const x Int)
(assert (and (<= 1 if) (<= if 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct if x))
(check-sat)"
{'solver': 'QF_UB', 'reasoning': '(set-logic QF_LIA (declare-const x 0: INTEGER) (assert (>= x 1)) (check-sat))'}	(assert (>= 2 3)) (check-sat)	"(assert true)
(check-sat)"
Prove that if Alice and Bob are friends, then Carol is also friends with both of them.	(set-logic QF_UF)                (declare-const alice friend bob)     (assert (not (friend bob alice)))     (declare-const carol friend alicebob)     (assert (and (friend alicebob carol) (friend alice carol)))	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (= if_friend_is is_friend_if))
(assert (= true if_friend_is))
(check-sat)"
Prove that there are no friends among five people.	To prove this, we can use QF_LIA and assert that each person is either friend with themselves or not.	
A person is either married to their spouse or in a consensual relationship with someone else.	This property can be expressed using QF_UF (Unions of First-Order) and constraints such as <person> marry <other_person>	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
Verify that there are no social connections between all individuals in a network of 10 people with no mutual friends	Use QF_UF to model the relationship as a graph, and then use QF_LIA to check if the graph is acyclic. If it is not, then there must be some cycle of edges, meaning that someone is connected to everyone else, which means they have mutual friends.	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (= a_friend_in in_friend_a))
(assert (= true a_friend_in))
(check-sat)"
(set-logic QF_UF (declare-const x y z (integer :pred <)) (assert (not (= x 5))) (check-sat)	(check-sat)	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that there exist distinct integers x, y such that x + y = 3 and x  y	Using QF_UF and the constraints x + y = 3 and x  y, derive a contradiction if neither x nor y is equal to zero.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that a person who has friends with people they know personally and strangers, but does not have acquaintances outside of their social circle, cannot be a friend to any one specific stranger.	Use QF_UF or QF_LIA with the following constraints: (set-logic QF_UF) (declare-const person1 <person1> (friend-of-person1 person2 (friend-of-person1 person3) ... (not acquaintances person4 person5))) (assert (for-all x (forall y (not friend-of-person1 y x))) (not (in-a-social-circle x)))	"(declare-const a_friend_be Bool)
(declare-const be_friend_a Bool)
(assert (not a_friend_be))
(assert (not be_friend_a))
(check-sat)"
Prove that there exist non-empty sets A and B of people such that A  B = 	"The following set constraints ensure the existence of such sets:  - A (A  X)   	B (B  A);"	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
Social Network Problem	The following friendship relationships hold: (Alice, Bob), (Bob, Charlie), (Charlie, Alice). Find the maximum number of friends each person can have.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given two people A and B, where person A is related to person B by marriage if A's age is greater than B's age.	Use QF_UF or QF_LIA with set-logic to express the relationship between ages of individuals for any positive integers n and m (where n <= m).	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
Prove that if person A has degree 3 and person B has degree 4, then person A's age is greater than or equal to person B's age	This implication can be proved using QF_UF or QF_LIA.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
Prove that there exists an integer x such that x^2 = 5 and x^4 + 2x^2 - 1	Use QF_UF to reason about the existence of a solution and then use QLIA to solve for x.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that two people are acquaintances if they have met at least once	(set-logic QF_UF) (declare-const person1 :: int) (declare-const person2 :: int) (assert (person1 = person2)) (check-sat)	"(declare-const at Int)
(declare-const if Int)
(assert (and (<= 1 at) (<= at 10)))
(assert (and (<= 1 if) (<= if 10)))
(assert (distinct at if))
(check-sat)"
Given the social network of individuals with attributes 'name' and 'relationship_type', find the maximum number of people who are directly related to each other.	This can be solved using QF_UF or QF_LIA, where we express a relationship between two individuals as an equivalence relation. We then use the fact that the size of an equivalence relation is equal to the number of pairs of distinct elements in the set. This allows us to compute the maximum number of people who are directly related to each other.	"(declare-const of_friend_to Bool)
(declare-const to_friend_of Bool)
(assert (= of_friend_to to_friend_of))
(assert (= true of_friend_to))
(check-sat)"
Prove that there exists an integer x such that x + 1 = 2 * x	Use QF_UF and set-logic to prove the statement	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that a person can go to exactly two different cities if they travel between cities in different countries.	Using the QF_UF model with a set of cities and countries, prove that the person's travel history is consistent.	"(declare-const a Int)
(declare-const can Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 can) (<= can 10)))
(assert (distinct a can))
(check-sat)"
Prove that a person is either married or single.	(set-of-values x:Person; (set-of-assertions x:-single | x:-married))	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Use QF_LIA to express the relationship between friends and their relationships with others.	Use QF_UF with a set of 'not' constraints to express the relationship between individuals.	
Find all triples (a, b, c) where a has degree 2 in graph G and b is adjacent to both a and c	Use QF_LIA constraints to enforce the properties of the relationships.	"(declare-const G Int)
(declare-const a Int)
(assert (and (<= 1 G) (<= G 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct G a))
(check-sat)"
Find all pairs of distinct people in a university with exactly one common friend.	Use QF_UF to model this relationship and QLIA to restrict the number of friends each person can have.	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (= a_friend_in in_friend_a))
(assert (= true a_friend_in))
(check-sat)"
The set of all prime numbers less than or equal to 100	{(set-logic QF_UF) {(declare-const P UU)   assert (forall (x UU) ( eg ((xor x P) (xor P x))))	"(declare-const of Int)
(declare-const or Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 or) (<= or 10)))
(assert (distinct of or))
(check-sat)"
The given social relationship is valid.	Use QF_UF and set-logic QF_UF to ensure validity of constraints.	
Prove that every person is related to themselves.	Use QF_UF to assert that each person is connected to at least one other person, and then use QF_LIA to conclude that there are no cycles in the graph.	"(declare-const is Int)
(declare-const to Int)
(assert (and (<= 1 is) (<= is 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct is to))
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 0	Use QF_UF and set-logic to reason about the existence of solutions to this equation.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that if person A is friends with person B, and person B is friends with person C, then person A is friends with person C	Use QF_UF and QF_LIA constraints to derive the desired implication. Use the following assumptions: (A,B) and (B,C), and (C,A).	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Prove that for all integers n >= 5, n^2 + n - 13 > 0	The following statements are true:  - set-logic QF_UF - set-logic QF_LIA - declare-const n_ int - declare-variable x int - assert (x = 5) - assert (x^2 + x - 13 > 0)	"(assert true)
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 4x and 2x > 0	Using QF_UF with the set of variables {x} and the constraints from the problem statement, we can derive the following expression: 2 * (x^2 - 4) = 0. Solving for x, we get x = 16. Therefore, there exists an integer solution to the equation.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The friends of Alice are married, but Bob is not	To ensure this is true, we need to assert that (set-of-people x y) != (set-of-people x z)	"(declare-const is_friend_of Bool)
(declare-const of_friend_is Bool)
(assert (not is_friend_of))
(assert (not of_friend_is))
(check-sat)"
Prove that there exists an integer x such that x^2 + 4x - 3 = 0	To prove this equation has a solution, we can use the fact that it is a quadratic equation with two roots. We can also use the method of completing the square to simplify the equation.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that a person is not a friend of themselves	Use   to separate the reasoning into two parts: first, prove that an individual is friends with another if they have at least one movie in common, and second, prove the converse	"(declare-const a_friend_is Bool)
(declare-const is_friend_a Bool)
(assert (not a_friend_is))
(assert (not is_friend_a))
(check-sat)"
Prove that there exists an integer x such that 2*x + 3 >= 0	To prove this, we can use the QF_UF logic with 2*u + 3 <= -u for u >= 0. This is because for any non-negative integer u, 2*u + 3 will always be greater than or equal to 1, satisfying the condition.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The following social constraint is invalid: \nIt states that Alice and Bob are friends when they do not have a mutual friend, which is a contradiction.	\nTo resolve this conflict, we can add constraints to ensure that if Alice is friends with X, then X must also be friends with Alice. This can be achieved using the following QF_UF clause: (\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n)	"(declare-const a_friend_do Bool)
(declare-const do_friend_a Bool)
(assert (not a_friend_do))
(assert (not do_friend_a))
(check-sat)"
Prove that there does not exist an ordered pair of integers (x, y) such that x = 2 and y = 4	This statement can be proven using the QF_UF rule and the fact that x cannot be both even and odd.	"(declare-const an Int)
(declare-const of Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct an of))
(check-sat)"
Prove that there exists an integer x such that x + 1 = 2*x	"\begin{align*} (\exists x (\forall y (y < x \ 2*y == x+y))) &
ightarrow ((\exists z (z >= 0 \ z != -1)))) \end{align*}"	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Satisfying the social constraint: No two people in the same group.	Use QF_UF or QF_LIA to ensure that each person is in a unique set of groups.	"(declare-const No Int)
(declare-const in Int)
(assert (and (<= 1 No) (<= No 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct No in))
(check-sat)"
Prove that there exists an integer x such that 2x + 1 > 0	To prove this, we can use the QF_LIA solver with the following constraints: (set-logic QF_UF) (declare-const x Int) (assert (>= 0 (1 + 2 * x)))	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
A university has two classes: History and English.	The class that starts later must be the one with more students	"(declare-const A Int)
(assert (and (<= 1 A) (<= A 3)))
(check-sat)"
Prove that if Alice and Bob both have a pet cat, then they are friends.	\begin{qf uf} \setof(x:person) (x ~ x.pet.cat) & (x ~ y.pet.cat) \declare-relation(p,q:friend)(p.y ~ q.y) \check-sat	"(declare-const a_friend_if Bool)
(declare-const if_friend_a Bool)
(assert (= a_friend_if if_friend_a))
(assert (= true a_friend_if))
(check-sat)"
PREDicates and Atomic Variables: Prove that there exists an integer x such that x^2 = 0	The solution to this problem can be proven using QF_UF, given the constraints (set-logic QF_UF) and (declare-const x :: int). The key insight is to recognize that if there does not exist an integer x such that x^2 = 0, then we must have a contradiction. This would mean that either x or x+1 cannot be zero, which implies that x is not an integer, leading to a contradiction.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	Use QF_UF and QF_LIA axioms to prove that a valid schedule can be constructed from a given set of jobs with different durations.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the linear programming relaxation of the knapsack problem	Using QF_UF with an interval representation to solve this linear program	"(assert true)
(check-sat)"
Scheduling Problem	Integer linear programming to optimize task allocation on a machine with multiple processing units.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	# Use QF_UF and QF_LIA rules with simple integer constraints to model the scheduling problem. The SMT-LIB program should include the following constraints: # A must be executed by processor C1 P_A <= P_C1 * 2; # Assign tasks to processors based on their capabilities # B must be executed by processor C2 P_B <= P_C2 * 3; # Assign tasks to processors based on their capabilities # Check if the assignment satisfies all constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfies the linear programming relaxation of the flow network of scheduling problem with three nodes and four edges, where each edge has two capacities.	This problem can be solved using the flow network solver of SMT-LIB.	"(assert true)
(check-sat)"
Scheduling Problem	Construct a scheduling problem with two tasks that cannot be scheduled together.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling: max-work-hours	assert (set-logic QF_UF) and (declare-const hours 1: integer) and (declare-const total_hours 0: integer) and (assert (=, total_hours, sumhours(hours))) and (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA with simple integer and boolean constraints to model a scheduling algorithm that assigns jobs to machines based on their processing time and machine capacity.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF with integer variables	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF to solve this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
\(\setoflucore uf) \+ (\declareconst i32 x 10)	\(\checksat (\assert true) \| (\checksat false))	"(declare-const i32 Int)
(declare-const uf Int)
(assert (and (<= 1 i32) (<= i32 10)))
(assert (and (<= 1 uf) (<= uf 10)))
(assert (distinct i32 uf))
(check-sat)"
Scheduling Problem	Use QF_UF to model scheduling as a maximization problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
{'type': 'scheduling', 'domain': 'transportation'}	{'type': 'explanation', 'domain': 'scheduling'}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Check if this scheduling problem is solvable in practice.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a scheduling problem	{'approach': 'brute-force', 'search': 'depth-first'}	"(assert true)
(check-sat)"
\(declare-const x 0: Int\); (set-logic QF_UF)\n(declare-const y 1: Boolean; (assert \(x = true; \))\n(check-sat)	Using the properties of equality and union to derive new constraints	"(declare-const n Int)
(declare-const x Int)
(assert (and (<= 1 n) (<= n 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct n x))
(check-sat)"
Scheduling Problem	Use QF_LIA and set-logic QF_UF to generate constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling problem to minimize make times and meet deadlines	Use QF_UF and QF_LIA rules to analyze constraints on machine times and resource utilization.	"(assert true)
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to enforce valid scheduling rules	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF with linear constraints to model a scheduling problem where tasks are assigned to time slots and their start times must be within a certain range.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to model the scheduling of tasks on a shared resource.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA SMT-LIB rules to derive a valid scheduling plan.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to generate valid constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Minimize Latency	Use QF_LIA and set-logic QF_UF to ensure validity and correctness.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find an assignment that satisfies all constraints	Using QF_UF and QF_LIA, derive valid integer constraints to satisfy the scheduling problem.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_LIA to reason about scheduling constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Maximize the number of customers served while minimizing idle time	Use QF_UF and QF_LIA rules to model the scheduling problem, including constraints on customer arrival and departure times, as well as idle time.	"(assert true)
(check-sat)"
Scheduling Problem: Find an optimal assignment of jobs to machines in a factory	Use QF_UF and QF_LIA rules to solve this scheduling problem, ensuring that all constraints are satisfied exactly.	"(declare-const a_of Bool)
(declare-const a_to Bool)
(declare-const an_of Bool)
(declare-const an_to Bool)
(declare-const in_of Bool)
(declare-const in_to Bool)
(assert (= (+
  (ite a_of 1 0)
  (ite an_of 1 0)
  (ite in_of 1 0)
) 1))
(assert (= (+
  (ite a_to 1 0)
  (ite an_to 1 0)
  (ite in_to 1 0)
) 1))
(assert (<= (+
  (ite a_of 1 0)
  (ite a_to 1 0)
) 1))
(assert (<= (+
  (ite an_of 1 0)
  (ite an_to 1 0)
) 1))
(assert (<= (+
  (ite in_of 1 0)
  (ite in_to 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to solve the scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
(set-logic QF_UF  (declare-const x int)  (declare-const y int)  (assert (>= x 0)    (<= y 10) )	This is a problem that will be solved using SMT-LIB.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Scheduling Problem	Formally specify scheduling constraints using QF_UF and QF_LIA.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the parity of three signals in a 3D system	Use QF_UF with equality constraints and set-logic QF_LIA to enforce non-increasing order.	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Satisfy the following scheduling constraint: Minimize make_time(1, 2) + make_time(3, 4)	Use QF_UF and QF_LIA constraints to ensure that make_time(1, 2) <= make_time(3, 4).	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to prove the satisfiability of the scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA clauses to model the scheduling of tasks on a single processor.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a scheduling conflict on multiple servers	Using QF_UF and QF_LIA to ensure tight coupling between tasks and servers, while respecting resource constraints.	"(declare-const a Int)
(declare-const on Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 on) (<= on 10)))
(assert (distinct a on))
(check-sat)"
Scheduling Problem: Resource Allocation	Use QF_UF and QF_LIA constraints to model resource allocation in a scheduling problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF to define sets of variables and use QF_LIA to check consistency.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Maximize Productivity with Limited Time	This problem can be solved using QF_UF and QF_LIA constraints to ensure that the production of products does not exceed the available time.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	{'constraints': ['(set-logic QF_UF)', '(declare-const X 1)', '(declare-const Y 2)', '(assert (<= X 10))'], 'clauses': ['(check-sat)']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling problem with no conflicts	Use QF_LIA to model this scheduling problem without conflicts.	"(assert true)
(check-sat)"
Scheduling Problem	This problem uses QF_UF and QF_LIA formulas to model a real-time system.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and check-sat to prove the validity of the program, which asserts that there exists an integer solution to the scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	{'constraint_type': 'integer_lower_bound', 'variables': ['x', 'y'], 'constraints': ['(set-logic QF_UF)', '(declare-const x int)', '(declare-const y int)', '(assert (>= x 0))', '(assert (<= y 10))']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Integer Constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the following linear programming relaxation of the 8-hour workday problem with additional constraints	Using QF_UF and QF_LIA, derive the solution to a system of linear equations representing the 8-hour workday problem, where employees are only allowed to work up to 40 hours per week.	"(assert true)
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to prove validity	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Maximize Customer Satisfaction	Use QF_UF or QF_LIA to generate a valid model and check its satisfiability.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Formulate a valid schedule that satisfies all constraints and meets the deadline.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	{'type': 'clausal', 'constraints': ['(set-logic QF_UF)', '(declare-const x Int)', '(declare-const y Bool)', '(assert (not (= x 0)))']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to model this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Find all valid solutions to the following system of linear equations with two variables.	Use QF_LIA and integer constraints to solve this system.	"(declare-const of Int)
(declare-const to Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct of to))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to ensure valid constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling: maximize {x, y} where x is the number of customers served in the first hour and y is the number of customers served in the last hour	The goal is to maximize the total number of customers served within a fixed time frame. This can be achieved by prioritizing customers based on their arrival times.	"(declare-const in Int)
(declare-const is Int)
(assert (and (<= 1 in) (<= in 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct in is))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA constraints to model a scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	To solve the scheduling problem, we need to find an assignment of tasks to machines that satisfies all constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find the optimal assignment of tasks to machines	Use QF_UF and QF_LIA constraints to enforce valid scheduling rules, and check for satisfiability using QBF or DPLL-SAT.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA to represent the scheduling problem as a logic formula	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA solvers to reason about valid schedules.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following scheduling constraint using QF_UF and basic arithmetic constraints.	Use the following set of rules to derive the solution: (set-logic QF_UF) (declare-const X < 10) (assert X > 0) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA constraints to ensure fairness in resource allocation.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given a set of jobs with deadlines and resource requirements, determine the optimal assignment of jobs to machines without violating any deadlines or resource constraints.	Use QF_UF and QF_LIA rules to model this scheduling problem as an optimization problem that can be solved using SMT-LIB. Include assertions for machine availability and job deadlines.	"(declare-const a_to Bool)
(declare-const of_to Bool)
(declare-const or_to Bool)
(assert (= (+
  (ite a_to 1 0)
  (ite of_to 1 0)
  (ite or_to 1 0)
) 1))
(assert (<= (+
  (ite a_to 1 0)
) 1))
(assert (<= (+
  (ite of_to 1 0)
) 1))
(assert (<= (+
  (ite or_to 1 0)
) 1))
(check-sat)"
Scheduling Problem: Minimize Makespan	Given a set of tasks with start times and durations, find the order that minimizes the total makespan.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying an integer linear equation	(= (int x) ( (1 + 2)  = 3))	"(assert true)
(check-sat)"
scheduling_problem	derive_satisfiability_from_just_the_constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	(set-logic QF_UF)  define-variables   x: integer   y: boolean,   z: real  (assert (not (= x 0))) (assert (not (= y true))) (assert (= z 1.5))	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find the minimum number of machines required to schedule tasks with maximum utilization	This problem can be solved using First-Order Logic (FOL) constraints in SMT-LIB. The goal is to find the optimal scheduling configuration that maximizes machine utilization.	"(declare-const of Int)
(assert (and (<= 1 of) (<= of 3)))
(declare-const to Int)
(assert (and (<= 1 to) (<= to 3)))
(assert (distinct of to))
(check-sat)"
Scheduling Problem	{'type': 'Propositional Reasoning', 'reason': 'Using QF_UF with integer constraints and checking satisfiability'}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	Use QF_UF with set of variables and universal quantification to model a scheduling problem where tasks have start and end times.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Generate an exact solution for the following linear programming relaxation of the 5-hour delivery problem	Use QF_UF and QF_LIA constraints to model integer variables representing hours worked by drivers, and use assert statements to enforce non-negativity.	"(declare-const an Int)
(declare-const of Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct an of))
(check-sat)"
\(set-logic QF_UF \n\n(declare-const X true \n  \n  (assert Y = 1) \n  (assert Z < 5))\n	This is a valid SMT-LIB program that includes the necessary logic for model checking and satisfiability.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find optimal assignment of tasks to machines	Use QF_UF and QF_LIA solvers with simple constraints, e.g., (set-logic QF_UF)   (declare-const machine <1..4>   (declare-const task <1..5>))   (assert (>= 0 (size of task)))	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to prove that it is NP-complete.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA to enforce valid scheduling constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA to model the scheduling problem	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find the optimal assignment of tasks to machines	Use QF_UF and QF_LIA constraints to reason about machine resource allocation.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to enforce precedence constraints on tasks	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF to model the scheduling of tasks with deadlines and resource constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA constraints to model this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Determine if it is possible to assign all tasks to employees within a given time frame.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to model scheduling problems.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF with valid constraints to solve this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a scheduling constraint	Use QF_UF and QF_LIA constraints to model the problem	"(assert true)
(check-sat)"
Modeling scheduling conflicts in a production line	\n\n\n(\n  \n    \n    (\n      \n      \n      \n      \n      \n      \n      \n    ),\n\n  \n\n  (\n    \n    (\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    )\n\n  \n)	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Scheduling Problem	Using QF_UF and QF_LIA rules to reason about scheduling constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	This problem requires the use of QF_UF and QF_LIA rules to reason about scheduling constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Using QF_UF and set-logic to model scheduling problems with multiple tasks and resource constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	Use QF_UF rules to model the scheduling of tasks with dependencies.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following integer linear program: P = { x, y | x + y <= 5, x >= 0, y >= 0 }	Use QF_UF and QF_LIA constraints to ensure satisfiability, then check for valid solutions.	"(declare-const P Int)
(declare-const x Int)
(assert (and (<= 1 P) (<= P 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct P x))
(check-sat)"
Scheduling Problem: Given two tasks t1 and t2, assign task t1 to machine M1 and task t2 to machine M2 if both machines are not busy	Propositional Reasoner	"(declare-const M1_t1 Bool)
(declare-const M1_t2 Bool)
(declare-const M2_t1 Bool)
(declare-const M2_t2 Bool)
(declare-const if_t1 Bool)
(declare-const if_t2 Bool)
(assert (= (+
  (ite M1_t1 1 0)
  (ite M2_t1 1 0)
  (ite if_t1 1 0)
) 1))
(assert (= (+
  (ite M1_t2 1 0)
  (ite M2_t2 1 0)
  (ite if_t2 1 0)
) 1))
(assert (<= (+
  (ite M1_t1 1 0)
  (ite M1_t2 1 0)
) 1))
(assert (<= (+
  (ite M2_t1 1 0)
  (ite M2_t2 1 0)
) 1))
(assert (<= (+
  (ite if_t1 1 0)
  (ite if_t2 1 0)
) 1))
(check-sat)"
scheduling:make-schedule	show that it is impossible to schedule two tasks with different start times and one task can be delayed by any amount of time without violating the constraints.	"(declare-const X Int)
(assert (and (<= 1 X) (<= X 3)))
(declare-const Y Int)
(assert (and (<= 1 Y) (<= Y 3)))
(declare-const Z Int)
(assert (and (<= 1 Z) (<= Z 3)))
(assert (distinct X Y Z))
(check-sat)"
{'solver': 'smt2', 'input': '\\{(\\x0 \\y -5) + (\\z + 10) <= 15; \\x1 = (\\x3 + 2) * (\\x4 - 3); \\z = 12; \\v = true; \\w = false;\\n\\(\\x0 < 0 \\n\\n(\\y - 5) * (\\z + 10) <= 15 \\n\\n(\\x1 = (\\x3 + 2) * (\\x4 - 3))\\n\\n(check-sat)'}	{'solver': 'smt2', 'input': '\\{(\\x0 \\y -5) + (\\z + 10) <= 15; \\x1 = (\\x3 + 2) * (\\x4 - 3); \\z = 12; \\v = true; \\w = false;\\n\\(\\x0 < 0 \\n\\n(\\y - 5) * (\\z + 10) <= 15 \\n\\n(\\x1 = (\\x3 + 2) * (\\x4 - 3))\\n\\n(check-sat)'}	"(declare-const n Int)
(declare-const v Int)
(assert (and (<= 1 n) (<= n 10)))
(assert (and (<= 1 v) (<= v 10)))
(assert (distinct n v))
(check-sat)"
Satisfying the constraint that all tasks in a scheduling problem have at least one feasible solution	Use QF_UF and QF_LIA axioms to ensure feasibility, then use modus ponens and contradiction elimination to prove satisfiability.	"(declare-const a Int)
(declare-const at Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 at) (<= at 10)))
(assert (distinct a at))
(check-sat)"
Scheduling Problem: Find the optimal assignment of tasks to machines in a factory	Use QF_UF or QF_LIA constraints and simple integer or boolean constraints to model the problem.	"(declare-const a_to Bool)
(declare-const in_to Bool)
(declare-const of_to Bool)
(assert (= (+
  (ite a_to 1 0)
  (ite in_to 1 0)
  (ite of_to 1 0)
) 1))
(assert (<= (+
  (ite a_to 1 0)
) 1))
(assert (<= (+
  (ite in_to 1 0)
) 1))
(assert (<= (+
  (ite of_to 1 0)
) 1))
(check-sat)"
Satisfy the following system of linear equations with two variables x and y	Use the QF_UF rule to introduce new variables, then use QF_LIA to eliminate them, and finally assert the truth of the resulting equation.	"(declare-const of Int)
(declare-const x Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct of x))
(check-sat)"
Satisfy the constraints of a finite automaton	Use QF_UF and QF_LIA rules to express the constraints of the automaton	"(declare-const a Int)
(declare-const of Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct a of))
(check-sat)"
Satisfy the following linear equations using QF_UF and QF_LIA rules	Use simple integer constraints to represent the relationships between variables.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following constraint using QF_UF and QF_LIA	Use simple integer constraints and   newlines to separate logical statements	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Using QF_UF and QF_LIA rules to derive a valid scheduling plan from a set of constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Resource Allocation Problem	Use QF_UF to model the allocation of resources.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation: Assigning Resources to Tasks	{'variables': ['x', 'y'], 'constraints': ['(set-logic QF_UF)', '(declare-const x Integer)', '(declare-const y Boolean)', '(assert x >= 0)'], 'solver': 'SMT-LIB'}	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA axioms to model this problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Prove that there exists an integer x such that x = 1 and (x + 2) mod 3 = 0	Using the properties of modular arithmetic, we can show that this equation is true for all values of x.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Resource Allocation	Use QF_UF or QF_LIA with simple integer and boolean constraints to solve a resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to ensure valid integer solutions.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
{'name': 'Resource Allocation', 'description': 'A resource allocation problem in a cloud computing environment'}	Using QF_UF and set-logic, we can model this problem as follows:  set-logic QF_UF; assert (declare-const x:integer >= 0); assert (declare-const y:integer > 0); check-sat;	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation: Minimize Number of Server Assignments	(set-logic QF_UF) (declare-const x : integer) (assert (x > 0)) (check-sat)	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF to enforce unit-of-formula equality	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: 3 resources available, 4 requests to allocate	Use QF_UF and QF_LIA constraints to ensure integer solutions are found	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF logic to model this resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA solvers to find an optimal assignment of resources to tasks.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model a resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to define a set of constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	To allocate resources to tasks, we need to minimize waste and maximize efficiency.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use of QF_UF or QF_LIA constraints to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA formulas to model this resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
(set-logic QF_UF (declare-const x int : 1) (assert (equivalent? (add 2 x) (add 5 x)))	Using the properties of arithmetic operations and addition, we can deduce that if (add 2 x) = (add 5 x), then (add 3 x) must be true.	"(assert true)
(check-sat)"
Resource allocation problem	Satisfiability Reasoning and Computation System	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to processes	Using QF_UF and QF_LIA, derive that there exists a valid assignment of resources to each process such that the total resource usage is non-negative.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to ensure fairness in resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: 5 machines, 3 software licenses	Using QF_UF with constraints on machine availability and license usage.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA to model resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to reason about resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to processes	Use QF_UF and QF_LIA constraints to model resource allocation, considering bounds on resources and process demands.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Using QF_UF with set-logic and declare-const constraints to model the allocation of resources between two processes.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation	Using QF_UF with linear constraints to optimize resource usage.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Allocate resources to tasks with minimum latency	{'variables': [{'name': 'latency', 'type': 'int'}], 'assumptions': ['(set-logic QF_UF)', '(declare-const task1-latency 10)', '(declare-const task2-latency 5)'], 'conclusions': ['(assert (leq task1-latency task2-latency 5))']}	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA logical frameworks to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
{'name': 'Resource Allocation', 'description': 'A problem of resource allocation in a computer system', 'satisfiability': False}	{'rule1': '(set-logic QF_UF)', 'rule2': '(declare-const x integer)', 'rule3': '(declare-const y boolean)'}	"(declare-const A_of Bool)
(declare-const a_of Bool)
(declare-const in_of Bool)
(assert (= (+
  (ite A_of 1 0)
  (ite a_of 1 0)
  (ite in_of 1 0)
) 1))
(assert (<= (+
  (ite A_of 1 0)
) 1))
(assert (<= (+
  (ite a_of 1 0)
) 1))
(assert (<= (+
  (ite in_of 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Using QF_UF and set-logic to model resource allocation problem	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
(set-logic QF_UF (declare-const x y Z)	This is a valid program, and it will always find a solution.	"(declare-const Z Int)
(declare-const x Int)
(assert (and (<= 1 Z) (<= Z 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct Z x))
(check-sat)"
Resource allocation: Assigning resources to tasks	Use QF_UF and QF_LIA rules to reason about resource availability	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation	Use QF_UF or QF_LIA to specify the resource constraints and then assert them using set-logic.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to model resource allocation problems, ensuring that resources are allocated in an optimal manner.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF to find valid assignments that satisfy all constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Using QF_UF with set of variables and assertions to solve a resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
\(set-logic QF_UF\) \(declare-const x_0 bool\) \(assert (x_0 = true)\)	\(check-sat\)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to model resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA constraints to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA solvers to find an optimal assignment of resources.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA axioms to reason about resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA quantifiers to model the problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to tasks	Use QF_UF and QF_LIA rules to constrain resource allocation.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation: Minimize the number of machines used in the data center	Use QF_UF and QF_LIA to model this problem, and ensure that it includes  - (set-logic QF_UF) or QF_LIA. Use simple integer constraints for machine utilization.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation: Assigning resources to tasks	Using QF_UF and QF_LIA constraints to ensure fairness in resource allocation, while also ensuring that the system is satisfiable.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Prove that it is possible to allocate resources such that all devices are used and no device is idle	(set-logic QF_UF) # Define the universe of discourse as integers from 0 to N-1 (where N is the number of devices)  (set-logic QF_UF)(declare-const N: int)  (assert (>= N 2))  (check-sat)	"(declare-const is_to Bool)
(declare-const it_to Bool)
(declare-const no_to Bool)
(assert (= (+
  (ite is_to 1 0)
  (ite it_to 1 0)
  (ite no_to 1 0)
) 1))
(assert (<= (+
  (ite is_to 1 0)
) 1))
(assert (<= (+
  (ite it_to 1 0)
) 1))
(assert (<= (+
  (ite no_to 1 0)
) 1))
(check-sat)"
Resource Allocation: Assigning Resources to Jobs	Use QF_UF and QF_LIA constraints, and ensure that all constraints are linear and integer/boolean.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Integer Variables with Bounds	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to servers in a cloud-based data center	Use QF_UF and QF_LIA constraints to model the resource allocation decision.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and set-logic to model resource allocation with multiple constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA logic to reason about resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Using QF_UF and QF_LIA rules, derive a valid solution that maximizes resource utilization.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Minimize the number of printers used	Using QF_UF and QF_LIA constraints, prove that it is not possible to allocate enough printers to satisfy all user requests without exceeding the available capacity.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	To ensure efficient resource allocation, we use the QF_UF and QF_LIA rules.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA theory to reason about resource constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use the QF_UF and QF_LIA logics to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
{'smtplib': 'int(x) <= x + 1'}	Satisfiability with constraints (set-logic QF_UF; assert x > 0; check-sat)	"(assert true)
(check-sat)"
Resource allocation problem	This problem involves allocating resources to tasks with different priorities and constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	To allocate resources efficiently, we need to minimize waste and maximize utilization of available resources.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA to represent resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA rules to model resource allocation problems	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	{'type': 'model-checking', 'description': 'Verify that a resource allocation model satisfies QF_UF and QF_LIA constraints.'}	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use set-logic QF_UF and declare-const to specify resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA rules to formulate a valid resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA solvers, and assert that the program produces exactly one solution.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Maximize production of 5 units while minimizing waste	Using QF_LIA and set-logic QF_UF, the following constraints can be derived.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
{'input': '\\(set-logic QF_UF\\) \\n \\n (declare-const x Int\\n \\n assert (x = 0)\n \\n check-sat)'}	This SMT-LIB program checks if a number is zero	"(declare-const n Int)
(declare-const x Int)
(assert (and (<= 1 n) (<= n 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct n x))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA to model this problem and ensure validity.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: assigning 10 units of CPU to process 1 and 5 units to process 2	Use QF_UF and QF_LIA constraints to model the resource allocation problem. Ensure that the total number of units allocated is exactly 15.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation: 3 cars and 4 passengers	Use QF_UF and set-logic to ensure that each passenger has at least one seat	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation optimization	Use QF_UF and QF_LIA constraints to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation	Use QF_UF and assert/declare/check-sat to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	(set-logic QF_UF) (declare-const x (int)) (assert (not (= 2, 0))) (check-sat)	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA to specify the resource allocation model.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Ensure that the minimum number of units required to satisfy all resource constraints is met	Use QF_UF and QF_LIA to reason about the satisfiability of the program, and check for validity using SMT solver.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF with assert statements to model this problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA rules to ensure feasibility.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: 5 agents, each with capacity 2 and deadline 10	Use QF_UF and QF_LIA rules to prove existence of a solution that satisfies all constraints	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	 - {set-logic QF_UF         assert (2 > 0)}	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to solve this optimization problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA solvers with simple integer constraints to model this problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Ensure that the maximum number of employees is allocated to each department	Use QF_UF or QF_LIA quantifier, and simple integer constraints (e.g., <=) to represent the relationship between departments and employees.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A woman has two coins that total 30 cents. One coin is not a nickel, and one coin is not a quarter. What type of coin are they?	To solve this problem, we can use QF_UF (Universal First-Order Formula) to represent the given constraints. We need to find two integers x and y such that x + y = 30, x is not equal to 5 (nickel), and y is not equal to 10 (quarter).	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
A farmer has a rectangular field with integer coordinates in pixels, and she wants to know if it's possible to place a row of n x m flowers on this field such that no two flowers are adjacent.	This problem can be solved using QF_UF (Unfolding Formulas) or QF_LIA (Linear Arithmetic Inequality).	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
Solve for x: 2*x + 5 = 11	Use QF_LIA and set-logic to model this equation as an equality of integer constraints.	"(assert true)
(check-sat)"
A farmer has a field with 3 rows and 4 columns. Each cell can hold either an integer from 1 to 10, inclusive.	{   (set-logic QF_UF)   (declare-const row1 int   row2 int   row3 int),   (declare-const col1 int   col2 int   col3 int),   (assert (>= row1 1)            (<= row1 10))   (assert (>= row2 1)            (<= row2 10))   (assert (>= col1 1)            (<= col1 4))   (assert (>= col2 1)            (<= col2 3))   (assert (>= col3 1)            (<= col3 4))   (check-sat)}	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
3+2=5	Using QF_LIA, we can assert that the sum of two integers less than or equal to 10 is greater than 1 and less than or equal to 15.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Solve for x: 2*x + 5 = 11	Use QF_LIA with constraints: x >= 0, 2x <= 6	"(assert true)
(check-sat)"
(set-logic QF_UF (declare-const x 1) (assert (>= x 0)) (check-sat)	This is a simple satisfiability problem, where we need to find an assignment of values to the variable x such that all constraints are satisfied.	"(assert true)
(check-sat)"
Solve the following logic puzzle: A bat and a ball together cost $1.10. The bat costs $1.00 more than the ball. If you have 5 times as many bats as balls, how much will you pay?	Let B represent the number of balls and B+ represent the number of bats. From the first equation, we get: B + (B+1) = 10. This simplifies to 2B + 1 = 10, or B = 4.5. Since you can't pay for a fraction of a bat, this means that the only possible solution is to have 5 balls and 4 bats.	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
The Five Switches	Use QF_LIA and set-logic QF_UF to prove that there is exactly one way to program a computer to switch between five lights on, one at a time, while the lights are off.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that there exists an integer x such that x^2 + x - 5 = 0	Use QF_UF and set-logic to prove the existence of a solution, and use check-sat to find it.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The Five Houses	Using set-logic QF_UF and quantifiers, prove that there exists a house on each row such that at least one of its doors is open.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF and QF_LIA to prove that there exists a number between 1 and 3 that has exactly one switch on.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	(set-logic QF_UF) (declare-const x true) (declare-const y false) (declare-const z true)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Five Houses Problem	To solve this problem, we need to use the QF_UF and QF_LIA SMT-LIB rules.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A man, a plan, a canal, Panama!	(set-logic QF_UF   (declare-const X 0 5)   (declare-const Y 5 10))(assert (>= X 1) (<= Y 4))   (check-sat)	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Three Switches	Use QF_UF and assert statements to prove that there is a unique solution to this puzzle.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Five Houses Problem	To solve this puzzle, we need to find a valid assignment of integers from 1 to 5 to the five houses such that no two adjacent houses have more than one occupant.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF to represent three switches, and assert that they are either all on or none of them is on.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has 'a' apples and 'b' bananas in his orchard. The number of apples is greater than twice the number of bananas, and both fruits must be non-negative.	The constraints are: (set-logic QF_UF) (declare-const a int > 0) (declare-const b int > 0) (assert (a > 2 * b) (check-sat)	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
A farmer has three fields: A, B, and C. Field A can hold values 0 through 9. Field B can hold values -1 through 1. Field C can only hold the number 5.	The farmer needs to ensure that field C holds a value of either 0 or 4. If field A holds any other value, then field C must be 0. Otherwise, if field A is 5 or greater, then field B must be -1.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
(set-logic QF_UF   (declare-const x 9)   (declare-const y 10)   assert (>= x 0)   assert (<= y 100)   check-sat)	Satisfiability isomorphism using UFL constraints and linear integer programming.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Satisfy the following set of constraints on the variable x.	Use the quantifier 'for all' to generalize over all natural numbers n.	"(declare-const of Int)
(declare-const on Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 on) (<= on 10)))
(assert (distinct of on))
(check-sat)"
A farmer has 5 sheep and 3 goats. How many animals does she have?	(set-logic QF_UF  (declare-const A int  (A = 5)  (G int  (G = 3)))  (assert < A + G > 0))	"(assert true)
(check-sat)"
The Set of Twin Primes	- Prove that there do not exist two prime numbers p and q such that pq = 2.	"(assert true)
(check-sat)"
A 5-person committee needs to decide on a project leader.	Use QF_UF and assert constraints like (equal (= 1 2)) or (not (equal (= 3 4))).	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
Solve for x: 2x + 5 = 11	Use QF_UF and set-logic (maximize) to find an optimal solution.	"(assert true)
(check-sat)"
The Five Houses Problem	To solve this problem, we need to assign numbers to each of the five houses such that each house is assigned a number between 1 and 5 (inclusive), and no two adjacent houses have the same number.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use the rules provided by the problem to construct a valid solution.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Five Houses Puzzle	To solve this puzzle, we need to find a valid assignment of integers from 1 to 5 to the five houses such that each house is either occupied by an integer or not.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer wants to optimize his irrigation system to minimize water waste.	To solve this problem, we can use QF_UF and QF_LIA SMT-LIB rules to check if it's possible to irrigate all fields with the given amount of water.	"(declare-const A Int)
(declare-const to Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct A to))
(check-sat)"
Solve the following puzzle:  3 x + y = 6, 2x - y = 4.	(set-logic QF_UF) (declare-const x Int) (declare-const y Int) (assert (>= x 0) (assert (>= y 0)) (verify-sat)	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
A person is standing next to a box with an unknown weight. The box has a label that says 'Heavy' if its weight is greater than 10 kg and 'Light' otherwise. The person is holding the box, but they don't know which side it's on. What can be said about the box?	Using QF_UF, we can assert that the box is either Heavy or Light.	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
There are three switches: hot, cold and off.  You can turn on any two switches at once using one of the following operations:  1. Turn on switch A and then off switch B.  2. Turn on switch C and then off switch D.  3. Turn on switch B and then off switch D.  4. Turn on switch A and then turn on switch C.  5. Turn on switch C and then turn on switch D.	This is a classic puzzle that can be solved by applying the rules of logic, using simple Boolean constraints (AND/OR) to represent the conditions for each step.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A man, a plan, a canal, Panama!	(set-logic QF_UF   (declare-const X 0 5)   assert (<= X 0)   check-sat)	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Five Houses Puzzle	To solve this puzzle, we need to use QF_UF constraints to represent the relationships between the houses and their occupants.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF to create a function symbol and apply it to three variables in a predicate.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following statement	Use the QF_UF and QF_LIA rules to generate a model that satisfies this statement.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a linear equation with two variables	Use QF_UF to ensure equality and QF_LIA to allow variable combination.	"(assert true)
(check-sat)"
Find integers x such that x^2 + 1 = x+3	This equation can be solved using QF_UF with the following constraints: (set-logic QF_UF) and (declare-const x integer)	"(assert true)
(check-sat)"
Prove that there exists an integer x such that x^2 + 4x - 7 = 0 and x is even	To prove this, we can use the QF_UF rules to find a model for the equation x^2 + 4x - 7 = 0. We can then analyze the models to determine which ones satisfy the condition that x is even.	"(declare-const an Int)
(declare-const is Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct an is))
(check-sat)"
(set-logic QF_UF (declare-const x 1 x < 5) (declare-const y 2 y = x + 3) assert (>= y 4)	To prove that the assertion is true, we can use a model with x >= 0 and y > 0.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
(set-logic QF_UF) (declare-const x 1) (assert (not (= x 0))) (check-sat)	To prove that x is not equal to 0, we can use the property of equality that if a = b then a = b.	"(assert true)
(check-sat)"
(set-logic QF_UF  define-const X 0  assert (<= X 5)  check-sat	This puzzle requires the solver to find a value for X such that it is less than or equal to 5.	"(assert true)
(check-sat)"
A farmer has a field that is 100 meters long and 50 meters wide. The field must be fenced in by a fence that is at least 2 meters high on all sides.	The farmer can use the following constraints to solve this problem:  - (declare-const field-width 50 :integer) - (declare-const field-length 100 :integer) - (assert (>= (add (multiply field-width 2) (add field-length 2)) (add field-width 2)))	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The set-builder logic asserts that there exists an integer x such that x^2 + 4x - 3 = 0.	\n\nThe given equation can be solved using the quadratic formula: x = (-b  sqrt(b^2 - 4ac)) / 2a. In this case, a=1, b=4, and c=-3. \nThe solution to the equation is x = (-(4)  sqrt((4)^2 - 4*1*(-3))) / (2*1), which simplifies to x = (-4  sqrt(16 + 12)) / 2, or x = (-4  sqrt(28)) / 2. Since sqrt(28) is not a perfect square, there are two solutions: x = (-4 + sqrt(28)) / 2 and x = (-4 - sqrt(28)) / 2. \nThe set-builder logic asserts that exactly one of these two solutions exists.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The Five Houses Problem	Use set-logic QF_UF and declare variables for each house number.  (declare-const house1-number 1) (declare-const house2-number 2) (declare-const house3-number 3) (declare-const house4-number 4) (declare-const house5-number 5)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Find an infinite set {x: [0, 1]}.	This problem can be solved using QF_UF.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that there exists an integer x such that x^2 + 4 = 13	Use QF_UF and set-logic to derive the desired formula.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
(set-logic QF_UF  (declare-const x 1)  (declare-const y 2)	This problem is a simple example of using set-logic QF_UF to reason about the satisfiability of a given formula.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
A farmer wants to ensure that all cows are wearing collars of a certain color.	The farmer has ordered 100 cows, each with one collar. The collar can be either red or blue. Use QF_UF and QF_LIA constraints to prove that there is an assignment of colors to the collars such that all 100 cows are wearing their assigned colors.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Flipped Coins	Use QF_UF with a set of variables and constraints to prove that it's impossible to flip all coins such that one side always shows the opposite number.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Prove that there exists an integer x such that exactly three switches are open.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF to prove that exactly one of three boolean variables can be false at any given time.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Prove that it is impossible to assign colors to three switches such that each switch corresponds to one of three colors and the corresponding color switch is red.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
\(\{\n  x: \n    # Introduce a variable and constraint\n    assert(x > 0);\n  y: \n    # Introduce another variable and constraint\n    assert(y < x);\n  z: \n    # Use SMT-LIB to prove the variables are equal\n  (set-logic QF_UF \n    (declare-const x : int) \n    (declare-const y : int) \n    (declare-const z : bool))\n  \n  assert(z);\n  \n  (check-sat)	\(\{\n  # We use the fact that x > 0 and x + y = z to prove x == z\n  assert(x + y = z + x);\n  \n  # Since z is True, we can deduce x == z\n  assert(x == z);\n  \n  \n  # Use the assumption that x < 0 and x - y = z to prove x != z\n  assert(x > 0 && x - y = z);\n  \n  # Since z is False, we can deduce x != z\n  assert(x != z);\n  \n  \n  \n  (check-sat)	"(declare-const a Int)
(declare-const n Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 n) (<= n 10)))
(assert (distinct a n))
(check-sat)"
A prisoner needs to escape from a cell with multiple locks, each of which has two possible keys: the correct key or the wrong key. The guards enter a room and check one lock at a time in order.	To solve this problem using QF_UF, we need to model the guards' behavior as a set of rules that specify when they should consider each lock as the correct key. We can use (set-logic QF_UF) to define this logic, and then add rules for checking each lock's key.	"(declare-const A Int)
(assert (and (<= 1 A) (<= A 3)))
(declare-const a Int)
(assert (and (<= 1 a) (<= a 3)))
(declare-const and Int)
(assert (and (<= 1 and) (<= and 3)))
(assert (distinct A a and))
(check-sat)"
A woman has two coins that weigh differently. One coin weighs 1 kg and the other weighs 0.9 kg. How much does the lighter one weigh?	Use set-logic QF_UF and assert   (weigh < 1kg)  and (not (weigh = 0.9kg))	"(declare-const A Int)
(declare-const kg Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 kg) (<= kg 10)))
(assert (distinct A kg))
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 0 and x is not odd	To prove this statement, we can use the QF_UF rule to generate a set of solutions for the equation x^2 + 1 = 0. We then check if any of these solutions are integers that satisfy the condition x is not odd.	"(declare-const an Int)
(declare-const is Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct an is))
(check-sat)"
A farmer has two fields, A and B. Field A has 5 apples, and field B has 3 oranges. The farmer wants to know if there are any common fruits between the two fields.	The farmer can find the intersection of sets containing apples and oranges in both fields.	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
A bat and a ball together cost $1.10. The bat costs $1.00 more than the ball. If the ball costs x dollars, how much does the bat cost?	Let b = number of cents in the ball. Then the equation is (100 - b) + b = 110. Solve for b.	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
Satisfying the union of two sets with distinct elements	Use QF_UF and set-builder constraints to model the union of two sets A = {1, 2} and B = {3, 4}. The constraint (set-logic QF_UF) ensures that each element in both sets is present. The constraint (declare-const x : setof int) defines a set of integers containing all elements from both sets. Finally, the constraint (assert all of A | B) asserts that any element in either set is present.	"(assert true)
(check-sat)"
A farmer has two fields, A and B. Field A is 3 units long, while field B is only 2 units long. The farmer wants to know if there are enough spaces on both fields.	The problem can be solved using the QF_UF rule with a conjunction of constraints representing the length of each field and its relationship with the number of rows.	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Satisfying a set of rules on the number of apples	Use QF_UF to generate constraints for the number of apples in each basket and then solve using check-sat.	"(declare-const a Int)
(declare-const of Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct a of))
(check-sat)"
A farmer has two fields: Field A and Field B. If it rains, both fields receive water, but only if it's not too hot.	let (   0:     assert (>= 20 any x) => (x = 'hot')   1:     assert (= 100 any y) => (y = 80)   2:     let (       z: set of string       f0: {x | x = 'hot', x < 20}       f1: {x | x = 'hot', x >= 20, x <= 30}       f2: {x | x = 'hot', x > 30})     assert (in z f0)     & (not in f1 f0)    & (in f2 f1)	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A farmer wants to irrigate all but two rows of his garden, and then water one row. What are the possible values for k?	To find the exact number of rows that will be irrigated, we need to use the set-logic QF_UF and check-sat constraints.	"(declare-const A Int)
(declare-const k Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 k) (<= k 10)))
(assert (distinct A k))
(check-sat)"
"{   'problem': ""Solve the following puzzle: There are three switches, but they are not labelled. Each switch corresponds to one of three light bulbs in a room. Each bulb is either on or off. You can turn the switches on and off as many times as you want, but you can only enter the room one time to observe the bulbs. How can you figure out which switch corresponds to which light bulb?"""	{   (set-logic QF_UF)   (declare-const bulb1 bool   bulb2 bool   bulb3 bool)   (declare-const switches [ bulb1 true    bulb2 false    bulb3 true ]   (assert not (switches[0]            or switches[1]            or switches[2]))   (check-sat)	"(declare-const a Int)
(assert (and (<= 1 a) (<= a 3)))
(declare-const as Int)
(assert (and (<= 1 as) (<= as 3)))
(declare-const in Int)
(assert (and (<= 1 in) (<= in 3)))
(assert (distinct a as in))
(check-sat)"
(set-logic QF_UF (declare-const x int) (declare-const y bool) (assert (>= x 0) (check-sat)	This is a simple problem that can be solved using basic arithmetic and logical constraints. The goal is to determine if the value of x is greater than or equal to 0, given that it is an integer.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
(set-logic QF_UF   (declare-const x y int)   (assert x > 0))	This is a simple logic puzzle where we are asked to prove that if x is greater than 0, then x is positive.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
A farmer has a field that can hold up to 1000 square meters of land. The field is currently empty, and it needs to be fenced in.	The farmer needs to fence in at least 800 square meters of land for this task.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Three Switches	Use set-logic QF_UF and assert/declare/declare-const to model a problem where a person has three switches, labelled A, B and C, and each switch corresponds to one of three light bulbs in a room. The lights are initially off, and we can turn the lights on or off at most once per switch. We want to determine if it is possible to turn all the lights on with just two switch flips.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
(set-logic QF_UF (declare-const x y 1))	(assert y = 1) && (check-sat)	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
The Three Switches	{'type': 'deductive', 'constraints': ['\n  assert (x = 0)\n', '\n  assert (y = 1)\n', '\n  assert (z = 2)\n']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use set-logic QF_UF and assert/unify to prove that there is no valid assignment of colors to switches such that each switch corresponds to either red or green.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the following system of linear equations with integer coefficients and constraints	Use QF_LIA or QF_UF to generate the model, then solve it using a solver like DPLL or CDT.	"(assert true)
(check-sat)"
(set-logic QF_UF (declare-const x 1 #t) (declare-const y 2 #f) (assert (x = true) (y = false)))	to prove that x and not y are both true or both false using only basic arithmetic operations and equality checks	"(declare-const f Int)
(declare-const t Int)
(assert (and (<= 1 f) (<= f 10)))
(assert (and (<= 1 t) (<= t 10)))
(assert (distinct f t))
(check-sat)"
The set of all perfect numbers	This is a classic problem in number theory, and it can be solved using QF_UF with constraints such as (forall x (<= 1000) (odd? x))	"(assert true)
(check-sat)"
Solve the puzzle: 5 cars are parked on the street, and each car has a different color. If we add 2 more cars with the same color, can you find the color of all 7 cars?	Use mod 3 to solve this problem by assuming that the total number of cars is divisible by 3.	"(declare-const If Int)
(declare-const a Int)
(assert (and (<= 1 If) (<= If 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct If a))
(check-sat)"
A farmer has a field with two rows and two columns. Each cell in the field can be either red or green. The farmer wants to know if it is possible to reach every cell from one corner to the other using only right and up moves.	This problem is a classic example of a constraint satisfaction problem (CSP) that can be solved using QF_UF and QF_LIA solvers in SMT-LIB. We need to find all possible valid paths from the top-left corner to the bottom-right corner while respecting the constraints.	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
Satisfy the following proposition: 2 + 2 = true.	This can be proved using the QF_UF rule and simple arithmetic constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use a model with three variables and two constraints to solve this puzzle.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given integers a and b, find all pairs of distinct positive integers c and d such that a + b = c + d	Prove the validity of the following system using QF_UF or QF_LIA with integer constraints: (set-logic QF_UF)   (declare-const a Int)   (declare-const b Int)   (declare-const c Int)   (declare-const d Int)   (assert (a + b = c + d))   (check-sat)	"(declare-const a Int)
(declare-const b Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 b) (<= b 10)))
(assert (distinct a b))
(check-sat)"
Prove that the following statement is true: x = 5 and y != 3	Use the QF_UF rule to combine the assertions of x = 5 and y != 3, then use the QF_LIA rule to prove the conjunction of these two statements. Finally, add a check-sat clause to verify that the system is satisfiable.	"(declare-const is Int)
(declare-const x Int)
(assert (and (<= 1 is) (<= is 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct is x))
(check-sat)"
Solve the following puzzle: A bat and a ball together cost $1.10. The bat costs $1.00 more than the ball. If the ball costs x dollars, how much does the bat cost? y.	$y-x=0.10\quad$y>x$	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
A 5-person committee must be formed from a group of 8 people, and each person can only speak on one topic.	Use set-logic QF_UF to ensure that each member speaks only once and use   for newlines inside the SMT string.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Five Houses Puzzle	Use QF_UF to express that each house is occupied by either a person or an animal.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has N cows to milk. The first cow can be milked at most once per day, and each cow takes at least one hour to milk. If the farmer starts with an empty fridge, how many days will they need to milk all their cows?	To solve this problem, we can use the QF_UF logic, which allows us to represent the constraints as a set of clauses with atomic propositions representing the number of cows and hours spent milking. We can then use the 'check-sat' solver to find an optimal solution.	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
The Three Switches	(set-logic QF_UF) (declare-const x 1) (assert (x = 0)) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has two fields, A and B. Field A contains all the apples from both fields combined. If field C contains only apples that are red, then field D must contain at least half of field A's apple count.	Use QF_UF and QF_LIA to solve this problem. Consider the constraints (set-logic QF_UF) and (declare-const ...). Use assert statements to define field A and field B. Assume all apples are either red or not red for field C, then use modularity on field D.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A farmer has 5 sheep and wants to build a fence around them. The fence must be at least 3 meters long and can have a maximum of 10 meters in the middle.	Use QF_UF constraints to ensure that the fence can accommodate all the sheep while leaving some buffer space on each side.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
A farmer has 'm' chickens and wants to know if they are all happy.	The answer is yes if and only if m = 5 or m = 6	"(declare-const A_friend_if Bool)
(declare-const if_friend_A Bool)
(assert (= A_friend_if if_friend_A))
(assert (= true A_friend_if))
(check-sat)"
The Life of Pi	Use QF_UF and assert constraints on pi, x, and y.	"(declare-const Pi Int)
(declare-const of Int)
(assert (and (<= 1 Pi) (<= Pi 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct Pi of))
(check-sat)"
A farmer has three fields: A, B and C. Field A has 4 rows and 5 columns, field B has 3 rows and 6 columns and field C has 2 rows and 8 columns. The farmer wants to know how many hot peppers are in each field.	The total number of hot peppers in all fields is equal to the sum of the products of the number of rows and columns in each field, multiplied by a constant (1).	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
\(\(\{1:2, 3:4} \) -> (false))	(set-logic QF_UF) (declare-const X int) (assert (X = 1) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
(set-logic QF_UF) (declare-const x 1  # t) (assert (<= 0 (and x 2) (add 3 x))) (check-sat)	"Using the <a href=""https://www.sat.inf.u-bremen.de/"">SAT solver</a> to verify the satisfiability of the given formula. We found that it is unsatisfiable for all values of x."	"(declare-const t Int)
(declare-const x Int)
(assert (and (<= 1 t) (<= t 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct t x))
(check-sat)"
The Three Switches	"(set-logic QF_UF 	(declare-const x 1) 	(declare-const y 2) 	(assert (not (= x 0))) 	(check-sat)"	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	QF_UF and set-logic QF_LIA	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has 5 rows of flowers in her garden, and each row can have at most 3 flowers. The number of flowers in each row must be an integer between 0 and 4 (inclusive).	The number of flowers is a valid integer.	"(declare-const A Int)
(declare-const an Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 an) (<= an 10)))
(assert (distinct A an))
(check-sat)"
Satisfying a simple equation	Use <~{ to enforce an inequality, and <~~ to enforce equality.	"(assert true)
(check-sat)"
Satisfying the Chicken McNugget Theorem	The Chicken McNugget Theorem states that the sum of two relatively prime numbers has a unique representation as a linear combination of those two numbers. Prove this theorem using QF_UF and SMT-LIB.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use a switch statement to determine which color shirt to wear based on the day of the week.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has three fields of wheat: Field A, Field B, and Field C. Each field can hold either 0 or 1 units of wheat. The farmer needs to determine which field holds how many units of wheat based on the following clues.	Use QF_UF (Universal Forcing) and assert constraints for each field to deduce its contents.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A farmer has two fields, A and B. Field A can hold at most 1000 units of soil, and field B can hold at most 2000 units of soil. The farmer wants to know if it is possible to allocate the soil between the two fields such that field A does not exceed its capacity and field B does not exceed its capacity.	use QF_UF to add constraints on the number of units in each field, check-sat to verify the validity of the constraints	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Solve the following logic puzzle: There are three switches, but they are not labelled. Each switch corresponds to one of three light bulbs in a room. Each bulb is either on or off. You can turn the lights on and off as many times as you want, but you can only enter the room one time to observe the bulbs.	Use QF_UF to model the switches and their corresponding light bulbs. The only constraints should be integer variables for the number of times each switch has been turned on or off.	"(declare-const a Int)
(assert (and (<= 1 a) (<= a 3)))
(declare-const as Int)
(assert (and (<= 1 as) (<= as 3)))
(declare-const in Int)
(assert (and (<= 1 in) (<= in 3)))
(assert (distinct a as in))
(check-sat)"
The set of all perfect squares between 0 and 100	Use QF_UF to express that a number is either even or odd, then use the property (forall x (x = 0) -> (not (x^2))) to assert that there are no perfect squares less than 100.	"(assert true)
(check-sat)"
The Five Houses Problem	Use QF_UF and QF_LIA solvers to prove the following statement: There exists an integer x such that x^2 + x + 1 = 5x + 4 or (x == 0 and y == 2) or (x == 3 and y == 1)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
\u03c0\u202f\u2228\u221a\u203b\u2153\u2192\u2115\u20d1\u2164\u217e\u22cc\u2202\u2189\u2164\u223b\u2193\u214f\u2187\u212a\u215c\u2236\u219d\u2210\u2135\u2188\u217c\u2221\u218a\u216f\u220e\u2192\u211c\u2153	\u03b7\u2129\u20ac\u201d\u2060\u2035\u2130\u2211\u2148\u218a\u2164\u217e\u22cc\u2202\u218f\u2153\u219b\u222c\u2207\u2189\u207d\u2066\u2120\u20ac\u201d\u2035\u2130	"(declare-const u2115 Int)
(declare-const u2135 Int)
(assert (and (<= 1 u2115) (<= u2115 10)))
(assert (and (<= 1 u2135) (<= u2135 10)))
(assert (distinct u2115 u2135))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that two people are friends if and only if they have a mutual friend	Use QF_UF to prove the biconditional, and use set-logic to add the necessary constraints	"(declare-const a_friend_if Bool)
(declare-const if_friend_a Bool)
(assert (= a_friend_if if_friend_a))
(assert (= true a_friend_if))
(check-sat)"
(set-logic QF_UF   (declare-const x int)   (assert (not (= x 0)))   (check-sat)	The assertion will only be true if x is not equal to 0.	"(assert true)
(check-sat)"
Social inequality	Use QF_UF to model the relationship between income and education level, where higher income leads to higher education level.  (declare-const X (integer : LessThan 5))  (declare-const Y (integer : GreaterThan 0))  (assert (QF_UF (     X Y              <= 4 ? true : false) )	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given a social network with people of different ages, find all pairs of individuals who are friends.	To solve this problem, we can use QF_UF and check-sat constraints to derive the friendships between people. We can first list all possible pairs of individuals, then constrain each pair using simple integer or boolean constraints (e.g., `age(a, b) <= 18 && age(b, a)`), and finally check for satisfiability.	"(declare-const a_friend_of Bool)
(declare-const of_friend_a Bool)
(assert (= a_friend_of of_friend_a))
(assert (= true a_friend_of))
(check-sat)"
Prove that there exists an integer x such that x + 1 = 3 and x - 2 > 0	Use the QF_UF rule to combine x + 1 = 3 with x - 2 > 0 to get (x+1) - (x-2) = 5 > 0	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The given social constraint is inconsistent and cannot be satisfied by any assignment of integers or booleans.	A valid solution would require the existence of a finite set of integer values that can satisfy all constraints simultaneously.	"(declare-const be_of Bool)
(declare-const be_or Bool)
(declare-const by_of Bool)
(declare-const by_or Bool)
(declare-const is_of Bool)
(declare-const is_or Bool)
(assert (= (+
  (ite be_of 1 0)
  (ite by_of 1 0)
  (ite is_of 1 0)
) 1))
(assert (= (+
  (ite be_or 1 0)
  (ite by_or 1 0)
  (ite is_or 1 0)
) 1))
(assert (<= (+
  (ite be_of 1 0)
  (ite be_or 1 0)
) 1))
(assert (<= (+
  (ite by_of 1 0)
  (ite by_or 1 0)
) 1))
(assert (<= (+
  (ite is_of 1 0)
  (ite is_or 1 0)
) 1))
(check-sat)"
Prove that John and Mary are married	Use QF_LIA and assert the following equations to prove this statement, then check-sat.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Ensure that no two people in a friendship network have more than one connection to each other	"model  	 globeforall x y z:  		headgedd (x, y)  		and  		( x  eq z |  			not ( 			y, z)  	))"	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (= a_friend_in in_friend_a))
(assert (= true a_friend_in))
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 2x and x is less than or equal to 10	{'method': 'modelChecking'}	"(declare-const an Int)
(declare-const is Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct an is))
(check-sat)"
Prove that there exist two distinct integers x and y such that x + y = 5	Using QF_UF with constraints x >= 0, y <= 5, and x + y = 5, derive the existence of a solution.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that it is not possible to construct a directed acyclic graph (DAG) with more than 5 nodes and 10 edges.	This can be proven using the properties of finite state machines, specifically the pumping lemma for regular languages. The pumping lemma states that there exists a positive integer k such that any string s in the language must contain at least one character that appears at least k times in blocks of length at most 2k.	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Prove that there exists an integer x such that x^2 + 4 = 8 and x^2 - 3 < 0.	This problem can be solved using the QF_UF rule, which states that for any formula f(X) of type 'quantifier-free' with one free variable X, we have either f(X) or f(X). We will use this rule to derive a contradiction. First, we show that 3^2 - 4 = 5 and 3^2 + 4 > 8. Then, we can conclude that there exists an integer x such that x^2 < 0.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that 'John' is not equal to 'Alice'	Use QF_UF with set-logic and assert constraints.	"(declare-const is Int)
(declare-const to Int)
(assert (and (<= 1 is) (<= is 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct is to))
(check-sat)"
Prove that there exists an integer $x$ such that x^2 + 3x - 4 = 0	The quadratic equation has at least one real root according to the Fundamental Theorem of Algebra, and we can show this by attempting to solve it manually.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that there exists an integer x such that x > 0 and (x + 1) mod 3 = 2	Using the properties of modular arithmetic, we can derive that if x is positive, then (x + 1) mod 3 must be equal to 2. This implies that there exists a unique integer solution for x.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that John and Mary are married.	(set-logic QF_UF) (declare-const John mary : pair (string , string)) (assert (John mary) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that a person is not married to themselves.	(not (set-of-facts (set-of-constants 'x) (set-of-constants 'y)))	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Prove that for all integers n >= 2, (1 + n) mod 3 = 0.	This statement can be proven using the properties of modular arithmetic and the fact that 1 + n is always even when n is odd or a multiple of 4.	"(assert true)
(check-sat)"
Prove that there are at least two distinct social connections between individuals in a small community.	Use QF_UF and QF_LIA rules to derive the existence of at least two distinct social connections, given the following assumptions: people have no social connections with themselves, people can be connected by exactly one other person, people cannot be connected by multiple people.	"(declare-const a Int)
(declare-const at Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 at) (<= at 10)))
(assert (distinct a at))
(check-sat)"
Verify that the following relation holds: (x, y) <- (x, z) && (y, z)	Use QF_UF and QF_LIA rules to derive the implication.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that it is impossible to have two people who are friends with each other	{'description': 'Use QF_UF and set-logic to model this relationship.', 'smtlib': 'set-logic QF_UF\ndeclare-const Alice:Int\ndeclare-const Bob:Int'}	"(declare-const is_friend_it Bool)
(declare-const it_friend_is Bool)
(assert (= is_friend_it it_friend_is))
(assert (= true is_friend_it))
(check-sat)"
Given the following social network structure: [1, 2; 2, 3; 3, 4], define the minimum number of friendships required to satisfy all constraints.	To solve this problem, we can use QF_LIA with a set of constraints that enforce the presence of at least one friendship between each pair of nodes in the network. We can then check if the resulting model is satisfiable using check-sat.	"(declare-const of_friend_to Bool)
(declare-const to_friend_of Bool)
(assert (= of_friend_to to_friend_of))
(assert (= true of_friend_to))
(check-sat)"
Prove that any two people are connected in a social network	Use QF_UF and QF_LIA rules to reason about graph connectivity	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Verify that a social relationship graph is consistent.	{   (set-logic QF_UF)   (declare-const person1 person2 : FRIENDS)   (assert (forall (x person)         (           (person1 x)                        (person2 x))         (not (eq x x)))   )	"(declare-const a_friend_is Bool)
(declare-const is_friend_a Bool)
(assert (= a_friend_is is_friend_a))
(assert (= true a_friend_is))
(check-sat)"
Prove that two people are friends if and only if they share a common interest.	Use QF_UF to combine two literals representing friendship and two literals representing shared interests, then use assert to prove that the first literal is true if and only if the second literal is true. Finally, check-sat to verify that the system satisfiable.	"(declare-const a_friend_if Bool)
(declare-const if_friend_a Bool)
(assert (= a_friend_if if_friend_a))
(assert (= true a_friend_if))
(check-sat)"
Determine whether a person is married to their spouse	Use QF_LIA and (set-logic QF_UF) with valid constraints to prove that a person is not married to their spouse.	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Prove that there does not exist an integer x such that x^2 + 1 = 0	This statement can be proven using the QF_LIA theory, specifically by assuming x is an integer and then deriving a contradiction.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that if person A is friends with person B and person C, then person A and person C are connected by a friendship chain	Use QF_UF to represent friendships between people and QF_LIA to ensure the structure of the friendship graph is consistent.	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Determine if all people in a social network have at least one friend.	Use QF_UF and assert statements to model relationships between individuals, then use the check-sat solver to verify validity.	"(declare-const a_friend_at Bool)
(declare-const at_friend_a Bool)
(assert (= a_friend_at at_friend_a))
(assert (= true a_friend_at))
(check-sat)"
Prove that there exist two people in a social network such that they are friends and not spouses.	Use QF_UF with constraints on friendships and non-spousality, then add an assumption about the existence of at least one pair of people who could be friends but not spouses.	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (not a_friend_in))
(assert (not in_friend_a))
(check-sat)"
Prove that there does not exist an integer k such that k^2 + 5k - 6 = 0	(assert (integer s) (> 0 ? 1 : 2)) (assert (syms x k real) > 0) (assert (satisfies (e (univariate x) (- 6 x 6 k^2 + 5 k))) > 0) ((set-logic QF_UF) (declare-const s real)) ((check-sat))	"(declare-const an Int)
(declare-const k Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 k) (<= k 10)))
(assert (distinct an k))
(check-sat)"
Determine whether it is possible to construct a social network where all individuals are connected and no two individuals are friends	The graph of friendships can be represented as an undirected graph with weighted edges, where each edge has a weight representing the strength of the friendship. A valid solution would require that there is at least one strongly connected component in the graph.	"(declare-const a_friend_is Bool)
(declare-const is_friend_a Bool)
(assert (= a_friend_is is_friend_a))
(assert (= true a_friend_is))
(check-sat)"
Prove that if Alice is friends with Bob and Bob is friends with Charlie, then Alice is friends with Charlie	Use QF_UF with constraints that express the friendship relationships as valid integer solutions. Ensure the model is satisfiable by checking for consistency.	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (= if_friend_is is_friend_if))
(assert (= true if_friend_is))
(check-sat)"
Prove the following sentence is valid in QF_UF	Use the set-logic QF_UF and assert statements to derive the sentence.	"(declare-const in Int)
(declare-const is Int)
(assert (and (<= 1 in) (<= in 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct in is))
(check-sat)"
Given a person A with age 25 and friend B, prove that if A's friends are all friends of C then A is friends of B.	(declare-const A Person (0: 1) (declare-const B Person (0: 1) (declare-const C Person (0: 1))  (   (            (forall x (Person (x)) (         (set-of y (Set-of-z) z)))        ) )  (   (assert (or (A= B) (All-of-A-Friend-Of-B-C A C))))	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Prove that if person1 is friends with person2 and person3, then person4 is not friends with person5.	{'method': 'existential', 'variables': ['person1', 'person2', 'person3', 'person4', 'person5'], 'constraints': ['(set-logic QF_UF)\n\n', '(declare-const person1 person1)\n', '(declare-const person2 person2)\n', '(declare-const person3 person3)\n', '(assert (person1 <> person2))\n', '(assert (person1 <> person3))\n', '(assert (not (person4 <>) (person5 <)))']}	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (not if_friend_is))
(assert (not is_friend_if))
(check-sat)"
The relationship 'John Doe' and 'Jane Smith' are friends.	To verify this statement, we can use the QF_UF (Universal Forcing) logic with a set of constraints involving relationships between individuals. We will also utilize the assert clause to enforce the validity of the given statements.	"(declare-const X_friend_Y Bool)
(declare-const Y_friend_X Bool)
(assert (= X_friend_Y Y_friend_X))
(assert (= true X_friend_Y))
(check-sat)"
The given social network of friends has exactly 5 people.	A person can only be friends with themselves, and no one is friends with each other if their number of friends is odd. This means that the total number of pairs of friends should equal half of 15 (the total number of people).	
Prove that there exists an integer x such that x + 1 = 2x	Use the QF_UF and QF_LIA rules to derive the desired consequence.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that there are no cycles in the graph G = ({a, b, c}, R), where R is an undirected relation and 'a' and 'b' are related to each other, but not both.	Use QF_UF and set-logic to reason about the satisfiability of this graph. Assume X = {a, b} such that X  G. Prove by contradiction that there exists a path from a to c in G if and only if for all y  X, (y, x)  R.	"(declare-const G Int)
(declare-const R Int)
(assert (and (<= 1 G) (<= G 10)))
(assert (and (<= 1 R) (<= R 10)))
(assert (distinct G R))
(check-sat)"
Pigeonhole Principle	Given n pigeons and m pigeonholes, show that at least one pigeonhole must contain more than one pigeon.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The following social relationship constraint is valid: P(x, y) |= Q(x, z), where P, Q are predicates and x, y, z are atoms.	To prove the validity of this constraint, we need to show that it is satisfiable using a finite model.	"(declare-const P_friend_Q Bool)
(declare-const Q_friend_P Bool)
(assert (= P_friend_Q Q_friend_P))
(assert (= true P_friend_Q))
(check-sat)"
Verify that a social constraint involving two individuals and their relationships holds true	{'method': 'existential quantification'}	
Prove that all employees in the company are working	Using set-logic QF_UF and QF_LIA, derive the following implications: (set-of-people employee1 ... employee5) => (work(employee1, employee2), work(employee3, employee4), work(employee5, employee6))	"(assert true)
(check-sat)"
Prove that John and Mary are married	(set-logic QF_UF) (declare-const John mary : bool) (assert (== John mary)) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that if person1 is friends with person2, and person2 is friends with person3, then person1 is friends with person3.	Use the transitive property of friendship to prove this implication.	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (= if_friend_is is_friend_if))
(assert (= true if_friend_is))
(check-sat)"
Prove that a person is either in their hometown or not.	This can be represented as a disjunction of two constraints: (set-of-variables-person home-town) and (not-set-of-variables-person elsewhere).	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Find all pairs of people in a social network where one person is friends with another.	Use QF_UF to model friendship relationships and check-sat to solve the problem	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (not a_friend_in))
(assert (not in_friend_a))
(check-sat)"
Prove that any person is either a student or an employee of the same company.	{   (set-logic QF_UF)   (declare-const C (Symbol('Company'))   (declare-const S (Symbol('Student'))   (declare-const E (Symbol('Employee'))   (assert (not (or (= C S) (= C E))))   (assert (not (and (= S C) (= E C)))   (assert (not (or (= S E) (= C E)))))   (check-sat) }	"(declare-const a Int)
(declare-const an Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 an) (<= an 10)))
(assert (distinct a an))
(check-sat)"
Prove that a person is either married to their spouse or not married at all	Use QF_UF and assert variables for marriage status, then check-sat	"(declare-const a Int)
(declare-const at Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 at) (<= at 10)))
(assert (distinct a at))
(check-sat)"
Prove that John and Mary have different favorite sports.	Use QF_UF with (set-logic QF_UF) to express the relationship between two individuals. Then, use (assert ...) to assert a specific property about their preferences. Finally, check-sat to prove this property holds true.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that John and Alice are friends.	(john = alice) -> (friend john alicia)	"(declare-const X_friend_Y Bool)
(declare-const Y_friend_X Bool)
(assert (= X_friend_Y Y_friend_X))
(assert (= true X_friend_Y))
(check-sat)"
A university has two social constraints regarding friendships between students.	These constraints can be represented using QF_UF and QF_LIA axioms.	
Prove that a person is either in the US or has a valid US driver's license.	Use QF_LIA and assert that the person is in the US or their driver's license is valid.	"(declare-const US Int)
(declare-const a Int)
(assert (and (<= 1 US) (<= US 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct US a))
(check-sat)"
Prove that every person has at least one friend	Use QF_LIA and QF_UF to model the friendship relationship between people	"(declare-const at_friend_has Bool)
(declare-const has_friend_at Bool)
(assert (= at_friend_has has_friend_at))
(assert (= true at_friend_has))
(check-sat)"
Satisfies QF_UF rule with a valid JSON payload	"{'solver': 'CPVEX', 'input': '{""solution"": ""1"", ""constraints"": [""x + y = 2""]}', 'expected_solution': '[0, 3]'}"	"(assert true)
(check-sat)"
The social network has a relationship between John and Alice, but they are not friends.	{'constraints': ['(set-logic QF_UF)\n', '(declare-const person1 person2)\n', '(assert (not (person1 = person2)))\n', '(check-sat)']}	
\(set-logic QF_UF\) \(declare-const x = 5\) \(assert \((\u'== 4\)\))	This proof uses QF_UF to prove a simple equality and QF_LIA to derive the truth of the assertion.	"(declare-const u Int)
(declare-const x Int)
(assert (and (<= 1 u) (<= u 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct u x))
(check-sat)"
The relationship between person A and person B is that they are friends.	This can be expressed as (set-logic QF_UF)      (declare-const personA personA   declare-const personB personB   assert (personA == personB))   (assert (not (personA != personB)))	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
\(set-of\(\{x| x #= 1\} \) && \(set-of\(\{y| y #!= 2 && !x || y #<= 3\} \))\)	\(declare-const x 1; \(declare-const y 2; \(assert (xor (and (not (eq x 1) (neq x 2)) (not (eq x 1) (lt x 3))) (and (neq x 1) (gt x 3)));\)	"(declare-const of Int)
(declare-const x Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct of x))
(check-sat)"
Prove that there exists an integer x such that 2*x + 3 >= 5 and x^2 <= 4	Use QF_UF to model the system of linear inequalities: 2x + 3 >= 5 --> 2x >= 2 --> x >= 1; x^2 <= 4 --> x <= -2	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that for all integers x and y, if x > y then x + y = 2y	Using QF_UF with the set of integers and the implication rule, derive the following:   (declare-const x Int) (declare-const y Int) (assert (x > y)) (check-sat)	"(declare-const if Int)
(declare-const x Int)
(assert (and (<= 1 if) (<= if 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct if x))
(check-sat)"
{'solver': 'QF_UB', 'reasoning': '(set-logic QF_LIA (declare-const x 0: INTEGER) (assert (>= x 1)) (check-sat))'}	(assert (>= 2 3)) (check-sat)	"(assert true)
(check-sat)"
Prove that if Alice and Bob are friends, then Carol is also friends with both of them.	(set-logic QF_UF)                (declare-const alice friend bob)     (assert (not (friend bob alice)))     (declare-const carol friend alicebob)     (assert (and (friend alicebob carol) (friend alice carol)))	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (= if_friend_is is_friend_if))
(assert (= true if_friend_is))
(check-sat)"
Prove that there are no friends among five people.	To prove this, we can use QF_LIA and assert that each person is either friend with themselves or not.	
A person is either married to their spouse or in a consensual relationship with someone else.	This property can be expressed using QF_UF (Unions of First-Order) and constraints such as <person> marry <other_person>	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
Verify that there are no social connections between all individuals in a network of 10 people with no mutual friends	Use QF_UF to model the relationship as a graph, and then use QF_LIA to check if the graph is acyclic. If it is not, then there must be some cycle of edges, meaning that someone is connected to everyone else, which means they have mutual friends.	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (= a_friend_in in_friend_a))
(assert (= true a_friend_in))
(check-sat)"
(set-logic QF_UF (declare-const x y z (integer :pred <)) (assert (not (= x 5))) (check-sat)	(check-sat)	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that there exist distinct integers x, y such that x + y = 3 and x  y	Using QF_UF and the constraints x + y = 3 and x  y, derive a contradiction if neither x nor y is equal to zero.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that a person who has friends with people they know personally and strangers, but does not have acquaintances outside of their social circle, cannot be a friend to any one specific stranger.	Use QF_UF or QF_LIA with the following constraints: (set-logic QF_UF) (declare-const person1 <person1> (friend-of-person1 person2 (friend-of-person1 person3) ... (not acquaintances person4 person5))) (assert (for-all x (forall y (not friend-of-person1 y x))) (not (in-a-social-circle x)))	"(declare-const a_friend_be Bool)
(declare-const be_friend_a Bool)
(assert (not a_friend_be))
(assert (not be_friend_a))
(check-sat)"
Prove that there exist non-empty sets A and B of people such that A  B = 	"The following set constraints ensure the existence of such sets:  - A (A  X)   	B (B  A);"	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
Social Network Problem	The following friendship relationships hold: (Alice, Bob), (Bob, Charlie), (Charlie, Alice). Find the maximum number of friends each person can have.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given two people A and B, where person A is related to person B by marriage if A's age is greater than B's age.	Use QF_UF or QF_LIA with set-logic to express the relationship between ages of individuals for any positive integers n and m (where n <= m).	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
Prove that if person A has degree 3 and person B has degree 4, then person A's age is greater than or equal to person B's age	This implication can be proved using QF_UF or QF_LIA.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
Prove that there exists an integer x such that x^2 = 5 and x^4 + 2x^2 - 1	Use QF_UF to reason about the existence of a solution and then use QLIA to solve for x.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that two people are acquaintances if they have met at least once	(set-logic QF_UF) (declare-const person1 :: int) (declare-const person2 :: int) (assert (person1 = person2)) (check-sat)	"(declare-const at Int)
(declare-const if Int)
(assert (and (<= 1 at) (<= at 10)))
(assert (and (<= 1 if) (<= if 10)))
(assert (distinct at if))
(check-sat)"
Given the social network of individuals with attributes 'name' and 'relationship_type', find the maximum number of people who are directly related to each other.	This can be solved using QF_UF or QF_LIA, where we express a relationship between two individuals as an equivalence relation. We then use the fact that the size of an equivalence relation is equal to the number of pairs of distinct elements in the set. This allows us to compute the maximum number of people who are directly related to each other.	"(declare-const of_friend_to Bool)
(declare-const to_friend_of Bool)
(assert (= of_friend_to to_friend_of))
(assert (= true of_friend_to))
(check-sat)"
Prove that there exists an integer x such that x + 1 = 2 * x	Use QF_UF and set-logic to prove the statement	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that a person can go to exactly two different cities if they travel between cities in different countries.	Using the QF_UF model with a set of cities and countries, prove that the person's travel history is consistent.	"(declare-const a Int)
(declare-const can Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 can) (<= can 10)))
(assert (distinct a can))
(check-sat)"
Prove that a person is either married or single.	(set-of-values x:Person; (set-of-assertions x:-single | x:-married))	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Use QF_LIA to express the relationship between friends and their relationships with others.	Use QF_UF with a set of 'not' constraints to express the relationship between individuals.	
Find all triples (a, b, c) where a has degree 2 in graph G and b is adjacent to both a and c	Use QF_LIA constraints to enforce the properties of the relationships.	"(declare-const G Int)
(declare-const a Int)
(assert (and (<= 1 G) (<= G 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct G a))
(check-sat)"
Find all pairs of distinct people in a university with exactly one common friend.	Use QF_UF to model this relationship and QLIA to restrict the number of friends each person can have.	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (= a_friend_in in_friend_a))
(assert (= true a_friend_in))
(check-sat)"
The set of all prime numbers less than or equal to 100	{(set-logic QF_UF) {(declare-const P UU)   assert (forall (x UU) ( eg ((xor x P) (xor P x))))	"(declare-const of Int)
(declare-const or Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 or) (<= or 10)))
(assert (distinct of or))
(check-sat)"
The given social relationship is valid.	Use QF_UF and set-logic QF_UF to ensure validity of constraints.	
Prove that every person is related to themselves.	Use QF_UF to assert that each person is connected to at least one other person, and then use QF_LIA to conclude that there are no cycles in the graph.	"(declare-const is Int)
(declare-const to Int)
(assert (and (<= 1 is) (<= is 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct is to))
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 0	Use QF_UF and set-logic to reason about the existence of solutions to this equation.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that if person A is friends with person B, and person B is friends with person C, then person A is friends with person C	Use QF_UF and QF_LIA constraints to derive the desired implication. Use the following assumptions: (A,B) and (B,C), and (C,A).	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Prove that for all integers n >= 5, n^2 + n - 13 > 0	The following statements are true:  - set-logic QF_UF - set-logic QF_LIA - declare-const n_ int - declare-variable x int - assert (x = 5) - assert (x^2 + x - 13 > 0)	"(assert true)
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 4x and 2x > 0	Using QF_UF with the set of variables {x} and the constraints from the problem statement, we can derive the following expression: 2 * (x^2 - 4) = 0. Solving for x, we get x = 16. Therefore, there exists an integer solution to the equation.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The friends of Alice are married, but Bob is not	To ensure this is true, we need to assert that (set-of-people x y) != (set-of-people x z)	"(declare-const is_friend_of Bool)
(declare-const of_friend_is Bool)
(assert (not is_friend_of))
(assert (not of_friend_is))
(check-sat)"
Prove that there exists an integer x such that x^2 + 4x - 3 = 0	To prove this equation has a solution, we can use the fact that it is a quadratic equation with two roots. We can also use the method of completing the square to simplify the equation.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that a person is not a friend of themselves	Use   to separate the reasoning into two parts: first, prove that an individual is friends with another if they have at least one movie in common, and second, prove the converse	"(declare-const a_friend_is Bool)
(declare-const is_friend_a Bool)
(assert (not a_friend_is))
(assert (not is_friend_a))
(check-sat)"
Prove that there exists an integer x such that 2*x + 3 >= 0	To prove this, we can use the QF_UF logic with 2*u + 3 <= -u for u >= 0. This is because for any non-negative integer u, 2*u + 3 will always be greater than or equal to 1, satisfying the condition.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The following social constraint is invalid: \nIt states that Alice and Bob are friends when they do not have a mutual friend, which is a contradiction.	\nTo resolve this conflict, we can add constraints to ensure that if Alice is friends with X, then X must also be friends with Alice. This can be achieved using the following QF_UF clause: (\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n)	"(declare-const a_friend_do Bool)
(declare-const do_friend_a Bool)
(assert (not a_friend_do))
(assert (not do_friend_a))
(check-sat)"
Prove that there does not exist an ordered pair of integers (x, y) such that x = 2 and y = 4	This statement can be proven using the QF_UF rule and the fact that x cannot be both even and odd.	"(declare-const an Int)
(declare-const of Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct an of))
(check-sat)"
Prove that there exists an integer x such that x + 1 = 2*x	"\begin{align*} (\exists x (\forall y (y < x \ 2*y == x+y))) &
ightarrow ((\exists z (z >= 0 \ z != -1)))) \end{align*}"	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Satisfying the social constraint: No two people in the same group.	Use QF_UF or QF_LIA to ensure that each person is in a unique set of groups.	"(declare-const No Int)
(declare-const in Int)
(assert (and (<= 1 No) (<= No 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct No in))
(check-sat)"
Prove that there exists an integer x such that 2x + 1 > 0	To prove this, we can use the QF_LIA solver with the following constraints: (set-logic QF_UF) (declare-const x Int) (assert (>= 0 (1 + 2 * x)))	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
A university has two classes: History and English.	The class that starts later must be the one with more students	"(declare-const A Int)
(assert (and (<= 1 A) (<= A 3)))
(check-sat)"
Prove that if Alice and Bob both have a pet cat, then they are friends.	\begin{qf uf} \setof(x:person) (x ~ x.pet.cat) & (x ~ y.pet.cat) \declare-relation(p,q:friend)(p.y ~ q.y) \check-sat	"(declare-const a_friend_if Bool)
(declare-const if_friend_a Bool)
(assert (= a_friend_if if_friend_a))
(assert (= true a_friend_if))
(check-sat)"
PREDicates and Atomic Variables: Prove that there exists an integer x such that x^2 = 0	The solution to this problem can be proven using QF_UF, given the constraints (set-logic QF_UF) and (declare-const x :: int). The key insight is to recognize that if there does not exist an integer x such that x^2 = 0, then we must have a contradiction. This would mean that either x or x+1 cannot be zero, which implies that x is not an integer, leading to a contradiction.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	Use QF_UF and QF_LIA axioms to prove that a valid schedule can be constructed from a given set of jobs with different durations.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the linear programming relaxation of the knapsack problem	Using QF_UF with an interval representation to solve this linear program	"(assert true)
(check-sat)"
Scheduling Problem	Integer linear programming to optimize task allocation on a machine with multiple processing units.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	# Use QF_UF and QF_LIA rules with simple integer constraints to model the scheduling problem. The SMT-LIB program should include the following constraints: # A must be executed by processor C1 P_A <= P_C1 * 2; # Assign tasks to processors based on their capabilities # B must be executed by processor C2 P_B <= P_C2 * 3; # Assign tasks to processors based on their capabilities # Check if the assignment satisfies all constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfies the linear programming relaxation of the flow network of scheduling problem with three nodes and four edges, where each edge has two capacities.	This problem can be solved using the flow network solver of SMT-LIB.	"(assert true)
(check-sat)"
Scheduling Problem	Construct a scheduling problem with two tasks that cannot be scheduled together.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling: max-work-hours	assert (set-logic QF_UF) and (declare-const hours 1: integer) and (declare-const total_hours 0: integer) and (assert (=, total_hours, sumhours(hours))) and (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA with simple integer and boolean constraints to model a scheduling algorithm that assigns jobs to machines based on their processing time and machine capacity.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF with integer variables	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF to solve this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
\(\setoflucore uf) \+ (\declareconst i32 x 10)	\(\checksat (\assert true) \| (\checksat false))	"(declare-const i32 Int)
(declare-const uf Int)
(assert (and (<= 1 i32) (<= i32 10)))
(assert (and (<= 1 uf) (<= uf 10)))
(assert (distinct i32 uf))
(check-sat)"
Scheduling Problem	Use QF_UF to model scheduling as a maximization problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
{'type': 'scheduling', 'domain': 'transportation'}	{'type': 'explanation', 'domain': 'scheduling'}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Check if this scheduling problem is solvable in practice.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a scheduling problem	{'approach': 'brute-force', 'search': 'depth-first'}	"(assert true)
(check-sat)"
\(declare-const x 0: Int\); (set-logic QF_UF)\n(declare-const y 1: Boolean; (assert \(x = true; \))\n(check-sat)	Using the properties of equality and union to derive new constraints	"(declare-const n Int)
(declare-const x Int)
(assert (and (<= 1 n) (<= n 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct n x))
(check-sat)"
Scheduling Problem	Use QF_LIA and set-logic QF_UF to generate constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling problem to minimize make times and meet deadlines	Use QF_UF and QF_LIA rules to analyze constraints on machine times and resource utilization.	"(assert true)
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to enforce valid scheduling rules	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF with linear constraints to model a scheduling problem where tasks are assigned to time slots and their start times must be within a certain range.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to model the scheduling of tasks on a shared resource.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA SMT-LIB rules to derive a valid scheduling plan.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to generate valid constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Minimize Latency	Use QF_LIA and set-logic QF_UF to ensure validity and correctness.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find an assignment that satisfies all constraints	Using QF_UF and QF_LIA, derive valid integer constraints to satisfy the scheduling problem.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_LIA to reason about scheduling constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Maximize the number of customers served while minimizing idle time	Use QF_UF and QF_LIA rules to model the scheduling problem, including constraints on customer arrival and departure times, as well as idle time.	"(assert true)
(check-sat)"
Scheduling Problem: Find an optimal assignment of jobs to machines in a factory	Use QF_UF and QF_LIA rules to solve this scheduling problem, ensuring that all constraints are satisfied exactly.	"(declare-const a_of Bool)
(declare-const a_to Bool)
(declare-const an_of Bool)
(declare-const an_to Bool)
(declare-const in_of Bool)
(declare-const in_to Bool)
(assert (= (+
  (ite a_of 1 0)
  (ite an_of 1 0)
  (ite in_of 1 0)
) 1))
(assert (= (+
  (ite a_to 1 0)
  (ite an_to 1 0)
  (ite in_to 1 0)
) 1))
(assert (<= (+
  (ite a_of 1 0)
  (ite a_to 1 0)
) 1))
(assert (<= (+
  (ite an_of 1 0)
  (ite an_to 1 0)
) 1))
(assert (<= (+
  (ite in_of 1 0)
  (ite in_to 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to solve the scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
(set-logic QF_UF  (declare-const x int)  (declare-const y int)  (assert (>= x 0)    (<= y 10) )	This is a problem that will be solved using SMT-LIB.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Scheduling Problem	Formally specify scheduling constraints using QF_UF and QF_LIA.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the parity of three signals in a 3D system	Use QF_UF with equality constraints and set-logic QF_LIA to enforce non-increasing order.	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Satisfy the following scheduling constraint: Minimize make_time(1, 2) + make_time(3, 4)	Use QF_UF and QF_LIA constraints to ensure that make_time(1, 2) <= make_time(3, 4).	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to prove the satisfiability of the scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA clauses to model the scheduling of tasks on a single processor.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a scheduling conflict on multiple servers	Using QF_UF and QF_LIA to ensure tight coupling between tasks and servers, while respecting resource constraints.	"(declare-const a Int)
(declare-const on Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 on) (<= on 10)))
(assert (distinct a on))
(check-sat)"
Scheduling Problem: Resource Allocation	Use QF_UF and QF_LIA constraints to model resource allocation in a scheduling problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF to define sets of variables and use QF_LIA to check consistency.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Maximize Productivity with Limited Time	This problem can be solved using QF_UF and QF_LIA constraints to ensure that the production of products does not exceed the available time.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	{'constraints': ['(set-logic QF_UF)', '(declare-const X 1)', '(declare-const Y 2)', '(assert (<= X 10))'], 'clauses': ['(check-sat)']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling problem with no conflicts	Use QF_LIA to model this scheduling problem without conflicts.	"(assert true)
(check-sat)"
Scheduling Problem	This problem uses QF_UF and QF_LIA formulas to model a real-time system.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and check-sat to prove the validity of the program, which asserts that there exists an integer solution to the scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	{'constraint_type': 'integer_lower_bound', 'variables': ['x', 'y'], 'constraints': ['(set-logic QF_UF)', '(declare-const x int)', '(declare-const y int)', '(assert (>= x 0))', '(assert (<= y 10))']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Integer Constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the following linear programming relaxation of the 8-hour workday problem with additional constraints	Using QF_UF and QF_LIA, derive the solution to a system of linear equations representing the 8-hour workday problem, where employees are only allowed to work up to 40 hours per week.	"(assert true)
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to prove validity	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Maximize Customer Satisfaction	Use QF_UF or QF_LIA to generate a valid model and check its satisfiability.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Formulate a valid schedule that satisfies all constraints and meets the deadline.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	{'type': 'clausal', 'constraints': ['(set-logic QF_UF)', '(declare-const x Int)', '(declare-const y Bool)', '(assert (not (= x 0)))']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to model this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Find all valid solutions to the following system of linear equations with two variables.	Use QF_LIA and integer constraints to solve this system.	"(declare-const of Int)
(declare-const to Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct of to))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to ensure valid constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling: maximize {x, y} where x is the number of customers served in the first hour and y is the number of customers served in the last hour	The goal is to maximize the total number of customers served within a fixed time frame. This can be achieved by prioritizing customers based on their arrival times.	"(declare-const in Int)
(declare-const is Int)
(assert (and (<= 1 in) (<= in 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct in is))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA constraints to model a scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	To solve the scheduling problem, we need to find an assignment of tasks to machines that satisfies all constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find the optimal assignment of tasks to machines	Use QF_UF and QF_LIA constraints to enforce valid scheduling rules, and check for satisfiability using QBF or DPLL-SAT.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA to represent the scheduling problem as a logic formula	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA solvers to reason about valid schedules.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following scheduling constraint using QF_UF and basic arithmetic constraints.	Use the following set of rules to derive the solution: (set-logic QF_UF) (declare-const X < 10) (assert X > 0) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA constraints to ensure fairness in resource allocation.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given a set of jobs with deadlines and resource requirements, determine the optimal assignment of jobs to machines without violating any deadlines or resource constraints.	Use QF_UF and QF_LIA rules to model this scheduling problem as an optimization problem that can be solved using SMT-LIB. Include assertions for machine availability and job deadlines.	"(declare-const a_to Bool)
(declare-const of_to Bool)
(declare-const or_to Bool)
(assert (= (+
  (ite a_to 1 0)
  (ite of_to 1 0)
  (ite or_to 1 0)
) 1))
(assert (<= (+
  (ite a_to 1 0)
) 1))
(assert (<= (+
  (ite of_to 1 0)
) 1))
(assert (<= (+
  (ite or_to 1 0)
) 1))
(check-sat)"
Scheduling Problem: Minimize Makespan	Given a set of tasks with start times and durations, find the order that minimizes the total makespan.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying an integer linear equation	(= (int x) ( (1 + 2)  = 3))	"(assert true)
(check-sat)"
scheduling_problem	derive_satisfiability_from_just_the_constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	(set-logic QF_UF)  define-variables   x: integer   y: boolean,   z: real  (assert (not (= x 0))) (assert (not (= y true))) (assert (= z 1.5))	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find the minimum number of machines required to schedule tasks with maximum utilization	This problem can be solved using First-Order Logic (FOL) constraints in SMT-LIB. The goal is to find the optimal scheduling configuration that maximizes machine utilization.	"(declare-const of Int)
(assert (and (<= 1 of) (<= of 3)))
(declare-const to Int)
(assert (and (<= 1 to) (<= to 3)))
(assert (distinct of to))
(check-sat)"
Scheduling Problem	{'type': 'Propositional Reasoning', 'reason': 'Using QF_UF with integer constraints and checking satisfiability'}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	Use QF_UF with set of variables and universal quantification to model a scheduling problem where tasks have start and end times.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Generate an exact solution for the following linear programming relaxation of the 5-hour delivery problem	Use QF_UF and QF_LIA constraints to model integer variables representing hours worked by drivers, and use assert statements to enforce non-negativity.	"(declare-const an Int)
(declare-const of Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct an of))
(check-sat)"
\(set-logic QF_UF \n\n(declare-const X true \n  \n  (assert Y = 1) \n  (assert Z < 5))\n	This is a valid SMT-LIB program that includes the necessary logic for model checking and satisfiability.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find optimal assignment of tasks to machines	Use QF_UF and QF_LIA solvers with simple constraints, e.g., (set-logic QF_UF)   (declare-const machine <1..4>   (declare-const task <1..5>))   (assert (>= 0 (size of task)))	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA rules to prove that it is NP-complete.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA to enforce valid scheduling constraints	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF or QF_LIA to model the scheduling problem	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem: Find the optimal assignment of tasks to machines	Use QF_UF and QF_LIA constraints to reason about machine resource allocation.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to enforce precedence constraints on tasks	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF to model the scheduling of tasks with deadlines and resource constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA constraints to model this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Determine if it is possible to assign all tasks to employees within a given time frame.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF and QF_LIA to model scheduling problems.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Use QF_UF with valid constraints to solve this scheduling problem.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a scheduling constraint	Use QF_UF and QF_LIA constraints to model the problem	"(assert true)
(check-sat)"
Modeling scheduling conflicts in a production line	\n\n\n(\n  \n    \n    (\n      \n      \n      \n      \n      \n      \n      \n    ),\n\n  \n\n  (\n    \n    (\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    )\n\n  \n)	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Scheduling Problem	Using QF_UF and QF_LIA rules to reason about scheduling constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	This problem requires the use of QF_UF and QF_LIA rules to reason about scheduling constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Using QF_UF and set-logic to model scheduling problems with multiple tasks and resource constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
scheduling	Use QF_UF rules to model the scheduling of tasks with dependencies.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following integer linear program: P = { x, y | x + y <= 5, x >= 0, y >= 0 }	Use QF_UF and QF_LIA constraints to ensure satisfiability, then check for valid solutions.	"(declare-const P Int)
(declare-const x Int)
(assert (and (<= 1 P) (<= P 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct P x))
(check-sat)"
Scheduling Problem: Given two tasks t1 and t2, assign task t1 to machine M1 and task t2 to machine M2 if both machines are not busy	Propositional Reasoner	"(declare-const M1_t1 Bool)
(declare-const M1_t2 Bool)
(declare-const M2_t1 Bool)
(declare-const M2_t2 Bool)
(declare-const if_t1 Bool)
(declare-const if_t2 Bool)
(assert (= (+
  (ite M1_t1 1 0)
  (ite M2_t1 1 0)
  (ite if_t1 1 0)
) 1))
(assert (= (+
  (ite M1_t2 1 0)
  (ite M2_t2 1 0)
  (ite if_t2 1 0)
) 1))
(assert (<= (+
  (ite M1_t1 1 0)
  (ite M1_t2 1 0)
) 1))
(assert (<= (+
  (ite M2_t1 1 0)
  (ite M2_t2 1 0)
) 1))
(assert (<= (+
  (ite if_t1 1 0)
  (ite if_t2 1 0)
) 1))
(check-sat)"
scheduling:make-schedule	show that it is impossible to schedule two tasks with different start times and one task can be delayed by any amount of time without violating the constraints.	"(declare-const X Int)
(assert (and (<= 1 X) (<= X 3)))
(declare-const Y Int)
(assert (and (<= 1 Y) (<= Y 3)))
(declare-const Z Int)
(assert (and (<= 1 Z) (<= Z 3)))
(assert (distinct X Y Z))
(check-sat)"
{'solver': 'smt2', 'input': '\\{(\\x0 \\y -5) + (\\z + 10) <= 15; \\x1 = (\\x3 + 2) * (\\x4 - 3); \\z = 12; \\v = true; \\w = false;\\n\\(\\x0 < 0 \\n\\n(\\y - 5) * (\\z + 10) <= 15 \\n\\n(\\x1 = (\\x3 + 2) * (\\x4 - 3))\\n\\n(check-sat)'}	{'solver': 'smt2', 'input': '\\{(\\x0 \\y -5) + (\\z + 10) <= 15; \\x1 = (\\x3 + 2) * (\\x4 - 3); \\z = 12; \\v = true; \\w = false;\\n\\(\\x0 < 0 \\n\\n(\\y - 5) * (\\z + 10) <= 15 \\n\\n(\\x1 = (\\x3 + 2) * (\\x4 - 3))\\n\\n(check-sat)'}	"(declare-const n Int)
(declare-const v Int)
(assert (and (<= 1 n) (<= n 10)))
(assert (and (<= 1 v) (<= v 10)))
(assert (distinct n v))
(check-sat)"
Satisfying the constraint that all tasks in a scheduling problem have at least one feasible solution	Use QF_UF and QF_LIA axioms to ensure feasibility, then use modus ponens and contradiction elimination to prove satisfiability.	"(declare-const a Int)
(declare-const at Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 at) (<= at 10)))
(assert (distinct a at))
(check-sat)"
Scheduling Problem: Find the optimal assignment of tasks to machines in a factory	Use QF_UF or QF_LIA constraints and simple integer or boolean constraints to model the problem.	"(declare-const a_to Bool)
(declare-const in_to Bool)
(declare-const of_to Bool)
(assert (= (+
  (ite a_to 1 0)
  (ite in_to 1 0)
  (ite of_to 1 0)
) 1))
(assert (<= (+
  (ite a_to 1 0)
) 1))
(assert (<= (+
  (ite in_to 1 0)
) 1))
(assert (<= (+
  (ite of_to 1 0)
) 1))
(check-sat)"
Satisfy the following system of linear equations with two variables x and y	Use the QF_UF rule to introduce new variables, then use QF_LIA to eliminate them, and finally assert the truth of the resulting equation.	"(declare-const of Int)
(declare-const x Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct of x))
(check-sat)"
Satisfy the constraints of a finite automaton	Use QF_UF and QF_LIA rules to express the constraints of the automaton	"(declare-const a Int)
(declare-const of Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct a of))
(check-sat)"
Satisfy the following linear equations using QF_UF and QF_LIA rules	Use simple integer constraints to represent the relationships between variables.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following constraint using QF_UF and QF_LIA	Use simple integer constraints and   newlines to separate logical statements	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Scheduling Problem	Using QF_UF and QF_LIA rules to derive a valid scheduling plan from a set of constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Resource Allocation Problem	Use QF_UF to model the allocation of resources.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation: Assigning Resources to Tasks	{'variables': ['x', 'y'], 'constraints': ['(set-logic QF_UF)', '(declare-const x Integer)', '(declare-const y Boolean)', '(assert x >= 0)'], 'solver': 'SMT-LIB'}	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA axioms to model this problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Prove that there exists an integer x such that x = 1 and (x + 2) mod 3 = 0	Using the properties of modular arithmetic, we can show that this equation is true for all values of x.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Resource Allocation	Use QF_UF or QF_LIA with simple integer and boolean constraints to solve a resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to ensure valid integer solutions.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
{'name': 'Resource Allocation', 'description': 'A resource allocation problem in a cloud computing environment'}	Using QF_UF and set-logic, we can model this problem as follows:  set-logic QF_UF; assert (declare-const x:integer >= 0); assert (declare-const y:integer > 0); check-sat;	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation: Minimize Number of Server Assignments	(set-logic QF_UF) (declare-const x : integer) (assert (x > 0)) (check-sat)	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF to enforce unit-of-formula equality	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: 3 resources available, 4 requests to allocate	Use QF_UF and QF_LIA constraints to ensure integer solutions are found	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF logic to model this resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA solvers to find an optimal assignment of resources to tasks.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model a resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to define a set of constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	To allocate resources to tasks, we need to minimize waste and maximize efficiency.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use of QF_UF or QF_LIA constraints to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA formulas to model this resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
(set-logic QF_UF (declare-const x int : 1) (assert (equivalent? (add 2 x) (add 5 x)))	Using the properties of arithmetic operations and addition, we can deduce that if (add 2 x) = (add 5 x), then (add 3 x) must be true.	"(assert true)
(check-sat)"
Resource allocation problem	Satisfiability Reasoning and Computation System	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to processes	Using QF_UF and QF_LIA, derive that there exists a valid assignment of resources to each process such that the total resource usage is non-negative.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to ensure fairness in resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: 5 machines, 3 software licenses	Using QF_UF with constraints on machine availability and license usage.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA to model resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to reason about resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to processes	Use QF_UF and QF_LIA constraints to model resource allocation, considering bounds on resources and process demands.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Using QF_UF with set-logic and declare-const constraints to model the allocation of resources between two processes.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation	Using QF_UF with linear constraints to optimize resource usage.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Allocate resources to tasks with minimum latency	{'variables': [{'name': 'latency', 'type': 'int'}], 'assumptions': ['(set-logic QF_UF)', '(declare-const task1-latency 10)', '(declare-const task2-latency 5)'], 'conclusions': ['(assert (leq task1-latency task2-latency 5))']}	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA logical frameworks to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
{'name': 'Resource Allocation', 'description': 'A problem of resource allocation in a computer system', 'satisfiability': False}	{'rule1': '(set-logic QF_UF)', 'rule2': '(declare-const x integer)', 'rule3': '(declare-const y boolean)'}	"(declare-const A_of Bool)
(declare-const a_of Bool)
(declare-const in_of Bool)
(assert (= (+
  (ite A_of 1 0)
  (ite a_of 1 0)
  (ite in_of 1 0)
) 1))
(assert (<= (+
  (ite A_of 1 0)
) 1))
(assert (<= (+
  (ite a_of 1 0)
) 1))
(assert (<= (+
  (ite in_of 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Using QF_UF and set-logic to model resource allocation problem	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
(set-logic QF_UF (declare-const x y Z)	This is a valid program, and it will always find a solution.	"(declare-const Z Int)
(declare-const x Int)
(assert (and (<= 1 Z) (<= Z 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct Z x))
(check-sat)"
Resource allocation: Assigning resources to tasks	Use QF_UF and QF_LIA rules to reason about resource availability	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation	Use QF_UF or QF_LIA to specify the resource constraints and then assert them using set-logic.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to model resource allocation problems, ensuring that resources are allocated in an optimal manner.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF to find valid assignments that satisfy all constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Using QF_UF with set of variables and assertions to solve a resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
\(set-logic QF_UF\) \(declare-const x_0 bool\) \(assert (x_0 = true)\)	\(check-sat\)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA rules to model resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA constraints to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA solvers to find an optimal assignment of resources.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA axioms to reason about resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA quantifiers to model the problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to tasks	Use QF_UF and QF_LIA rules to constrain resource allocation.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation: Minimize the number of machines used in the data center	Use QF_UF and QF_LIA to model this problem, and ensure that it includes  - (set-logic QF_UF) or QF_LIA. Use simple integer constraints for machine utilization.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource allocation: Assigning resources to tasks	Using QF_UF and QF_LIA constraints to ensure fairness in resource allocation, while also ensuring that the system is satisfiable.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Prove that it is possible to allocate resources such that all devices are used and no device is idle	(set-logic QF_UF) # Define the universe of discourse as integers from 0 to N-1 (where N is the number of devices)  (set-logic QF_UF)(declare-const N: int)  (assert (>= N 2))  (check-sat)	"(declare-const is_to Bool)
(declare-const it_to Bool)
(declare-const no_to Bool)
(assert (= (+
  (ite is_to 1 0)
  (ite it_to 1 0)
  (ite no_to 1 0)
) 1))
(assert (<= (+
  (ite is_to 1 0)
) 1))
(assert (<= (+
  (ite it_to 1 0)
) 1))
(assert (<= (+
  (ite no_to 1 0)
) 1))
(check-sat)"
Resource Allocation: Assigning Resources to Jobs	Use QF_UF and QF_LIA constraints, and ensure that all constraints are linear and integer/boolean.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	Integer Variables with Bounds	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Assigning resources to servers in a cloud-based data center	Use QF_UF and QF_LIA constraints to model the resource allocation decision.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and set-logic to model resource allocation with multiple constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA logic to reason about resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Using QF_UF and QF_LIA rules, derive a valid solution that maximizes resource utilization.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Minimize the number of printers used	Using QF_UF and QF_LIA constraints, prove that it is not possible to allocate enough printers to satisfy all user requests without exceeding the available capacity.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation Problem	To ensure efficient resource allocation, we use the QF_UF and QF_LIA rules.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA theory to reason about resource constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA constraints to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use the QF_UF and QF_LIA logics to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
{'smtplib': 'int(x) <= x + 1'}	Satisfiability with constraints (set-logic QF_UF; assert x > 0; check-sat)	"(assert true)
(check-sat)"
Resource allocation problem	This problem involves allocating resources to tasks with different priorities and constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	To allocate resources efficiently, we need to minimize waste and maximize utilization of available resources.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA to represent resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA rules to model resource allocation problems	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to model the resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	{'type': 'model-checking', 'description': 'Verify that a resource allocation model satisfies QF_UF and QF_LIA constraints.'}	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use set-logic QF_UF and declare-const to specify resource allocation constraints.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA rules to formulate a valid resource allocation problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA solvers, and assert that the program produces exactly one solution.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Maximize production of 5 units while minimizing waste	Using QF_LIA and set-logic QF_UF, the following constraints can be derived.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
{'input': '\\(set-logic QF_UF\\) \\n \\n (declare-const x Int\\n \\n assert (x = 0)\n \\n check-sat)'}	This SMT-LIB program checks if a number is zero	"(declare-const n Int)
(declare-const x Int)
(assert (and (<= 1 n) (<= n 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct n x))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA to model this problem and ensure validity.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: assigning 10 units of CPU to process 1 and 5 units to process 2	Use QF_UF and QF_LIA constraints to model the resource allocation problem. Ensure that the total number of units allocated is exactly 15.	"(declare-const A_T1 Bool)
(declare-const A_T2 Bool)
(declare-const B_T1 Bool)
(declare-const B_T2 Bool)
(declare-const C_T1 Bool)
(declare-const C_T2 Bool)
(assert (= (+
  (ite A_T1 1 0)
  (ite B_T1 1 0)
  (ite C_T1 1 0)
) 1))
(assert (= (+
  (ite A_T2 1 0)
  (ite B_T2 1 0)
  (ite C_T2 1 0)
) 1))
(assert (<= (+
  (ite A_T1 1 0)
  (ite A_T2 1 0)
) 1))
(assert (<= (+
  (ite B_T1 1 0)
  (ite B_T2 1 0)
) 1))
(assert (<= (+
  (ite C_T1 1 0)
  (ite C_T2 1 0)
) 1))
(check-sat)"
Resource Allocation: 3 cars and 4 passengers	Use QF_UF and set-logic to ensure that each passenger has at least one seat	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation optimization	Use QF_UF and QF_LIA constraints to model resource allocation problems.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation	Use QF_UF and assert/declare/check-sat to model resource allocation.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	(set-logic QF_UF) (declare-const x (int)) (assert (not (= 2, 0))) (check-sat)	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF or QF_LIA to specify the resource allocation model.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Ensure that the minimum number of units required to satisfy all resource constraints is met	Use QF_UF and QF_LIA to reason about the satisfiability of the program, and check for validity using SMT solver.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF with assert statements to model this problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation	Use QF_UF and QF_LIA rules to ensure feasibility.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem: 5 agents, each with capacity 2 and deadline 10	Use QF_UF and QF_LIA rules to prove existence of a solution that satisfies all constraints	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	 - {set-logic QF_UF         assert (2 > 0)}	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation problem	Use QF_UF and QF_LIA rules to solve this optimization problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource Allocation Problem	Use QF_UF and QF_LIA solvers with simple integer constraints to model this problem.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
Resource allocation: Ensure that the maximum number of employees is allocated to each department	Use QF_UF or QF_LIA quantifier, and simple integer constraints (e.g., <=) to represent the relationship between departments and employees.	"(assert (<= (+
) 1))
(assert (<= (+
) 1))
(assert (<= (+
) 1))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A woman has two coins that total 30 cents. One coin is not a nickel, and one coin is not a quarter. What type of coin are they?	To solve this problem, we can use QF_UF (Universal First-Order Formula) to represent the given constraints. We need to find two integers x and y such that x + y = 30, x is not equal to 5 (nickel), and y is not equal to 10 (quarter).	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
A farmer has a rectangular field with integer coordinates in pixels, and she wants to know if it's possible to place a row of n x m flowers on this field such that no two flowers are adjacent.	This problem can be solved using QF_UF (Unfolding Formulas) or QF_LIA (Linear Arithmetic Inequality).	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
Solve for x: 2*x + 5 = 11	Use QF_LIA and set-logic to model this equation as an equality of integer constraints.	"(assert true)
(check-sat)"
A farmer has a field with 3 rows and 4 columns. Each cell can hold either an integer from 1 to 10, inclusive.	{   (set-logic QF_UF)   (declare-const row1 int   row2 int   row3 int),   (declare-const col1 int   col2 int   col3 int),   (assert (>= row1 1)            (<= row1 10))   (assert (>= row2 1)            (<= row2 10))   (assert (>= col1 1)            (<= col1 4))   (assert (>= col2 1)            (<= col2 3))   (assert (>= col3 1)            (<= col3 4))   (check-sat)}	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
3+2=5	Using QF_LIA, we can assert that the sum of two integers less than or equal to 10 is greater than 1 and less than or equal to 15.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Solve for x: 2*x + 5 = 11	Use QF_LIA with constraints: x >= 0, 2x <= 6	"(assert true)
(check-sat)"
(set-logic QF_UF (declare-const x 1) (assert (>= x 0)) (check-sat)	This is a simple satisfiability problem, where we need to find an assignment of values to the variable x such that all constraints are satisfied.	"(assert true)
(check-sat)"
Solve the following logic puzzle: A bat and a ball together cost $1.10. The bat costs $1.00 more than the ball. If you have 5 times as many bats as balls, how much will you pay?	Let B represent the number of balls and B+ represent the number of bats. From the first equation, we get: B + (B+1) = 10. This simplifies to 2B + 1 = 10, or B = 4.5. Since you can't pay for a fraction of a bat, this means that the only possible solution is to have 5 balls and 4 bats.	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
The Five Switches	Use QF_LIA and set-logic QF_UF to prove that there is exactly one way to program a computer to switch between five lights on, one at a time, while the lights are off.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that there exists an integer x such that x^2 + x - 5 = 0	Use QF_UF and set-logic to prove the existence of a solution, and use check-sat to find it.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The Five Houses	Using set-logic QF_UF and quantifiers, prove that there exists a house on each row such that at least one of its doors is open.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF and QF_LIA to prove that there exists a number between 1 and 3 that has exactly one switch on.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	(set-logic QF_UF) (declare-const x true) (declare-const y false) (declare-const z true)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Five Houses Problem	To solve this problem, we need to use the QF_UF and QF_LIA SMT-LIB rules.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A man, a plan, a canal, Panama!	(set-logic QF_UF   (declare-const X 0 5)   (declare-const Y 5 10))(assert (>= X 1) (<= Y 4))   (check-sat)	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Three Switches	Use QF_UF and assert statements to prove that there is a unique solution to this puzzle.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Five Houses Problem	To solve this puzzle, we need to find a valid assignment of integers from 1 to 5 to the five houses such that no two adjacent houses have more than one occupant.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF to represent three switches, and assert that they are either all on or none of them is on.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has 'a' apples and 'b' bananas in his orchard. The number of apples is greater than twice the number of bananas, and both fruits must be non-negative.	The constraints are: (set-logic QF_UF) (declare-const a int > 0) (declare-const b int > 0) (assert (a > 2 * b) (check-sat)	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
A farmer has three fields: A, B, and C. Field A can hold values 0 through 9. Field B can hold values -1 through 1. Field C can only hold the number 5.	The farmer needs to ensure that field C holds a value of either 0 or 4. If field A holds any other value, then field C must be 0. Otherwise, if field A is 5 or greater, then field B must be -1.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
(set-logic QF_UF   (declare-const x 9)   (declare-const y 10)   assert (>= x 0)   assert (<= y 100)   check-sat)	Satisfiability isomorphism using UFL constraints and linear integer programming.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Satisfy the following set of constraints on the variable x.	Use the quantifier 'for all' to generalize over all natural numbers n.	"(declare-const of Int)
(declare-const on Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 on) (<= on 10)))
(assert (distinct of on))
(check-sat)"
A farmer has 5 sheep and 3 goats. How many animals does she have?	(set-logic QF_UF  (declare-const A int  (A = 5)  (G int  (G = 3)))  (assert < A + G > 0))	"(assert true)
(check-sat)"
The Set of Twin Primes	- Prove that there do not exist two prime numbers p and q such that pq = 2.	"(assert true)
(check-sat)"
A 5-person committee needs to decide on a project leader.	Use QF_UF and assert constraints like (equal (= 1 2)) or (not (equal (= 3 4))).	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
Solve for x: 2x + 5 = 11	Use QF_UF and set-logic (maximize) to find an optimal solution.	"(assert true)
(check-sat)"
The Five Houses Problem	To solve this problem, we need to assign numbers to each of the five houses such that each house is assigned a number between 1 and 5 (inclusive), and no two adjacent houses have the same number.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use the rules provided by the problem to construct a valid solution.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Five Houses Puzzle	To solve this puzzle, we need to find a valid assignment of integers from 1 to 5 to the five houses such that each house is either occupied by an integer or not.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer wants to optimize his irrigation system to minimize water waste.	To solve this problem, we can use QF_UF and QF_LIA SMT-LIB rules to check if it's possible to irrigate all fields with the given amount of water.	"(declare-const A Int)
(declare-const to Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct A to))
(check-sat)"
Solve the following puzzle:  3 x + y = 6, 2x - y = 4.	(set-logic QF_UF) (declare-const x Int) (declare-const y Int) (assert (>= x 0) (assert (>= y 0)) (verify-sat)	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
A person is standing next to a box with an unknown weight. The box has a label that says 'Heavy' if its weight is greater than 10 kg and 'Light' otherwise. The person is holding the box, but they don't know which side it's on. What can be said about the box?	Using QF_UF, we can assert that the box is either Heavy or Light.	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
There are three switches: hot, cold and off.  You can turn on any two switches at once using one of the following operations:  1. Turn on switch A and then off switch B.  2. Turn on switch C and then off switch D.  3. Turn on switch B and then off switch D.  4. Turn on switch A and then turn on switch C.  5. Turn on switch C and then turn on switch D.	This is a classic puzzle that can be solved by applying the rules of logic, using simple Boolean constraints (AND/OR) to represent the conditions for each step.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A man, a plan, a canal, Panama!	(set-logic QF_UF   (declare-const X 0 5)   assert (<= X 0)   check-sat)	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Five Houses Puzzle	To solve this puzzle, we need to use QF_UF constraints to represent the relationships between the houses and their occupants.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF to create a function symbol and apply it to three variables in a predicate.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfy the following statement	Use the QF_UF and QF_LIA rules to generate a model that satisfies this statement.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying a linear equation with two variables	Use QF_UF to ensure equality and QF_LIA to allow variable combination.	"(assert true)
(check-sat)"
Find integers x such that x^2 + 1 = x+3	This equation can be solved using QF_UF with the following constraints: (set-logic QF_UF) and (declare-const x integer)	"(assert true)
(check-sat)"
Prove that there exists an integer x such that x^2 + 4x - 7 = 0 and x is even	To prove this, we can use the QF_UF rules to find a model for the equation x^2 + 4x - 7 = 0. We can then analyze the models to determine which ones satisfy the condition that x is even.	"(declare-const an Int)
(declare-const is Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct an is))
(check-sat)"
(set-logic QF_UF (declare-const x 1 x < 5) (declare-const y 2 y = x + 3) assert (>= y 4)	To prove that the assertion is true, we can use a model with x >= 0 and y > 0.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
(set-logic QF_UF) (declare-const x 1) (assert (not (= x 0))) (check-sat)	To prove that x is not equal to 0, we can use the property of equality that if a = b then a = b.	"(assert true)
(check-sat)"
(set-logic QF_UF  define-const X 0  assert (<= X 5)  check-sat	This puzzle requires the solver to find a value for X such that it is less than or equal to 5.	"(assert true)
(check-sat)"
A farmer has a field that is 100 meters long and 50 meters wide. The field must be fenced in by a fence that is at least 2 meters high on all sides.	The farmer can use the following constraints to solve this problem:  - (declare-const field-width 50 :integer) - (declare-const field-length 100 :integer) - (assert (>= (add (multiply field-width 2) (add field-length 2)) (add field-width 2)))	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The set-builder logic asserts that there exists an integer x such that x^2 + 4x - 3 = 0.	\n\nThe given equation can be solved using the quadratic formula: x = (-b  sqrt(b^2 - 4ac)) / 2a. In this case, a=1, b=4, and c=-3. \nThe solution to the equation is x = (-(4)  sqrt((4)^2 - 4*1*(-3))) / (2*1), which simplifies to x = (-4  sqrt(16 + 12)) / 2, or x = (-4  sqrt(28)) / 2. Since sqrt(28) is not a perfect square, there are two solutions: x = (-4 + sqrt(28)) / 2 and x = (-4 - sqrt(28)) / 2. \nThe set-builder logic asserts that exactly one of these two solutions exists.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The Five Houses Problem	Use set-logic QF_UF and declare variables for each house number.  (declare-const house1-number 1) (declare-const house2-number 2) (declare-const house3-number 3) (declare-const house4-number 4) (declare-const house5-number 5)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Find an infinite set {x: [0, 1]}.	This problem can be solved using QF_UF.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that there exists an integer x such that x^2 + 4 = 13	Use QF_UF and set-logic to derive the desired formula.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
(set-logic QF_UF  (declare-const x 1)  (declare-const y 2)	This problem is a simple example of using set-logic QF_UF to reason about the satisfiability of a given formula.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
A farmer wants to ensure that all cows are wearing collars of a certain color.	The farmer has ordered 100 cows, each with one collar. The collar can be either red or blue. Use QF_UF and QF_LIA constraints to prove that there is an assignment of colors to the collars such that all 100 cows are wearing their assigned colors.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Flipped Coins	Use QF_UF with a set of variables and constraints to prove that it's impossible to flip all coins such that one side always shows the opposite number.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Prove that there exists an integer x such that exactly three switches are open.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use QF_UF to prove that exactly one of three boolean variables can be false at any given time.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Prove that it is impossible to assign colors to three switches such that each switch corresponds to one of three colors and the corresponding color switch is red.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
\(\{\n  x: \n    # Introduce a variable and constraint\n    assert(x > 0);\n  y: \n    # Introduce another variable and constraint\n    assert(y < x);\n  z: \n    # Use SMT-LIB to prove the variables are equal\n  (set-logic QF_UF \n    (declare-const x : int) \n    (declare-const y : int) \n    (declare-const z : bool))\n  \n  assert(z);\n  \n  (check-sat)	\(\{\n  # We use the fact that x > 0 and x + y = z to prove x == z\n  assert(x + y = z + x);\n  \n  # Since z is True, we can deduce x == z\n  assert(x == z);\n  \n  \n  # Use the assumption that x < 0 and x - y = z to prove x != z\n  assert(x > 0 && x - y = z);\n  \n  # Since z is False, we can deduce x != z\n  assert(x != z);\n  \n  \n  \n  (check-sat)	"(declare-const a Int)
(declare-const n Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 n) (<= n 10)))
(assert (distinct a n))
(check-sat)"
A prisoner needs to escape from a cell with multiple locks, each of which has two possible keys: the correct key or the wrong key. The guards enter a room and check one lock at a time in order.	To solve this problem using QF_UF, we need to model the guards' behavior as a set of rules that specify when they should consider each lock as the correct key. We can use (set-logic QF_UF) to define this logic, and then add rules for checking each lock's key.	"(declare-const A Int)
(assert (and (<= 1 A) (<= A 3)))
(declare-const a Int)
(assert (and (<= 1 a) (<= a 3)))
(declare-const and Int)
(assert (and (<= 1 and) (<= and 3)))
(assert (distinct A a and))
(check-sat)"
A woman has two coins that weigh differently. One coin weighs 1 kg and the other weighs 0.9 kg. How much does the lighter one weigh?	Use set-logic QF_UF and assert   (weigh < 1kg)  and (not (weigh = 0.9kg))	"(declare-const A Int)
(declare-const kg Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 kg) (<= kg 10)))
(assert (distinct A kg))
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 0 and x is not odd	To prove this statement, we can use the QF_UF rule to generate a set of solutions for the equation x^2 + 1 = 0. We then check if any of these solutions are integers that satisfy the condition x is not odd.	"(declare-const an Int)
(declare-const is Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct an is))
(check-sat)"
A farmer has two fields, A and B. Field A has 5 apples, and field B has 3 oranges. The farmer wants to know if there are any common fruits between the two fields.	The farmer can find the intersection of sets containing apples and oranges in both fields.	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
A bat and a ball together cost $1.10. The bat costs $1.00 more than the ball. If the ball costs x dollars, how much does the bat cost?	Let b = number of cents in the ball. Then the equation is (100 - b) + b = 110. Solve for b.	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
Satisfying the union of two sets with distinct elements	Use QF_UF and set-builder constraints to model the union of two sets A = {1, 2} and B = {3, 4}. The constraint (set-logic QF_UF) ensures that each element in both sets is present. The constraint (declare-const x : setof int) defines a set of integers containing all elements from both sets. Finally, the constraint (assert all of A | B) asserts that any element in either set is present.	"(assert true)
(check-sat)"
A farmer has two fields, A and B. Field A is 3 units long, while field B is only 2 units long. The farmer wants to know if there are enough spaces on both fields.	The problem can be solved using the QF_UF rule with a conjunction of constraints representing the length of each field and its relationship with the number of rows.	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Satisfying a set of rules on the number of apples	Use QF_UF to generate constraints for the number of apples in each basket and then solve using check-sat.	"(declare-const a Int)
(declare-const of Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct a of))
(check-sat)"
A farmer has two fields: Field A and Field B. If it rains, both fields receive water, but only if it's not too hot.	let (   0:     assert (>= 20 any x) => (x = 'hot')   1:     assert (= 100 any y) => (y = 80)   2:     let (       z: set of string       f0: {x | x = 'hot', x < 20}       f1: {x | x = 'hot', x >= 20, x <= 30}       f2: {x | x = 'hot', x > 30})     assert (in z f0)     & (not in f1 f0)    & (in f2 f1)	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A farmer wants to irrigate all but two rows of his garden, and then water one row. What are the possible values for k?	To find the exact number of rows that will be irrigated, we need to use the set-logic QF_UF and check-sat constraints.	"(declare-const A Int)
(declare-const k Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 k) (<= k 10)))
(assert (distinct A k))
(check-sat)"
"{   'problem': ""Solve the following puzzle: There are three switches, but they are not labelled. Each switch corresponds to one of three light bulbs in a room. Each bulb is either on or off. You can turn the switches on and off as many times as you want, but you can only enter the room one time to observe the bulbs. How can you figure out which switch corresponds to which light bulb?"""	{   (set-logic QF_UF)   (declare-const bulb1 bool   bulb2 bool   bulb3 bool)   (declare-const switches [ bulb1 true    bulb2 false    bulb3 true ]   (assert not (switches[0]            or switches[1]            or switches[2]))   (check-sat)	"(declare-const a Int)
(assert (and (<= 1 a) (<= a 3)))
(declare-const as Int)
(assert (and (<= 1 as) (<= as 3)))
(declare-const in Int)
(assert (and (<= 1 in) (<= in 3)))
(assert (distinct a as in))
(check-sat)"
(set-logic QF_UF (declare-const x int) (declare-const y bool) (assert (>= x 0) (check-sat)	This is a simple problem that can be solved using basic arithmetic and logical constraints. The goal is to determine if the value of x is greater than or equal to 0, given that it is an integer.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
(set-logic QF_UF   (declare-const x y int)   (assert x > 0))	This is a simple logic puzzle where we are asked to prove that if x is greater than 0, then x is positive.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
A farmer has a field that can hold up to 1000 square meters of land. The field is currently empty, and it needs to be fenced in.	The farmer needs to fence in at least 800 square meters of land for this task.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Three Switches	Use set-logic QF_UF and assert/declare/declare-const to model a problem where a person has three switches, labelled A, B and C, and each switch corresponds to one of three light bulbs in a room. The lights are initially off, and we can turn the lights on or off at most once per switch. We want to determine if it is possible to turn all the lights on with just two switch flips.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
(set-logic QF_UF (declare-const x y 1))	(assert y = 1) && (check-sat)	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
The Three Switches	{'type': 'deductive', 'constraints': ['\n  assert (x = 0)\n', '\n  assert (y = 1)\n', '\n  assert (z = 2)\n']}	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use set-logic QF_UF and assert/unify to prove that there is no valid assignment of colors to switches such that each switch corresponds to either red or green.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Satisfying the following system of linear equations with integer coefficients and constraints	Use QF_LIA or QF_UF to generate the model, then solve it using a solver like DPLL or CDT.	"(assert true)
(check-sat)"
(set-logic QF_UF (declare-const x 1 #t) (declare-const y 2 #f) (assert (x = true) (y = false)))	to prove that x and not y are both true or both false using only basic arithmetic operations and equality checks	"(declare-const f Int)
(declare-const t Int)
(assert (and (<= 1 f) (<= f 10)))
(assert (and (<= 1 t) (<= t 10)))
(assert (distinct f t))
(check-sat)"
The set of all perfect numbers	This is a classic problem in number theory, and it can be solved using QF_UF with constraints such as (forall x (<= 1000) (odd? x))	"(assert true)
(check-sat)"
Solve the puzzle: 5 cars are parked on the street, and each car has a different color. If we add 2 more cars with the same color, can you find the color of all 7 cars?	Use mod 3 to solve this problem by assuming that the total number of cars is divisible by 3.	"(declare-const If Int)
(declare-const a Int)
(assert (and (<= 1 If) (<= If 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct If a))
(check-sat)"
A farmer has a field with two rows and two columns. Each cell in the field can be either red or green. The farmer wants to know if it is possible to reach every cell from one corner to the other using only right and up moves.	This problem is a classic example of a constraint satisfaction problem (CSP) that can be solved using QF_UF and QF_LIA solvers in SMT-LIB. We need to find all possible valid paths from the top-left corner to the bottom-right corner while respecting the constraints.	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
Satisfy the following proposition: 2 + 2 = true.	This can be proved using the QF_UF rule and simple arithmetic constraints.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use a model with three variables and two constraints to solve this puzzle.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given integers a and b, find all pairs of distinct positive integers c and d such that a + b = c + d	Prove the validity of the following system using QF_UF or QF_LIA with integer constraints: (set-logic QF_UF)   (declare-const a Int)   (declare-const b Int)   (declare-const c Int)   (declare-const d Int)   (assert (a + b = c + d))   (check-sat)	"(declare-const a Int)
(declare-const b Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 b) (<= b 10)))
(assert (distinct a b))
(check-sat)"
Prove that the following statement is true: x = 5 and y != 3	Use the QF_UF rule to combine the assertions of x = 5 and y != 3, then use the QF_LIA rule to prove the conjunction of these two statements. Finally, add a check-sat clause to verify that the system is satisfiable.	"(declare-const is Int)
(declare-const x Int)
(assert (and (<= 1 is) (<= is 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct is x))
(check-sat)"
Solve the following puzzle: A bat and a ball together cost $1.10. The bat costs $1.00 more than the ball. If the ball costs x dollars, how much does the bat cost? y.	$y-x=0.10\quad$y>x$	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
A 5-person committee must be formed from a group of 8 people, and each person can only speak on one topic.	Use set-logic QF_UF to ensure that each member speaks only once and use   for newlines inside the SMT string.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
The Five Houses Puzzle	Use QF_UF to express that each house is occupied by either a person or an animal.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has N cows to milk. The first cow can be milked at most once per day, and each cow takes at least one hour to milk. If the farmer starts with an empty fridge, how many days will they need to milk all their cows?	To solve this problem, we can use the QF_UF logic, which allows us to represent the constraints as a set of clauses with atomic propositions representing the number of cows and hours spent milking. We can then use the 'check-sat' solver to find an optimal solution.	"(declare-const A Int)
(declare-const If Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 If) (<= If 10)))
(assert (distinct A If))
(check-sat)"
The Three Switches	(set-logic QF_UF) (declare-const x 1) (assert (x = 0)) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has two fields, A and B. Field A contains all the apples from both fields combined. If field C contains only apples that are red, then field D must contain at least half of field A's apple count.	Use QF_UF and QF_LIA to solve this problem. Consider the constraints (set-logic QF_UF) and (declare-const ...). Use assert statements to define field A and field B. Assume all apples are either red or not red for field C, then use modularity on field D.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A farmer has 5 sheep and wants to build a fence around them. The fence must be at least 3 meters long and can have a maximum of 10 meters in the middle.	Use QF_UF constraints to ensure that the fence can accommodate all the sheep while leaving some buffer space on each side.	"(declare-const A Int)
(declare-const a Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct A a))
(check-sat)"
A farmer has 'm' chickens and wants to know if they are all happy.	The answer is yes if and only if m = 5 or m = 6	"(declare-const A_friend_if Bool)
(declare-const if_friend_A Bool)
(assert (= A_friend_if if_friend_A))
(assert (= true A_friend_if))
(check-sat)"
The Life of Pi	Use QF_UF and assert constraints on pi, x, and y.	"(declare-const Pi Int)
(declare-const of Int)
(assert (and (<= 1 Pi) (<= Pi 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct Pi of))
(check-sat)"
A farmer has three fields: A, B and C. Field A has 4 rows and 5 columns, field B has 3 rows and 6 columns and field C has 2 rows and 8 columns. The farmer wants to know how many hot peppers are in each field.	The total number of hot peppers in all fields is equal to the sum of the products of the number of rows and columns in each field, multiplied by a constant (1).	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
\(\(\{1:2, 3:4} \) -> (false))	(set-logic QF_UF) (declare-const X int) (assert (X = 1) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
(set-logic QF_UF) (declare-const x 1  # t) (assert (<= 0 (and x 2) (add 3 x))) (check-sat)	"Using the <a href=""https://www.sat.inf.u-bremen.de/"">SAT solver</a> to verify the satisfiability of the given formula. We found that it is unsatisfiable for all values of x."	"(declare-const t Int)
(declare-const x Int)
(assert (and (<= 1 t) (<= t 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct t x))
(check-sat)"
The Three Switches	"(set-logic QF_UF 	(declare-const x 1) 	(declare-const y 2) 	(assert (not (= x 0))) 	(check-sat)"	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	QF_UF and set-logic QF_LIA	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has 5 rows of flowers in her garden, and each row can have at most 3 flowers. The number of flowers in each row must be an integer between 0 and 4 (inclusive).	The number of flowers is a valid integer.	"(declare-const A Int)
(declare-const an Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 an) (<= an 10)))
(assert (distinct A an))
(check-sat)"
Satisfying a simple equation	Use <~{ to enforce an inequality, and <~~ to enforce equality.	"(assert true)
(check-sat)"
Satisfying the Chicken McNugget Theorem	The Chicken McNugget Theorem states that the sum of two relatively prime numbers has a unique representation as a linear combination of those two numbers. Prove this theorem using QF_UF and SMT-LIB.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The Three Switches	Use a switch statement to determine which color shirt to wear based on the day of the week.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
A farmer has three fields of wheat: Field A, Field B, and Field C. Each field can hold either 0 or 1 units of wheat. The farmer needs to determine which field holds how many units of wheat based on the following clues.	Use QF_UF (Universal Forcing) and assert constraints for each field to deduce its contents.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
A farmer has two fields, A and B. Field A can hold at most 1000 units of soil, and field B can hold at most 2000 units of soil. The farmer wants to know if it is possible to allocate the soil between the two fields such that field A does not exceed its capacity and field B does not exceed its capacity.	use QF_UF to add constraints on the number of units in each field, check-sat to verify the validity of the constraints	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Solve the following logic puzzle: There are three switches, but they are not labelled. Each switch corresponds to one of three light bulbs in a room. Each bulb is either on or off. You can turn the lights on and off as many times as you want, but you can only enter the room one time to observe the bulbs.	Use QF_UF to model the switches and their corresponding light bulbs. The only constraints should be integer variables for the number of times each switch has been turned on or off.	"(declare-const a Int)
(assert (and (<= 1 a) (<= a 3)))
(declare-const as Int)
(assert (and (<= 1 as) (<= as 3)))
(declare-const in Int)
(assert (and (<= 1 in) (<= in 3)))
(assert (distinct a as in))
(check-sat)"
The set of all perfect squares between 0 and 100	Use QF_UF to express that a number is either even or odd, then use the property (forall x (x = 0) -> (not (x^2))) to assert that there are no perfect squares less than 100.	"(assert true)
(check-sat)"
The Five Houses Problem	Use QF_UF and QF_LIA solvers to prove the following statement: There exists an integer x such that x^2 + x + 1 = 5x + 4 or (x == 0 and y == 2) or (x == 3 and y == 1)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
\u03c0\u202f\u2228\u221a\u203b\u2153\u2192\u2115\u20d1\u2164\u217e\u22cc\u2202\u2189\u2164\u223b\u2193\u214f\u2187\u212a\u215c\u2236\u219d\u2210\u2135\u2188\u217c\u2221\u218a\u216f\u220e\u2192\u211c\u2153	\u03b7\u2129\u20ac\u201d\u2060\u2035\u2130\u2211\u2148\u218a\u2164\u217e\u22cc\u2202\u218f\u2153\u219b\u222c\u2207\u2189\u207d\u2066\u2120\u20ac\u201d\u2035\u2130	"(declare-const u2115 Int)
(declare-const u2135 Int)
(assert (and (<= 1 u2115) (<= u2115 10)))
(assert (and (<= 1 u2135) (<= u2135 10)))
(assert (distinct u2115 u2135))
(check-sat)"
problem	reasoning	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that two people are friends if and only if they have a mutual friend	Use QF_UF to prove the biconditional, and use set-logic to add the necessary constraints	"(declare-const a_friend_if Bool)
(declare-const if_friend_a Bool)
(assert (= a_friend_if if_friend_a))
(assert (= true a_friend_if))
(check-sat)"
(set-logic QF_UF   (declare-const x int)   (assert (not (= x 0)))   (check-sat)	The assertion will only be true if x is not equal to 0.	"(assert true)
(check-sat)"
Social inequality	Use QF_UF to model the relationship between income and education level, where higher income leads to higher education level.  (declare-const X (integer : LessThan 5))  (declare-const Y (integer : GreaterThan 0))  (assert (QF_UF (     X Y              <= 4 ? true : false) )	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given a social network with people of different ages, find all pairs of individuals who are friends.	To solve this problem, we can use QF_UF and check-sat constraints to derive the friendships between people. We can first list all possible pairs of individuals, then constrain each pair using simple integer or boolean constraints (e.g., `age(a, b) <= 18 && age(b, a)`), and finally check for satisfiability.	"(declare-const a_friend_of Bool)
(declare-const of_friend_a Bool)
(assert (= a_friend_of of_friend_a))
(assert (= true a_friend_of))
(check-sat)"
Prove that there exists an integer x such that x + 1 = 3 and x - 2 > 0	Use the QF_UF rule to combine x + 1 = 3 with x - 2 > 0 to get (x+1) - (x-2) = 5 > 0	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The given social constraint is inconsistent and cannot be satisfied by any assignment of integers or booleans.	A valid solution would require the existence of a finite set of integer values that can satisfy all constraints simultaneously.	"(declare-const be_of Bool)
(declare-const be_or Bool)
(declare-const by_of Bool)
(declare-const by_or Bool)
(declare-const is_of Bool)
(declare-const is_or Bool)
(assert (= (+
  (ite be_of 1 0)
  (ite by_of 1 0)
  (ite is_of 1 0)
) 1))
(assert (= (+
  (ite be_or 1 0)
  (ite by_or 1 0)
  (ite is_or 1 0)
) 1))
(assert (<= (+
  (ite be_of 1 0)
  (ite be_or 1 0)
) 1))
(assert (<= (+
  (ite by_of 1 0)
  (ite by_or 1 0)
) 1))
(assert (<= (+
  (ite is_of 1 0)
  (ite is_or 1 0)
) 1))
(check-sat)"
Prove that John and Mary are married	Use QF_LIA and assert the following equations to prove this statement, then check-sat.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Ensure that no two people in a friendship network have more than one connection to each other	"model  	 globeforall x y z:  		headgedd (x, y)  		and  		( x  eq z |  			not ( 			y, z)  	))"	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (= a_friend_in in_friend_a))
(assert (= true a_friend_in))
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 2x and x is less than or equal to 10	{'method': 'modelChecking'}	"(declare-const an Int)
(declare-const is Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct an is))
(check-sat)"
Prove that there exist two distinct integers x and y such that x + y = 5	Using QF_UF with constraints x >= 0, y <= 5, and x + y = 5, derive the existence of a solution.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that it is not possible to construct a directed acyclic graph (DAG) with more than 5 nodes and 10 edges.	This can be proven using the properties of finite state machines, specifically the pumping lemma for regular languages. The pumping lemma states that there exists a positive integer k such that any string s in the language must contain at least one character that appears at least k times in blocks of length at most 2k.	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Prove that there exists an integer x such that x^2 + 4 = 8 and x^2 - 3 < 0.	This problem can be solved using the QF_UF rule, which states that for any formula f(X) of type 'quantifier-free' with one free variable X, we have either f(X) or f(X). We will use this rule to derive a contradiction. First, we show that 3^2 - 4 = 5 and 3^2 + 4 > 8. Then, we can conclude that there exists an integer x such that x^2 < 0.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that 'John' is not equal to 'Alice'	Use QF_UF with set-logic and assert constraints.	"(declare-const is Int)
(declare-const to Int)
(assert (and (<= 1 is) (<= is 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct is to))
(check-sat)"
Prove that there exists an integer $x$ such that x^2 + 3x - 4 = 0	The quadratic equation has at least one real root according to the Fundamental Theorem of Algebra, and we can show this by attempting to solve it manually.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that there exists an integer x such that x > 0 and (x + 1) mod 3 = 2	Using the properties of modular arithmetic, we can derive that if x is positive, then (x + 1) mod 3 must be equal to 2. This implies that there exists a unique integer solution for x.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that John and Mary are married.	(set-logic QF_UF) (declare-const John mary : pair (string , string)) (assert (John mary) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that a person is not married to themselves.	(not (set-of-facts (set-of-constants 'x) (set-of-constants 'y)))	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Prove that for all integers n >= 2, (1 + n) mod 3 = 0.	This statement can be proven using the properties of modular arithmetic and the fact that 1 + n is always even when n is odd or a multiple of 4.	"(assert true)
(check-sat)"
Prove that there are at least two distinct social connections between individuals in a small community.	Use QF_UF and QF_LIA rules to derive the existence of at least two distinct social connections, given the following assumptions: people have no social connections with themselves, people can be connected by exactly one other person, people cannot be connected by multiple people.	"(declare-const a Int)
(declare-const at Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 at) (<= at 10)))
(assert (distinct a at))
(check-sat)"
Verify that the following relation holds: (x, y) <- (x, z) && (y, z)	Use QF_UF and QF_LIA rules to derive the implication.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that it is impossible to have two people who are friends with each other	{'description': 'Use QF_UF and set-logic to model this relationship.', 'smtlib': 'set-logic QF_UF\ndeclare-const Alice:Int\ndeclare-const Bob:Int'}	"(declare-const is_friend_it Bool)
(declare-const it_friend_is Bool)
(assert (= is_friend_it it_friend_is))
(assert (= true is_friend_it))
(check-sat)"
Given the following social network structure: [1, 2; 2, 3; 3, 4], define the minimum number of friendships required to satisfy all constraints.	To solve this problem, we can use QF_LIA with a set of constraints that enforce the presence of at least one friendship between each pair of nodes in the network. We can then check if the resulting model is satisfiable using check-sat.	"(declare-const of_friend_to Bool)
(declare-const to_friend_of Bool)
(assert (= of_friend_to to_friend_of))
(assert (= true of_friend_to))
(check-sat)"
Prove that any two people are connected in a social network	Use QF_UF and QF_LIA rules to reason about graph connectivity	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Verify that a social relationship graph is consistent.	{   (set-logic QF_UF)   (declare-const person1 person2 : FRIENDS)   (assert (forall (x person)         (           (person1 x)                        (person2 x))         (not (eq x x)))   )	"(declare-const a_friend_is Bool)
(declare-const is_friend_a Bool)
(assert (= a_friend_is is_friend_a))
(assert (= true a_friend_is))
(check-sat)"
Prove that two people are friends if and only if they share a common interest.	Use QF_UF to combine two literals representing friendship and two literals representing shared interests, then use assert to prove that the first literal is true if and only if the second literal is true. Finally, check-sat to verify that the system satisfiable.	"(declare-const a_friend_if Bool)
(declare-const if_friend_a Bool)
(assert (= a_friend_if if_friend_a))
(assert (= true a_friend_if))
(check-sat)"
Determine whether a person is married to their spouse	Use QF_LIA and (set-logic QF_UF) with valid constraints to prove that a person is not married to their spouse.	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Prove that there does not exist an integer x such that x^2 + 1 = 0	This statement can be proven using the QF_LIA theory, specifically by assuming x is an integer and then deriving a contradiction.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that if person A is friends with person B and person C, then person A and person C are connected by a friendship chain	Use QF_UF to represent friendships between people and QF_LIA to ensure the structure of the friendship graph is consistent.	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Determine if all people in a social network have at least one friend.	Use QF_UF and assert statements to model relationships between individuals, then use the check-sat solver to verify validity.	"(declare-const a_friend_at Bool)
(declare-const at_friend_a Bool)
(assert (= a_friend_at at_friend_a))
(assert (= true a_friend_at))
(check-sat)"
Prove that there exist two people in a social network such that they are friends and not spouses.	Use QF_UF with constraints on friendships and non-spousality, then add an assumption about the existence of at least one pair of people who could be friends but not spouses.	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (not a_friend_in))
(assert (not in_friend_a))
(check-sat)"
Prove that there does not exist an integer k such that k^2 + 5k - 6 = 0	(assert (integer s) (> 0 ? 1 : 2)) (assert (syms x k real) > 0) (assert (satisfies (e (univariate x) (- 6 x 6 k^2 + 5 k))) > 0) ((set-logic QF_UF) (declare-const s real)) ((check-sat))	"(declare-const an Int)
(declare-const k Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 k) (<= k 10)))
(assert (distinct an k))
(check-sat)"
Determine whether it is possible to construct a social network where all individuals are connected and no two individuals are friends	The graph of friendships can be represented as an undirected graph with weighted edges, where each edge has a weight representing the strength of the friendship. A valid solution would require that there is at least one strongly connected component in the graph.	"(declare-const a_friend_is Bool)
(declare-const is_friend_a Bool)
(assert (= a_friend_is is_friend_a))
(assert (= true a_friend_is))
(check-sat)"
Prove that if Alice is friends with Bob and Bob is friends with Charlie, then Alice is friends with Charlie	Use QF_UF with constraints that express the friendship relationships as valid integer solutions. Ensure the model is satisfiable by checking for consistency.	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (= if_friend_is is_friend_if))
(assert (= true if_friend_is))
(check-sat)"
Prove the following sentence is valid in QF_UF	Use the set-logic QF_UF and assert statements to derive the sentence.	"(declare-const in Int)
(declare-const is Int)
(assert (and (<= 1 in) (<= in 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct in is))
(check-sat)"
Given a person A with age 25 and friend B, prove that if A's friends are all friends of C then A is friends of B.	(declare-const A Person (0: 1) (declare-const B Person (0: 1) (declare-const C Person (0: 1))  (   (            (forall x (Person (x)) (         (set-of y (Set-of-z) z)))        ) )  (   (assert (or (A= B) (All-of-A-Friend-Of-B-C A C))))	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Prove that if person1 is friends with person2 and person3, then person4 is not friends with person5.	{'method': 'existential', 'variables': ['person1', 'person2', 'person3', 'person4', 'person5'], 'constraints': ['(set-logic QF_UF)\n\n', '(declare-const person1 person1)\n', '(declare-const person2 person2)\n', '(declare-const person3 person3)\n', '(assert (person1 <> person2))\n', '(assert (person1 <> person3))\n', '(assert (not (person4 <>) (person5 <)))']}	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (not if_friend_is))
(assert (not is_friend_if))
(check-sat)"
The relationship 'John Doe' and 'Jane Smith' are friends.	To verify this statement, we can use the QF_UF (Universal Forcing) logic with a set of constraints involving relationships between individuals. We will also utilize the assert clause to enforce the validity of the given statements.	"(declare-const X_friend_Y Bool)
(declare-const Y_friend_X Bool)
(assert (= X_friend_Y Y_friend_X))
(assert (= true X_friend_Y))
(check-sat)"
The given social network of friends has exactly 5 people.	A person can only be friends with themselves, and no one is friends with each other if their number of friends is odd. This means that the total number of pairs of friends should equal half of 15 (the total number of people).	
Prove that there exists an integer x such that x + 1 = 2x	Use the QF_UF and QF_LIA rules to derive the desired consequence.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that there are no cycles in the graph G = ({a, b, c}, R), where R is an undirected relation and 'a' and 'b' are related to each other, but not both.	Use QF_UF and set-logic to reason about the satisfiability of this graph. Assume X = {a, b} such that X  G. Prove by contradiction that there exists a path from a to c in G if and only if for all y  X, (y, x)  R.	"(declare-const G Int)
(declare-const R Int)
(assert (and (<= 1 G) (<= G 10)))
(assert (and (<= 1 R) (<= R 10)))
(assert (distinct G R))
(check-sat)"
Pigeonhole Principle	Given n pigeons and m pigeonholes, show that at least one pigeonhole must contain more than one pigeon.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
The following social relationship constraint is valid: P(x, y) |= Q(x, z), where P, Q are predicates and x, y, z are atoms.	To prove the validity of this constraint, we need to show that it is satisfiable using a finite model.	"(declare-const P_friend_Q Bool)
(declare-const Q_friend_P Bool)
(assert (= P_friend_Q Q_friend_P))
(assert (= true P_friend_Q))
(check-sat)"
Verify that a social constraint involving two individuals and their relationships holds true	{'method': 'existential quantification'}	
Prove that all employees in the company are working	Using set-logic QF_UF and QF_LIA, derive the following implications: (set-of-people employee1 ... employee5) => (work(employee1, employee2), work(employee3, employee4), work(employee5, employee6))	"(assert true)
(check-sat)"
Prove that John and Mary are married	(set-logic QF_UF) (declare-const John mary : bool) (assert (== John mary)) (check-sat)	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that if person1 is friends with person2, and person2 is friends with person3, then person1 is friends with person3.	Use the transitive property of friendship to prove this implication.	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (= if_friend_is is_friend_if))
(assert (= true if_friend_is))
(check-sat)"
Prove that a person is either in their hometown or not.	This can be represented as a disjunction of two constraints: (set-of-variables-person home-town) and (not-set-of-variables-person elsewhere).	"(declare-const a Int)
(declare-const in Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct a in))
(check-sat)"
Find all pairs of people in a social network where one person is friends with another.	Use QF_UF to model friendship relationships and check-sat to solve the problem	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (not a_friend_in))
(assert (not in_friend_a))
(check-sat)"
Prove that any person is either a student or an employee of the same company.	{   (set-logic QF_UF)   (declare-const C (Symbol('Company'))   (declare-const S (Symbol('Student'))   (declare-const E (Symbol('Employee'))   (assert (not (or (= C S) (= C E))))   (assert (not (and (= S C) (= E C)))   (assert (not (or (= S E) (= C E)))))   (check-sat) }	"(declare-const a Int)
(declare-const an Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 an) (<= an 10)))
(assert (distinct a an))
(check-sat)"
Prove that a person is either married to their spouse or not married at all	Use QF_UF and assert variables for marriage status, then check-sat	"(declare-const a Int)
(declare-const at Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 at) (<= at 10)))
(assert (distinct a at))
(check-sat)"
Prove that John and Mary have different favorite sports.	Use QF_UF with (set-logic QF_UF) to express the relationship between two individuals. Then, use (assert ...) to assert a specific property about their preferences. Finally, check-sat to prove this property holds true.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Prove that John and Alice are friends.	(john = alice) -> (friend john alicia)	"(declare-const X_friend_Y Bool)
(declare-const Y_friend_X Bool)
(assert (= X_friend_Y Y_friend_X))
(assert (= true X_friend_Y))
(check-sat)"
A university has two social constraints regarding friendships between students.	These constraints can be represented using QF_UF and QF_LIA axioms.	
Prove that a person is either in the US or has a valid US driver's license.	Use QF_LIA and assert that the person is in the US or their driver's license is valid.	"(declare-const US Int)
(declare-const a Int)
(assert (and (<= 1 US) (<= US 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct US a))
(check-sat)"
Prove that every person has at least one friend	Use QF_LIA and QF_UF to model the friendship relationship between people	"(declare-const at_friend_has Bool)
(declare-const has_friend_at Bool)
(assert (= at_friend_has has_friend_at))
(assert (= true at_friend_has))
(check-sat)"
Satisfies QF_UF rule with a valid JSON payload	"{'solver': 'CPVEX', 'input': '{""solution"": ""1"", ""constraints"": [""x + y = 2""]}', 'expected_solution': '[0, 3]'}"	"(assert true)
(check-sat)"
The social network has a relationship between John and Alice, but they are not friends.	{'constraints': ['(set-logic QF_UF)\n', '(declare-const person1 person2)\n', '(assert (not (person1 = person2)))\n', '(check-sat)']}	
\(set-logic QF_UF\) \(declare-const x = 5\) \(assert \((\u'== 4\)\))	This proof uses QF_UF to prove a simple equality and QF_LIA to derive the truth of the assertion.	"(declare-const u Int)
(declare-const x Int)
(assert (and (<= 1 u) (<= u 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct u x))
(check-sat)"
The relationship between person A and person B is that they are friends.	This can be expressed as (set-logic QF_UF)      (declare-const personA personA   declare-const personB personB   assert (personA == personB))   (assert (not (personA != personB)))	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
\(set-of\(\{x| x #= 1\} \) && \(set-of\(\{y| y #!= 2 && !x || y #<= 3\} \))\)	\(declare-const x 1; \(declare-const y 2; \(assert (xor (and (not (eq x 1) (neq x 2)) (not (eq x 1) (lt x 3))) (and (neq x 1) (gt x 3)));\)	"(declare-const of Int)
(declare-const x Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct of x))
(check-sat)"
Prove that there exists an integer x such that 2*x + 3 >= 5 and x^2 <= 4	Use QF_UF to model the system of linear inequalities: 2x + 3 >= 5 --> 2x >= 2 --> x >= 1; x^2 <= 4 --> x <= -2	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that for all integers x and y, if x > y then x + y = 2y	Using QF_UF with the set of integers and the implication rule, derive the following:   (declare-const x Int) (declare-const y Int) (assert (x > y)) (check-sat)	"(declare-const if Int)
(declare-const x Int)
(assert (and (<= 1 if) (<= if 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct if x))
(check-sat)"
{'solver': 'QF_UB', 'reasoning': '(set-logic QF_LIA (declare-const x 0: INTEGER) (assert (>= x 1)) (check-sat))'}	(assert (>= 2 3)) (check-sat)	"(assert true)
(check-sat)"
Prove that if Alice and Bob are friends, then Carol is also friends with both of them.	(set-logic QF_UF)                (declare-const alice friend bob)     (assert (not (friend bob alice)))     (declare-const carol friend alicebob)     (assert (and (friend alicebob carol) (friend alice carol)))	"(declare-const if_friend_is Bool)
(declare-const is_friend_if Bool)
(assert (= if_friend_is is_friend_if))
(assert (= true if_friend_is))
(check-sat)"
Prove that there are no friends among five people.	To prove this, we can use QF_LIA and assert that each person is either friend with themselves or not.	
A person is either married to their spouse or in a consensual relationship with someone else.	This property can be expressed using QF_UF (Unions of First-Order) and constraints such as <person> marry <other_person>	"(declare-const A_friend_a Bool)
(declare-const a_friend_A Bool)
(assert (= A_friend_a a_friend_A))
(assert (= true A_friend_a))
(check-sat)"
Verify that there are no social connections between all individuals in a network of 10 people with no mutual friends	Use QF_UF to model the relationship as a graph, and then use QF_LIA to check if the graph is acyclic. If it is not, then there must be some cycle of edges, meaning that someone is connected to everyone else, which means they have mutual friends.	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (= a_friend_in in_friend_a))
(assert (= true a_friend_in))
(check-sat)"
(set-logic QF_UF (declare-const x y z (integer :pred <)) (assert (not (= x 5))) (check-sat)	(check-sat)	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that there exist distinct integers x, y such that x + y = 3 and x  y	Using QF_UF and the constraints x + y = 3 and x  y, derive a contradiction if neither x nor y is equal to zero.	"(declare-const x Int)
(declare-const y Int)
(assert (and (<= 1 x) (<= x 10)))
(assert (and (<= 1 y) (<= y 10)))
(assert (distinct x y))
(check-sat)"
Prove that a person who has friends with people they know personally and strangers, but does not have acquaintances outside of their social circle, cannot be a friend to any one specific stranger.	Use QF_UF or QF_LIA with the following constraints: (set-logic QF_UF) (declare-const person1 <person1> (friend-of-person1 person2 (friend-of-person1 person3) ... (not acquaintances person4 person5))) (assert (for-all x (forall y (not friend-of-person1 y x))) (not (in-a-social-circle x)))	"(declare-const a_friend_be Bool)
(declare-const be_friend_a Bool)
(assert (not a_friend_be))
(assert (not be_friend_a))
(check-sat)"
Prove that there exist non-empty sets A and B of people such that A  B = 	"The following set constraints ensure the existence of such sets:  - A (A  X)   	B (B  A);"	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
Social Network Problem	The following friendship relationships hold: (Alice, Bob), (Bob, Charlie), (Charlie, Alice). Find the maximum number of friends each person can have.	"(declare-const X Int)
(declare-const Y Int)
(assert (and (<= 1 X) (<= X 10)))
(assert (and (<= 1 Y) (<= Y 10)))
(assert (distinct X Y))
(check-sat)"
Given two people A and B, where person A is related to person B by marriage if A's age is greater than B's age.	Use QF_UF or QF_LIA with set-logic to express the relationship between ages of individuals for any positive integers n and m (where n <= m).	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
Prove that if person A has degree 3 and person B has degree 4, then person A's age is greater than or equal to person B's age	This implication can be proved using QF_UF or QF_LIA.	"(declare-const A Int)
(declare-const B Int)
(assert (and (<= 1 A) (<= A 10)))
(assert (and (<= 1 B) (<= B 10)))
(assert (distinct A B))
(check-sat)"
Prove that there exists an integer x such that x^2 = 5 and x^4 + 2x^2 - 1	Use QF_UF to reason about the existence of a solution and then use QLIA to solve for x.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that two people are acquaintances if they have met at least once	(set-logic QF_UF) (declare-const person1 :: int) (declare-const person2 :: int) (assert (person1 = person2)) (check-sat)	"(declare-const at Int)
(declare-const if Int)
(assert (and (<= 1 at) (<= at 10)))
(assert (and (<= 1 if) (<= if 10)))
(assert (distinct at if))
(check-sat)"
Given the social network of individuals with attributes 'name' and 'relationship_type', find the maximum number of people who are directly related to each other.	This can be solved using QF_UF or QF_LIA, where we express a relationship between two individuals as an equivalence relation. We then use the fact that the size of an equivalence relation is equal to the number of pairs of distinct elements in the set. This allows us to compute the maximum number of people who are directly related to each other.	"(declare-const of_friend_to Bool)
(declare-const to_friend_of Bool)
(assert (= of_friend_to to_friend_of))
(assert (= true of_friend_to))
(check-sat)"
Prove that there exists an integer x such that x + 1 = 2 * x	Use QF_UF and set-logic to prove the statement	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that a person can go to exactly two different cities if they travel between cities in different countries.	Using the QF_UF model with a set of cities and countries, prove that the person's travel history is consistent.	"(declare-const a Int)
(declare-const can Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 can) (<= can 10)))
(assert (distinct a can))
(check-sat)"
Prove that a person is either married or single.	(set-of-values x:Person; (set-of-assertions x:-single | x:-married))	"(declare-const a Int)
(declare-const is Int)
(assert (and (<= 1 a) (<= a 10)))
(assert (and (<= 1 is) (<= is 10)))
(assert (distinct a is))
(check-sat)"
Use QF_LIA to express the relationship between friends and their relationships with others.	Use QF_UF with a set of 'not' constraints to express the relationship between individuals.	
Find all triples (a, b, c) where a has degree 2 in graph G and b is adjacent to both a and c	Use QF_LIA constraints to enforce the properties of the relationships.	"(declare-const G Int)
(declare-const a Int)
(assert (and (<= 1 G) (<= G 10)))
(assert (and (<= 1 a) (<= a 10)))
(assert (distinct G a))
(check-sat)"
Find all pairs of distinct people in a university with exactly one common friend.	Use QF_UF to model this relationship and QLIA to restrict the number of friends each person can have.	"(declare-const a_friend_in Bool)
(declare-const in_friend_a Bool)
(assert (= a_friend_in in_friend_a))
(assert (= true a_friend_in))
(check-sat)"
The set of all prime numbers less than or equal to 100	{(set-logic QF_UF) {(declare-const P UU)   assert (forall (x UU) ( eg ((xor x P) (xor P x))))	"(declare-const of Int)
(declare-const or Int)
(assert (and (<= 1 of) (<= of 10)))
(assert (and (<= 1 or) (<= or 10)))
(assert (distinct of or))
(check-sat)"
The given social relationship is valid.	Use QF_UF and set-logic QF_UF to ensure validity of constraints.	
Prove that every person is related to themselves.	Use QF_UF to assert that each person is connected to at least one other person, and then use QF_LIA to conclude that there are no cycles in the graph.	"(declare-const is Int)
(declare-const to Int)
(assert (and (<= 1 is) (<= is 10)))
(assert (and (<= 1 to) (<= to 10)))
(assert (distinct is to))
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 0	Use QF_UF and set-logic to reason about the existence of solutions to this equation.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that if person A is friends with person B, and person B is friends with person C, then person A is friends with person C	Use QF_UF and QF_LIA constraints to derive the desired implication. Use the following assumptions: (A,B) and (B,C), and (C,A).	"(declare-const A_friend_B Bool)
(declare-const B_friend_A Bool)
(assert (= A_friend_B B_friend_A))
(assert (= true A_friend_B))
(check-sat)"
Prove that for all integers n >= 5, n^2 + n - 13 > 0	The following statements are true:  - set-logic QF_UF - set-logic QF_LIA - declare-const n_ int - declare-variable x int - assert (x = 5) - assert (x^2 + x - 13 > 0)	"(assert true)
(check-sat)"
Prove that there exists an integer x such that x^2 + 1 = 4x and 2x > 0	Using QF_UF with the set of variables {x} and the constraints from the problem statement, we can derive the following expression: 2 * (x^2 - 4) = 0. Solving for x, we get x = 16. Therefore, there exists an integer solution to the equation.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The friends of Alice are married, but Bob is not	To ensure this is true, we need to assert that (set-of-people x y) != (set-of-people x z)	"(declare-const is_friend_of Bool)
(declare-const of_friend_is Bool)
(assert (not is_friend_of))
(assert (not of_friend_is))
(check-sat)"
Prove that there exists an integer x such that x^2 + 4x - 3 = 0	To prove this equation has a solution, we can use the fact that it is a quadratic equation with two roots. We can also use the method of completing the square to simplify the equation.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Prove that a person is not a friend of themselves	Use   to separate the reasoning into two parts: first, prove that an individual is friends with another if they have at least one movie in common, and second, prove the converse	"(declare-const a_friend_is Bool)
(declare-const is_friend_a Bool)
(assert (not a_friend_is))
(assert (not is_friend_a))
(check-sat)"
Prove that there exists an integer x such that 2*x + 3 >= 0	To prove this, we can use the QF_UF logic with 2*u + 3 <= -u for u >= 0. This is because for any non-negative integer u, 2*u + 3 will always be greater than or equal to 1, satisfying the condition.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
The following social constraint is invalid: \nIt states that Alice and Bob are friends when they do not have a mutual friend, which is a contradiction.	\nTo resolve this conflict, we can add constraints to ensure that if Alice is friends with X, then X must also be friends with Alice. This can be achieved using the following QF_UF clause: (\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n)	"(declare-const a_friend_do Bool)
(declare-const do_friend_a Bool)
(assert (not a_friend_do))
(assert (not do_friend_a))
(check-sat)"
Prove that there does not exist an ordered pair of integers (x, y) such that x = 2 and y = 4	This statement can be proven using the QF_UF rule and the fact that x cannot be both even and odd.	"(declare-const an Int)
(declare-const of Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 of) (<= of 10)))
(assert (distinct an of))
(check-sat)"
Prove that there exists an integer x such that x + 1 = 2*x	"\begin{align*} (\exists x (\forall y (y < x \ 2*y == x+y))) &
ightarrow ((\exists z (z >= 0 \ z != -1)))) \end{align*}"	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
Satisfying the social constraint: No two people in the same group.	Use QF_UF or QF_LIA to ensure that each person is in a unique set of groups.	"(declare-const No Int)
(declare-const in Int)
(assert (and (<= 1 No) (<= No 10)))
(assert (and (<= 1 in) (<= in 10)))
(assert (distinct No in))
(check-sat)"
Prove that there exists an integer x such that 2x + 1 > 0	To prove this, we can use the QF_LIA solver with the following constraints: (set-logic QF_UF) (declare-const x Int) (assert (>= 0 (1 + 2 * x)))	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
A university has two classes: History and English.	The class that starts later must be the one with more students	"(declare-const A Int)
(assert (and (<= 1 A) (<= A 3)))
(check-sat)"
Prove that if Alice and Bob both have a pet cat, then they are friends.	\begin{qf uf} \setof(x:person) (x ~ x.pet.cat) & (x ~ y.pet.cat) \declare-relation(p,q:friend)(p.y ~ q.y) \check-sat	"(declare-const a_friend_if Bool)
(declare-const if_friend_a Bool)
(assert (= a_friend_if if_friend_a))
(assert (= true a_friend_if))
(check-sat)"
PREDicates and Atomic Variables: Prove that there exists an integer x such that x^2 = 0	The solution to this problem can be proven using QF_UF, given the constraints (set-logic QF_UF) and (declare-const x :: int). The key insight is to recognize that if there does not exist an integer x such that x^2 = 0, then we must have a contradiction. This would mean that either x or x+1 cannot be zero, which implies that x is not an integer, leading to a contradiction.	"(declare-const an Int)
(declare-const x Int)
(assert (and (<= 1 an) (<= an 10)))
(assert (and (<= 1 x) (<= x 10)))
(assert (distinct an x))
(check-sat)"
